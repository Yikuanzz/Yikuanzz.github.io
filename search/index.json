[{"content":"Python 计算 数字 # 加减乘除 print(2 + 2)\t# 4 print(4 - 3)\t# 1 print(6 * 2) # 12 print(17 / 3)\t# 5.666667 # 去掉小数点 print(17 // 3) # 5 # 取模运算 print(17 % 3)\t# 2 # 幂运算 print(3 ** 2)\t# 9 # 变量赋值 tax = 12.5 / 100 price = 100.50 print(price * price) 文本 # 打印字符串 print(\u0026#34;Hello\u0026#34;)\t# Hello # 转义 print(\u0026#34;I\\\u0026#39;m\u0026#34;)\t# I\u0026#39;m print(r\u0026#39;C:\\user\\local\u0026#39;) # C:\\user\\local # 打印多行 print(\u0026#34;\u0026#34;\u0026#34;\\ Man, what can I said. \u0026#34;\u0026#34;\u0026#34;) # 字符拼接 print(2*\u0026#34;O\u0026#34; + \u0026#34;k\u0026#34;)\t# OOK 列表 # 打印列表 squares = [1, 4, 9] print(squares)\t# [1, 4, 9] # 索引切片 squares[0]\t# 1 squares[-1] # 9 squares[-2:] # [4, 9] # 相同引用 rgb = [\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;] rgba = rgb print(id(rgb) == id(rgba))\t# True # 清空列表 squares[:] = [] print(squares) # [] Python 流程控制 分支结构 # if 语句 x = intput(\u0026#34;请输入一个数字：\u0026#34;) if x \u0026lt; 0: print(\u0026#34;x是负数！\u0026#34;) elif x == 0: print(\u0026#34;x是零！\u0026#34;) else: print(\u0026#34;x是正数！\u0026#34;) 循环结构 # for 循环 animals = [\u0026#39;cat\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;] for a in animals: print(a, len(a)) # 迭代集合副本 weeks = {\u0026#39;Mon\u0026#39;:1, \u0026#39;Tue\u0026#39;:2, \u0026#39;Wen\u0026#39;:3} for d, n in weeks.copy().items(): print(d, n) 其他语句 # range()函数 for i in range(4): print(i)\t# 0 1 2 3 print(list(range(3, 5)))\t# 3 4 print(list(range(0, 10, 3)))\t# 0 3 6 9 print(sum(range(4)))\t# 6 # break 和 continue for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, \u0026#39;相当于\u0026#39;, x, \u0026#39;*\u0026#39;, n//x) break else: print(n, \u0026#39;是质数\u0026#39;) for num in range(2, 10): if num % 2 == 0: print(\u0026#34;偶数 \u0026#34;, num) continue print(\u0026#34;奇数 \u0026#34;, num) # pass 什么也不执行 while True: pass # match\t\u0026#34;_\u0026#34; 为通配符 一定会执行 def http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 401|403: return \u0026#34;Not allowed\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: return \u0026#34;I\u0026#39;m a teapot\u0026#34; case _:\treturn \u0026#34;Something\u0026#39;s wrong with the internet\u0026#34; Python 函数 函数定义 def fib(n): a, b = 0, 1 while a \u0026lt; n: print(a, end=\u0026#39; \u0026#39;) a, b = b, a + b print() def ask_ok(prompt, retries=4, reminder=\u0026#39;Please try again!\u0026#39;): while True: reply = input(prompt) if reply in {\u0026#39;y\u0026#39;, \u0026#39;ye\u0026#39;, \u0026#39;yes\u0026#39;}: return True if reply in {\u0026#39;n\u0026#39;, \u0026#39;no\u0026#39;, \u0026#39;nop\u0026#39;, \u0026#39;nope\u0026#39;}: return False retries = retries - 1 if retries \u0026lt; 0: raise ValueError(\u0026#39;invalid user response\u0026#39;) print(reminder) 函数参数 # *name 接收元组 **name 接收字典 def fun(*argument, **keywords): for arg in argument: print(arg) print(\u0026#34;-------\u0026#34;) for kw in kewords: print(kw, \u0026#34;:\u0026#34;, keywords[kw]) # / 限制前面的参数只能按位置传递 # * 限制后面的参数只能按关键字传递 def combined_example(pos_only, /, standard, *, kwd_only): print(pos_only, standard, kwd_only) print(combined_example(1, 2, kwd_only=3)) # 任意参数列表 def concat(*args, sep=\u0026#34;/\u0026#34;) return sep.join(args) print(concat(\u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;venus\u0026#34;))\t# \u0026#39;earth/mars/venus\u0026#39; # * 将实参从列表或元组解包 args = [3, 6] print(list(range(*args))) Lambda表达式 # 匿名函数写法 def make_incrementor(n): return lambda x: x + n; f = make_incrementor(3) print(f(1))\t# 4 print(f(2))\t# 6 # 匿名函数作实参 paris = [(1, \u0026#39;one\u0026#39;), (2, \u0026#39;two\u0026#39;), (3, \u0026#39;three\u0026#39;), (4, \u0026#39;four\u0026#39;)] paris.sort(key=lambda pair:pair[1]) print(paris) 函数注解 # -\u0026gt; 用来指示函数返回类型\t# __annotations__ 是函数的注解 def f(ham: str, eggs: str = \u0026#39;eggs\u0026#39;) -\u0026gt; str: print(\u0026#34;Annotations:\u0026#34;, f.__annotations__) print(\u0026#34;Arguments:\u0026#34;, ham, eggs) return ham + \u0026#39; and \u0026#39; + eggs 高阶函数 map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\nr = map(lambda x: x*x, [1, 2, 3, 4]) print(list(r)) reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。\nfrom functools import reduce i = reduce(lambda x, y: 10*x + y, [j for j in range(10) if j % 2 != 0]) print(i) filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\ndef is_odd(n): return n % 2 == 1 print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))) yield用法。\ndef g(n): while n \u0026gt; 0: yield n n = n - 1 print(g(10)) Python 数据结构 列表 # 定义列表 animals = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;] # count() 计数 print(animals.count(\u0026#39;panda\u0026#39;))\t# 2 # index() 索引 print(animals.index(\u0026#39;elephant\u0026#39;))\t# 4 # reverse() 反转 print(animals.reverse())\t# [\u0026#39;panda\u0026#39;，\u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;] # append() 添加 print(animals.append(\u0026#39;pig\u0026#39;))\t# [\u0026#39;cat\u0026#39;，\u0026#39;dog\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;pig\u0026#39;] # sort() 排序 animals.sort() print(animals)\t# [\u0026#39;cat\u0026#39;，\u0026#39;dog\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;pig\u0026#39;] # pop() 弹出 print(animals.pop)\t# pig # 列表实现栈 stack = [3, 4, 5] # 入栈 stack.append(6) # 出栈 stack.pop() # 列表实现队列 from collections import deque queue = deque([\u0026#34;Mike\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Tim\u0026#34;]) # 入队 queue.append(\u0026#34;Terry\u0026#34;) # 出队 queue.popleft() 元组和序列 # 元组由多个逗号隔开的值组成 tuples = 123, 4455, \u0026#39;python\u0026#39; print(t)\t# (123, 455, \u0026#39;python\u0026#39;) t = ([1,2,3], [3,2,1]) print(t)\t# ([1,2,3], [3,2,1]) 集合 # 创建集合用 {} 或 set() basket = {\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;} print(basket)\t# {\u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;apple\u0026#39;} a = set(\u0026#39;abracadabra\u0026#39;) b = set(\u0026#39;alacazam\u0026#39;) print(a - b)\t# \u0026#39;r\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39; print(a | b)\t# \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;l\u0026#39; print(a \u0026amp; b)\t# \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39; print(a ^ b)\t# \u0026#39;r\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;l\u0026#39; 字典 # 字典是键值对 tel = {\u0026#39;jack\u0026#39;: 4098, \u0026#39;sape\u0026#39;: 4139} t = dict([(\u0026#39;sape\u0026#39;, 4139), (\u0026#39;guido\u0026#39;, 4127), (\u0026#39;jack\u0026#39;, 4098)]) # 删除 del tel[\u0026#39;jack\u0026#39;] # 添加 tel[\u0026#39;irv\u0026#39;] = 4127 # 判断 print(\u0026#39;guido\u0026#39; in del)\t# True 循环技巧 # items() 提取键值对 knights = {\u0026#39;gallahad\u0026#39;: \u0026#39;the pure\u0026#39;, \u0026#39;robin\u0026#39;: \u0026#39;the brave\u0026#39;} for k, v in knights.items(): print(k, v) # enumerate() 提取索引和值 for i, v in enumerate([\u0026#39;tic\u0026#39;, \u0026#39;tac\u0026#39;, \u0026#39;toe\u0026#39;]): print(i, v) # zip() 循环多个序列 questions = [\u0026#39;name\u0026#39;, \u0026#39;quest\u0026#39;, \u0026#39;favorite color\u0026#39;] answers = [\u0026#39;lancelot\u0026#39;, \u0026#39;the holy grail\u0026#39;, \u0026#39;blue\u0026#39;] for q, a in zip(questions, answers): print(\u0026#39;What is your {0}? It is {1}.\u0026#39;.format(q, a)) # reversed() 逆向 for i in reversed(range(1, 10, 2)): print(i) # sorted() 排序 basket = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;] for i in sorted(basket): print(i) Python IO编程 由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。同步和异步的区别就在于是否等待IO执行的结果。\n文件读写 # 以读文件模式打开一个文件对象 f = open(\u0026#34;/Users/local/test.txt\u0026#34;, \u0026#39;r\u0026#39;) # 一次读取文件全部内容 f.read() # 关闭文件 f.close() # 用 with 自动关闭文件和处理异常 # f.readline()：读取单行数据保留换行符 # f.readline()：返回空字符串表示到文件末尾 # f.tell()：返回文件对象在文件中的位置 # f.seek(offset, whence)：可改变文件对象位置 with open(\u0026#39;/Users/local/test.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f.readlines(): print(line.strip())\t# 去掉换行符 with open(\u0026#39;/Users/local/test.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: f.write(\u0026#39;Hello, World!\u0026#39;) 内存读写 # StringIO 将字符串写入内存 from io import StringIO f = StringIO() f.write(\u0026#34;Hello\u0026#34;) print(f.getvalue()) # BytesIO 将字节写入内存 from io import BytesIO f = BytesIO() f.write(\u0026#39;中文\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) print(f.getvalue()) 文件和目录操作 # 导入 OS import os # 查看当前目录的绝对路径 os.path.abspath(\u0026#39;.\u0026#39;) # 新目录完整路径表示 os.path.join(\u0026#39;/Users/local\u0026#39;, \u0026#39;testdir\u0026#39;) # 创建目录 os.mkdir(\u0026#39;/Users/local/testdir\u0026#39;) # 删除目录 os.rmdir(\u0026#39;/Users/local/testdir\u0026#39;) # 文件路径拆分 os.path.split(\u0026#39;/Users/local/testdir/file.txt\u0026#39;) # 获取文件拓展名 os.path.splitext(\u0026#39;/Users/local/testdir/file.txt\u0026#39;) # 文件重命名 os.rename(\u0026#34;file.txt\u0026#34;, \u0026#34;file.py\u0026#34;) # 文件删除 os.remove(\u0026#34;file.py\u0026#34;) # 列出当前目录下所有目录 [x for x in os.listdir(\u0026#39;.\u0026#39;) if os.path.isdir(x)] # 列出所有 .py 文件 [x for x in os.listfir(\u0026#39;.\u0026#39;) if os.path.isfile(x) and os.paht.splitext(x)[1]=\u0026#39;.py\u0026#39;] 序列化 把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\n# 将对象序列化为 bytes import pickle d = {\u0026#39;name\u0026#39;:\u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:88} print(pickle.dumps(d)) # 将序列化的对象写入文件 with open(\u0026#39;dump.txt\u0026#39;, \u0026#39;wb\u0026#39;) as f: pickle.dump(d, f) # 直接读取序列化对象 with open(\u0026#39;dump.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: print(pickle.load(f)) # JSON 格式 import json d = {\u0026#39;name\u0026#39;:\u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:88} print(json.dumps(d)) # 将序列化的对象写入文件 with open(\u0026#39;dump.json\u0026#39;, \u0026#39;w\u0026#39;) as f: json.dump(d, f) # 直接读取序列化对象 with open(\u0026#39;dump.json\u0026#39;, \u0026#39;r\u0026#39;) as f: print(json.load(f)) # 类要转换为字典才能被序列化 print(json.dumps(s, default=lambda obj: obj.__dict__)) # 同理，反序列化也是一样的 print(json.loads(json_str, object_hook=dict2student)) 字符串格式化 # 格式化字面值 year = 2024 name = \u0026#39;Mike\u0026#39; print(f\u0026#39;{name} love {year}\u0026#39;) # str.format() 方法 yes_votes = 42_572_654 no_votes = 43_132_495 percentage = yes_votes / (yes_votes + no_votes) print(\u0026#39;{:-9} YES votes {:2.2%}\u0026#39;.format(yes_votes, percentage)) print(\u0026#39;{0}, {1}\u0026#39;.format(yes_votes, percentage)) Python 错误和异常 错误可（至少）被分为两种：语法错误 和 异常。\n异常处理 # 单个值异常 while True: try: x = int(input(\u0026#34;Please enter a number: \u0026#34;)) break except ValueError: print(\u0026#34;Oops! That was no valid number. Try again...\u0026#34;) # 多个异常处理 import sys try: f = open(\u0026#39;myfile.txt\u0026#39;) s = f.readline() i = int(s.strip()) except OSError as err: print(\u0026#34;OS error:\u0026#34;, err) except ValueError: print(\u0026#34;Could not convert data to an integer.\u0026#34;) except Exception as err: print(f\u0026#34;Unexpected {err=}, {type(err)=}\u0026#34;) raise # else 子句 for arg in sys.argv[1:]: try: f = open(arg, \u0026#39;r\u0026#39;) except OSError: print(\u0026#39;cannot open\u0026#39;, arg) else: print(arg, \u0026#39;has\u0026#39;, len(f.readlines()), \u0026#39;lines\u0026#39;) f.close() 异常触发 # raise 强制触发异常 raise NameError(\u0026#39;HiThere\u0026#39;) # 只想判断是否有异常但不处理 try: raise NameError(\u0026#39;HiThere\u0026#39;) except NameError: print(\u0026#39;An exception flew by!\u0026#39;) raise 调用栈 如果错误没有被捕获，它就会一直往上抛，最后被 Python 解释器捕获，打印一个错误信息，然后程序退出。\n# 可以记录错误信息 def foo(s): return 10 / int(s) def bar(s): return foo(s) * 2 def main(): try: bar(\u0026#39;0\u0026#39;) except Exception as e: logging.exception(e) main() 调试 # assert def foo(s): n = int(s) # 如果 n !=0 就会抛出错误 assert n != 0, \u0026#39;n is zero!\u0026#39; return 10 / n def main(): foo(\u0026#39;0\u0026#39;) # logging # 级别：debug、info、warning、error import logging logging.basicConfig(level=logging.INFO) s = \u0026#39;0\u0026#39; n = int(s) logging.info(\u0026#39;n = %d\u0026#39; % n) print(10 / n) 单元测试 单元测试是用来对一个模块、一个函数或一个类来进行正确性检验的测试工作。\n# Dict类 class Dict(dict): def __init__(self, **kw): super().__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\u0026#34;\u0026#39;Dict\u0026#39; object has no attribute \u0026#39;%s\u0026#39;\u0026#34; % key) def __setattr__(self, key, value): self[key] = value # Dict测试 \u0026#34;\u0026#34;\u0026#34; assertEqual(abs(-1), 1)\t断言函数返回结果与1是否相等 assertRaises(KeyError)\t期待抛出指定类型异常 \u0026#34;\u0026#34;\u0026#34; import unittest from mydict import Dict class TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b=\u0026#39;test\u0026#39;) self.assertEqual(d.a, 1) self.assertEqual(d.b, \u0026#39;test\u0026#39;) self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; self.assertEqual(d.key, \u0026#39;value\u0026#39;) def test_attr(self): d = Dict() d.key = \u0026#39;value\u0026#39; self.assertTrue(\u0026#39;key\u0026#39; in d) self.assertEqual(d[\u0026#39;key\u0026#39;], \u0026#39;value\u0026#39;) def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d[\u0026#39;empty\u0026#39;] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty # setUP 与 tearDown 分别在测试方法调用前后执行 class TestDice(unittest.TestCase): def setUp(self): print(\u0026#39;setUp..\u0026#39;) def tearDown(self): print(\u0026#39;tearDown..\u0026#39;) Python 面向对象编程 作用域和命名空间 \u0026#34;\u0026#34;\u0026#34; nonlocal 会改变 scope_test 对 spam 的绑定 global 会改变模块层级的绑定 \u0026#34;\u0026#34;\u0026#34; def scope_test(): def do_local(): spam = \u0026#34;local spam\u0026#34; def do_nonlocal(): nonlocal spam spam = \u0026#34;nonlocal spam\u0026#34; def do_global(): global spam spam = \u0026#34;global spam\u0026#34; spam = \u0026#34;test spam\u0026#34; do_local() print(\u0026#34;After local assignment:\u0026#34;, spam) do_nonlocal() print(\u0026#34;After nonlocal assignment:\u0026#34;, spam) do_global() print(\u0026#34;After global assignment:\u0026#34;, spam) scope_test() print(\u0026#34;In global scope:\u0026#34;, spam) 类基础 # 定义一个基础的类 class Dog: def __init__(self, name): # 在变量前 __ 就变成私有变量 self.__name = name self.tricks = [] def add_trick(self, trick): self.tricks.append(trick) 继承和多态 # 继承基类方法，多态覆盖基类方法 class Animal(object): def run(self): print(\u0026#39;Animal is running...\u0026#39;) class Dog(Animal): def run(self): print(\u0026#39;Dog is running...\u0026#39;) class Cat(Animal): pass # 判断某个变量是否是某个类型 a = Animal() d = Animal() print(a, Animal) # True print(d, Animal) # True 定制类 # __str__ 打印类实例 class Student: def __init__(self, name): self.name = name def __str__(self): return \u0026#39;Student object (name: %s)\u0026#39; % self.name # __repr___ 直接显示变量调用信息 __repr___ = __str___ print(Student(\u0026#34;Tom\u0026#34;)) # __iter__ 获取一个迭代对象 class Fib: def __init___(self): self.a, self.b = 0, 1 def __iter___(self): return self def __next___(self): self.a, self.b = self.b, self.a + self.b if self.a \u0026gt; 100_100: raise StopIteration() return self.a # __getitem__ 用下标取出元素 class Fib: def __getitem__(self, n): if isinstance(n, int)\t# n 是索引的时候 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice)\t# n 是切片 start = 0 if n.slice is None else n.slice stop = n.stop a, b = 1, 1 L = [] for x in range(stop): if x \u0026gt;= start: L.append(a) a, b = b, a + b return L # __getattr___ 动态返回一个属性 class Student: def __init__(self): self.name = \u0026#39;Mike\u0026#39; def __getattr__(self, attr): if attr==\u0026#39;score\u0026#39;: return 99 elif attr==\u0026#39;age\u0026#39;: return lambda: 25 # __call()__ 直接调用实例 class Student(object): def __init__(self, name): self.name = name def __call__(self): print(\u0026#39;My name is %s.\u0026#39; % self.name) # Callable 判断调用是对象还是函数 print(callable(Student())) print(callable([1, 2, 3])) ","date":"2024-03-27T00:20:54+08:00","image":"https://yikuanzz.github.io/2024/python-%E5%9F%BA%E7%A1%80/cover_hu39a96208b41191b61a5710e1893b7c44_1174048_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/python-%E5%9F%BA%E7%A1%80/","title":"Python - 基础"},{"content":"操作系统简要 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。 操作系统本质上是一个运行在计算机上的软件程序 ，它屏蔽了硬件层的复杂性，像是硬件使用的管理员，统筹管理计算机硬件和软件资源。 操作系统的 内核（Kernel） 是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。 操作系统功能 进程和线程的管理 ：进程的创建、撤销、阻塞、唤醒，进程间的通信等。 存储管理 ：内存的分配和管理、外存（磁盘等）的分配和管理等。 文件管理 ：文件的读、写、创建及删除等。 设备管理 ：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。 网络管理 ：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。 安全管理 ：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。 用户态和内核态 用户态(User Mode) : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。 内核态(Kernel Mode) ：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。 用户态切换到内核态的方式 系统调用（Trap） ：用户态进程 主动 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。 中断（Interrupt） ：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 异常（Exception）：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 进程和线程 进程（Process） 是指计算机中正在运行的一个程序实例。PCB（Process Control Block） 为进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。 线程（Thread） 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。 一个进程内可能有多个线程，它们的区别在于进程往往是相互独立的，而线程之间可能会相互影响，需要进行通信。并且，线程的执行开销相对要小一些。\n线程的优点 多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。 同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。 线程之间的同步方式 互斥锁(Mutex) ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。 信号量(Semaphore) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 屏障（Barrier） ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 进程的状态 创建状态(new) ：进程正在被创建，尚未到就绪状态。 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。 运行状态(running) ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。 进程的通信方式 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。 有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 进程调度算法 先到先服务调度算法(FCFS，First Come, First Served) : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 短作业优先的调度算法(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 时间片轮转调度算法（RR，Round-Robin） : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 多级反馈队列调度算法（MFQ，Multi-level Feedback Queue） ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。 优先级调度算法（Priority） ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。 僵尸进程和孤儿进程 僵尸进程 ：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。 孤儿进程 ：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。 死锁 死锁（Deadlock） 描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。\n产生死锁的必要条件 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。 循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，\u0026hellip;\u0026hellip;，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。 解决死锁的方法 预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。 避免则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生。 检测是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。 解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。 死锁的预防 死锁的预防主要是通过破坏产生死锁的四个必要条件来实现的：\n静态分配策略：指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行，它破坏了占有并等待的要求。\n层次分配策略：将所有的资源分成多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，它破坏了循环等待的要求。\n死锁的避免 死锁的避免允许产生死锁的四个必要条件存在，它根据并发进程中与每个进程有关的资源动态申请情况做出进程的调度。\n我们将系统的状态分为 安全状态 和 不安全状态 ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\n如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。\n银行家算法：先 试探 分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。\n问题：（1）该状态是否安全？（2）若进程 P2 提出请求 Request（1，2，2，2）后，系统能否分配给它？\nProcess Allocation Need Avaliable P0 0 0 3 2 0 0 1 2 1 6 2 2 P1 1 0 0 0 1 7 5 0 P2 1 3 5 4 2 3 5 6 P3 0 3 3 2 0 6 5 2 P4 0 0 1 4 0 6 5 6 死锁的检测 这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 定时地运行一个 “死锁检测” 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n乐观锁和悲观锁\n乐观锁和悲观锁是两种用于解决并发场景下数据竞争问题的思想.\n乐观锁：\n乐观锁对应于生活中乐观的人，总是认为事情会往好的方向发展。 在操作数据时，乐观锁非常乐观，认为别人不会同时修改数据。 乐观锁不会上锁，只是在执行更新时判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 性能较好，大部分情况下不会阻塞其他事务的读操作。 悲观锁：\n悲观锁对应于生活中悲观的人，总是认为事情会往坏的方向发展。 在操作数据时，悲观锁比较悲观，认为别人会同时修改数据。 悲观锁在操作数据时直接将数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。 性能较差，可能会阻塞其他事务的读写操作。 死锁的解除 立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。 进程-资源分配图 在资源分配图中，进程由圆表示，资源由矩形表示。这个图可以帮助我们了解哪些进程在多使用系统资源，并且指出可能存在的瓶颈\n化简资源分配图的方法步骤如下：\n首先，查看系统还剩下多少资源未分配，然后确定哪些进程是不阻塞的（即系统有足够的空闲资源分配给它们）。 将不阻塞的进程的所有边都去掉，形成一个孤立的点，并将系统分配给这些进程的资源回收回来。 接着，查看剩下的进程中哪些是不阻塞的，然后逐个将它们变成孤立的点。 最后，所有的资源和进程都变成孤立的点。这样的图被称为“可完全简化”。如果一个图可完全简化，那么不会产生死锁；如果一个图不可完全简化（即图中还有“边”存在），则会产生死锁。 我们看到图 a，发现左边的进程资源有三个箭头是往外的，这表示它分配了三个资源，所以它没有空闲的资源。再看到右边的进程资源，有一个箭头往外，则表示它分配了一个资源，所以它有一个空闲资源。 进程看完了后，我们看进程，发现 $P_2$ 进程请求一个左边资源，但是左边的资源都分配了，所以 $P_2$ 被阻塞了。在看到 $P_1$ 它请求了一个右边的资源，恰好有空闲的资源分配，所以 $P_1$ 正常运行。 紧接着，在 $P_1$ 执行完毕后，资源释放。我们看到图 b，现在左边有两个空闲资源，右边有一个空闲资源。我们的 $P_2$ 也获得了它的需要的所有资源，所以 $P_2$ 也正常运行了。 如果进程-资源分配图中无环路，则此时系统没有发生死锁。 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。 ​\n内存管理 操作系统的内存管理非常重要，主要负责下面这些事情：\n内存的分配与回收 ：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。 地址转换 ：将程序中的虚拟地址转换成内存中的物理地址。 内存扩充 ：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。 内存映射 ：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。 内存优化 ：通过调整内存分配策略和回收算法来优化内存使用效率。 内存安全 ：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。 \u0026hellip;\u0026hellip; 内存碎片 内部内存碎片(Internal Memory Fragmentation，简称为内存碎片) ：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（$2^7$） 大小的内存，那 63 字节的内存就成为了内部内存碎片。 外部内存碎片(External Memory Fragmentation，简称为外部碎片) ：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并为分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。 内存管理 连续内存管理 ：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。 非连续内存管理 ：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。 连续内存管理\n块式管理 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。\n在 Linux 系统中，连续内存管理采用了 伙伴系统（Buddy System）算法 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 $2^6$=64 KB），并将相邻的内存块组合成一对伙伴。\n当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。\n假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。\n虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 $2^n$ 的内存块，因此当需要分配的内存大小不是 $2^n$ 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 $2^7$=128 大小的内存块。\n为了解决内部碎片的任务，Linux 使用 SLAB分配器 来解决。它将内存划分为固定大小的块，每个块就是一个 SLAB，一个 SLAB 由连续的物理页组成。如果本地高速缓存中有可用的对象，直接从本地高速缓存中分配一个SLAB。否则，执行重新填充操作，从伙伴系统的空闲内存中获取一个 SLAB 并填充到本地高速缓存中。虽然如此，但是在某些情况下它无法提供最优性能。\nSLOB 分配器：\n围绕一个简单的内存块链展开，在分配内存时使用了同样简单的最先适配算法。 主要针对嵌入式系统，特别适用于内存非常有限的系统，例如只有 32MB 以下的内存。 SLOB 的目标是使用较少的内存来实现和管理内存分配。 然而，SLOB 分配器的主要限制在于容易产生外部碎片。 SLUB 分配器：\nSLUB 是 SLAB 分配器 的进化版，旨在改进 SLAB 分配器的一些问题。 为了配合大规模并行系统，通过将页帧打包为组，并用struct page中未使用的字段来管理这些组。 SLUB 分配器与 SLAB 分配器的一些不同之处在于： 每个 CPU 结构中保存的是一个 SLAB 缓冲区，而不是空闲对象链表。 对于每个 CPU，SLUB 不再使用共享的空闲对象链表，而是直接使用单个 SLAB，并且每个 CPU 都维护有自己的部分空链表。 结构对比：\nSLAB 分配器的每个节点有三个链表：空闲 SLAB 链表、部分空 SLAB 链表和已满 SLAB 链表。 SLUB 分配器将这三个链表精简为一个链表，只保留了部分空 SLAB 链表。 SLUB 分配器的 SLAB 缓冲区结构与 SLAB 分配器的不同，它没有对象描述符数组，而是使用指针来管理空闲对象。 非连续内存管理\n段式管理 ：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 页式管理 ：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页，现代操作系统广泛使用的一种内存管理方式。 段页式管理机制 ：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。 虚拟内存 虚拟内存(Virtual Memory) 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。\n虚拟内存的好处\n隔离进程 ：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。 提升物理内存利用率 ：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。 简化内存管理 ：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。 多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。 提高内存使用安全性 ：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。 提供更大的可使用内存空间 ： 可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。 虚拟内存的缺点\n性能下降：当物理内存严重不足时，系统会频繁地进行内存和磁盘的交换（swap），这会降低系统性能。特别是在处理超大文件时，这种性能下降更为明显。 切换开销：在多个应用程序之间切换时，虚拟内存会增加一定的时间开销。因为数据需要从磁盘加载到内存，这会影响应用程序的响应速度。 磁盘空间占用：虚拟内存实际上是将一部分硬盘空间划分为内存使用，同时在硬盘上生成一个 PageFile.Sys文件。尽管这样可以弥补物理内存不足，但也会占用一定的磁盘空间，导致实际可用的磁盘空间变小。 对固态硬盘的影响：虚拟内存的读写操作会对固态硬盘的寿命产生一定影响。如果虚拟内存设置不当，可能会加速固态硬盘的磨损。 虚拟地址和物理地址 物理地址（Physical Address） 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 虚拟地址（Virtual Address） 。\n虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。每一个进程都有一个一致且私有的虚拟地址空间。 物理地址空间是物理地址的集合，是物理内存的范围。 MMU（Memory Management Unit，内存管理单元）是一种硬件模块，用于在CPU和内存之间实现虚拟内存管理。其主要功能包括：\n虚实地址翻译：当用户访问内存时，将用户访问的虚拟地址翻译为实际的物理地址，以便CPU对实际的物理地址进行访问。 访问权限控制：MMU可以对一些虚拟地址进行访问权限控制，以便于对用户程序的访问权限和范围进行管理。例如，代码段一般设置为只读，如果有用户程序对代码段进行写操作，系统会触发异常。 引申的物理内存管理：MMU负责对系统的物理内存资源进行管理，为用户程序提供物理内存的申请、释放等操作接口。 分段机制 目的：分段机制旨在将虚拟地址空间划分为不同的段，每个段对应一个连续的内存区域。\n工作原理：\n分段管理通过 段表（Segment Table） 映射虚拟地址和物理地址。 每个逻辑段都有一对基址寄存器和界限寄存器。 基址寄存器存储段的起始物理地址，界限寄存器定义了段的大小。 优点：\n灵活性：不同的段可以放置在不同的物理内存地址处，避免了虚拟地址空间中未使用部分占用内存。 共享：支持共享代码段等，确保多个进程共享某些段而不会出现问题。 缺点：\n外部碎片：段的大小不一，可能导致物理内存被分割成奇怪的大小，难以分配连续的内存。 内存分配请求复杂：需要解决外部碎片问题。 分段机制下的虚拟地址组成：\n段号 ：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。\n段内偏移量 ：相对于该段起始地址的偏移量。\n​\n段表中每个段的参数：\n段基地址：段在线性地址空间中的开始地址。 段限长：段内最大可用偏移地址，定义了段的长度。 段属性：指定段的特性，如可读、可写、可执行等。 具体的地址翻译过程如下：\n程序执行时，从进程控制块（PCB）中取出段表始址和段表长度，装入段表寄存器； MMU 解析得到虚拟地址中的段号和段内偏移量； 通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）； 检查段内位移量是否超出该段的长度，若超过，产生越界中断； 从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。 分页机制 目的：将用户程序的地址空间划分为固定大小的页，并将内存空间分成相应大小的物理块。\n工作原理：\n分页管理通过 页表（Page Table） 映射虚拟地址和物理地址。 用户程序的地址空间被划分成若干固定大小的区域，称为“页”。（虚拟页） 内存空间也分成若干个物理块，页和块的大小相等。（物理页） 可将用户程序的任一页放在内存的任一块中，实现了离散分配。 优点：\n内存利用率高：分页将内存划分为大小相等的页框，可以更有效地利用内存空间。 减少外部碎片：由于页的大小固定，不会产生外部碎片。 用户不可见：分页对用户是透明的，用户无需关心页的分配。 缺点：\n设计复杂：实现分页需要复杂的管理机制。 信息共享受限：页的大小由页框决定，一个页中可能包含多个逻辑模块，共享同一块内存不太合理。 分页机制下的虚拟地址组成：\n页号 ：通过虚拟页号可以从页表中取出对应的物理页号； 页内偏移量 ：物理页起始地址+页内偏移量=物理内存地址。 具体的地址翻译过程如下：\n程序执行时，从进程控制块（PCB）中取出页表始址和页表长度，装入页表寄存器； MMU 解析得到虚拟地址中的虚拟页号和页内偏移量； 通过页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）； 检查页号是否超出页表长度，若超过，产生越界中断。 用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。 多级别页表 以 32 位的环境为例，虚拟地址空间范围共有 $2^{32}$（4G）。假设 一个页的大小是 $2^{12}$（4KB），那页表项共有 4G / 4K = $2^{20}$ 个。每个页表项为一个地址，占用 4 字节（32位），也就是说一个程序啥都不干，页表大小就得占用 4M。\n系统运行的应用程序多起来的话，页表的开销还是非常大的。而且，绝大部分应用程序可能只能用到页表中的几项，其他的白白浪费了。\n为了解决这个问题，操作系统引入了 多级页表（Multi-Level Page Table） ，多级页表对应多个页表，每个页表也前一个页表相关联。32 位系统一般为二级页表，64 位系统一般为四级页表。多级页表属于时间换空间的典型场景，利用增加页表查询的次数减少页表占用的空间。\n我们看一下这个四级页表的例子，它的虚拟地址有 4级索引、3级索引、2级索引、1级索引 和 偏移量。\n每个进程会有一个 4级页表。检索的时候，我们先通过4级页表索引得到一个3级页表的位置，然后再根据3级页表索引找到该表中的条目，也就是一个2级页表，然后再根据2级页表索引获得一个1级页表，最后再根据该1级页表来获得最终的物理地址。\n所以根据上图，我们明白4级索引中可能会有很多种 1级页表、2级页表，甚至是 3 级页表。\n事实上，多级页表就像一个多叉树的数据结构，所以我们常常称它为页表树。因为虚拟内存地址分布的连续性，树的第一层节点的指针，很多就是空的，也就是不需要有对应的子树了。所谓不需要子树，其实就是不需要对应的 2 级、3 级的页表。找到最终的物理页号，就好像通过一个特定的访问路径，走到树最底层的叶子节点。\n最后，我们可以知道的是：如果用单级表进行存储，则需要将虚拟空间对物理空间的映射占满，这样不论是多大的进程都会分配到一样大的映射表；而用多级表进行存储，则可以只使用进程占用空间的映射，这样映射表的空间就每那么大，从而达到省下空间的效果。\n段页机制\n结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。\n在段页式机制下，地址翻译的过程分为两个步骤：\n段式地址映射。 页式地址映射。 快表 为了提高虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 **转址旁路缓存(Translation Lookasjde Buffer，TLB，也被称为快表) ** 。\n在主流的 AArch64 和 x86-64 体系结构下，TLB 属于 (Memory Management Unit，内存管理单元) 内部的单元，本质上就是一块高速缓存（Cache），缓存了虚拟页号到物理页号的映射关系，你可以将其简单看作是存储着键（虚拟页号）值（物理页号）对的哈希表。\n使用 TLB 之后的 地址翻译流程 是这样的：\n用虚拟地址中的虚拟页号作为 key 去 TLB 中查询； 如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。 如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。 当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。 页缺失 页缺失（Page Fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等） 指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 MMU 所发出的中断。\n硬性页缺失（Hard Page Fault） ：物理内存中没有对应的物理页。于是，Page Fault Hander 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。 软性页缺失（Soft Page Fault）：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。于是，Page Fault Hander 会指示 MMU 建立相应的虚拟页和物理页的映射关系。 页面置换 当发生硬性页缺失时，如果物理内存中没有空闲的物理页面可用的话。操作系统就必须将物理内存中的一个物理页淘汰出去，这样就可以腾出空间来加载新的页面了。\n用来选择淘汰哪一个物理页的规则叫做 页面置换算法 ，我们可以把页面置换算法看成是淘汰物物理页的规则。\n最佳页面置换算法（OPT，Optimal） ：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。 先进先出页面置换算法（FIFO，First In First Out） : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。 最近最久未使用页面置换算法（LRU ，Least Recently Used） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。 最少使用页面置换算法（LFU，Least Frequently Used） : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。 时钟页面置换算法（Clock） ：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。 文件系统 文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：\n存储管理 ：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。 文件管理 ：文件的创建、删除、移动、重命名、压缩、加密、共享等等。 目录管理 ：目录的创建、删除、移动、重命名等等。 文件访问控制 ：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。 软链接和硬链接 在 Linux/类 Unix 系统上，文件链接（File Link）是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：\n1、硬链接（Hard Link）\n在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。 只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。 硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。 ln 命令用于创建硬链接。 2、软链接（Symbolic Link 或 Symlink）\n软链接和源文件的 inode 节点号不同，而是指向一个文件路径。 源文件删除后，硬链接依然存在，但是指向的是一个无效的文件路径。 软连接类似于 Windows 系统中的快捷方式。 不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。 ln -s 命令用于创建软链接。 磁盘调度算法 先来先服务算法（First-Come First-Served，FCFS） ：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。 最短寻道时间优先算法（Shortest Seek Time First，SSTF） ：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。 扫描算法（SCAN） ：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。 循环扫描算法（Circular Scan，C-SCAN） ：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。 边扫描边观察算法（LOOK） ：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。 均衡循环扫描算法（C-LOOK） ：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。 ","date":"2024-03-26T20:28:49+08:00","image":"https://yikuanzz.github.io/2024/%E6%B5%85%E8%81%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cover_hu7463b4b34524b427fe5ff8175328084d_847514_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E6%B5%85%E8%81%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"浅聊操作系统"},{"content":"计算机内可以存储各种各样的数据，例如：文本数据、图片数据、音频数据、视频数据等等。\n这些数据都会以 位（bit，或比特） 的形式储存在计算机内，并且它们的组织形式通常是一组，我们一般认为 8个位为 1个字节（byte）。\n计算机能处理的位数越多，那么它的速度就会越快。接下来，这篇文章会向读者介绍计算机是如何对其中的数据进行处理的。\n整数 人类的计数方式通常是“逢十进一”，称为 十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字0~9是目前最广泛采用的。\n计算机是用数字电路搭成的，数字电路中只有1和0两种状态，或者可以说计算机只有两个手指，所以对计算机来说 二进制（Binary） 是最自然的计数方式。根据“逢二进一”的原则，十进制的1、2、3、4分别对应二进制的1、10、11、100。\n计算机采用如下的逻辑电路计算两个 bit 的加法：\nBit Full Adder Sign and Magnitude表示法 我们如果用 8个 bit 表示正数和负数，那么一个简单的想法就是把最高位规定为 符号位（Sign Bit），这样一个字节的取值范围就是 -$2^7$-1 ~ $2^7$-1​。\n-1\t-\t10000001 +1\t-\t00000001 1.两个数的低7位相加的结果超出了范围，就会产生 溢出（Overflow），这时通常把计算机中的一个标志位置1表示当前运算产生了溢出。 2.两个符号位不同的数，一个大一个小，用大的数减小的数，符号位是大数的符号位。 3.零的表示有两种，一种是符号为 0 的正零，另一种是符号为 1 的负零。 4.两个数做减法的时候就需要进行转换，把加数先变成负数然后再进行加法运算。 我们可以发现，如果采用Sign and Magnitude表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。\nComplement表示法 一种更好的方法就是用二进制补码系统来表示有符号整数，因为它可以将减法运算转换为对减数的补数运算。\n补码的类型有两种：1位补码（1\u0026rsquo;s complement）和2位补码（2\u0026rsquo;s complement）。\n一位补码： 也称为原码。 正数的一位补码与其本身相同。 负数的一位补码为其绝对值的二进制形式，所有数字位取反，再加一。 二位补码： 也称为反码。 正数的二位补码与其本身相同。 负数的二位补码为在原码的基础上，符号位不变，其余位取反，再加一。 补数运算：\n以十进制为例，如果一个数是一位的，那么它与它的补数和总是 9，这样 2 的补数是 7；如果这个数是两位的，那么补数和就是99，那么 11 的补数是 88。\n以二进制为例，通常是 $n$ 位的运算，那么数 $P$ 的补数为 $Q$ 且 $P + Q = 2^n$。例如，01100101 的补数和是 100000000，求一个数的补数是取反加 1，这样 01100101 的补数就是 10011010 + 1 = 10011011。\n如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。如果溢出了，就要连接到溢出标志位去提示计算产生了溢出。\n​\n无符号二进制乘法 我们回顾一下平时使用的乘法，就是先把乘数的一部分先与被乘数相乘，记录下每个部分的乘积然后再将它们相加得到最终的结果。\n但实际上，计算的做法稍微有些不同，它在每次做运算的时候就先将部分积的值加到乘数中。\n布斯乘法 布斯乘法适用于，两个正数、一个正数和一个负数、两个负数相乘的情况。它与无符号数乘法很相似，我们对算法进行描述：\n对于 $N$ 位乘数 $Y$ ，布斯算法检查其 2 的补码形式的最后一位和一个隐含的低位，命名为 $y[i-1]$ ，初始值为 0 。对于 $y[i], i = 0, 1, \u0026hellip;, N - 1$，考察 $y[i]$ 和 $y[i - 1 ]$。当这两位相同时，存放积的累加器 $P$ 的值保持不变。当 $y[i] = 0$ 且 $y[i - 1] = 1$ 时，被乘数乘以 $2^i$ 加到 $P$ 中。当 $y[i]= 1$ 且 $y[i - 1] = 0$ 时，从 $P$ 中减去被乘数乘以 $2^i$ 的值。算法结束后， $P$ 中的数即为乘法结果。\n同样是 10x13 的这个例子，我们用布斯乘法计算无符号的乘法：\n上述式子结果高位溢出直接丢弃，结果就是：1000 0010。\n如果是对于无符号位的计算，则需要先将负数用原码进行表示，然后再进行计算：\n上述式子结果高位溢出直接丢弃，结果就是：00 1000 0010。\n除法 除法就是通过被除数不断减去除数直到结果为零或小于除数来实现的。\n减去除数的次数为 商（quotient）,最后一次减法的差为 余数（remainder）。\n与乘法的部分积类似，除法的话主要是对部分被除数做减法。\n我们先看看无符号除法的例子，575 ÷ 25：\n我们需要用文字描述这一个过程的实现，主要用以下这两种表述：\n1.恢复余数除法\n部分被除数初始化为被除数，除数对齐是通过位移实现的，书上的例子很清晰，这里就直接贴图，不做另外的解释了。\n2.不恢复余数除法\n浮点数 浮点数运算就是实数之间的运算，它不像整数运算，浮点数的计算结果一般是不确定的。\n浮点数表示也被称作 “科学计数法”，在十进制运算中，科学计数法表示的数字被写成：尾数 x $10^{指数 }$ 的形式，例如：$1.2345 \\times 10^{20}$，指数以 10 的整数倍将其扩大或缩小。\n二进制浮点数则表示为：尾数 x $2^{指数 }$，例如：$1.01010111 \\times 2^5$。\nIEEE 754 浮点数标准提供了 3 种浮点数表示：32 位单精度浮点数，64 位双精度浮点数，以及 128位四精度浮点数。\nIEEE（电气和电子工程师协会）\n电气和电子工程师协会 (IEEE, 读做 “eye- triple-ee”) 是一个包括所有电子和计技术的专业团体。它出版刊物，举办会议，并且建立委员会来定义标准，内容涉及从电力传输到软件工程。另一个 IEEE 标准的例子是无线网络的 802. 11 标准。\nIEEE 浮点表示 IEEE 浮点标准采用 $V = (-1)^s \\times F \\times 2^{E - 偏置常数}$ 的形式来表示一个数：\n符号（sign）$s$ 决定这个数是负数还是正数。 尾数（significand）$F$ 是一个二进制小数。 阶码（exponent）$E$ 的作用是对浮点数加权，$E_{min}-1$ 表示浮点 0，$E_{max}+1$ 表示正或负无穷大或 非数（Not a Number, NaN）。 为什么对指数进行偏置？（以单精度浮点数为例）\n因为单精度浮点数的指数部分使用 8 位来存储（范围:0~255），为了能够表示正负的指数所以我们减去一个偏移量得到：-126~+127。\n十进制转换为二进制浮点数\n将十进制数 $4100.125_{10} $ 转换为符合 IEEE 754 标准的 32位单精度二进制浮点数。\n首先将 $4100.125$ 转换为二进制定点数，整数部分 $4100_{10} = 10000000000100_2$，小数部分 $0.125_{10}=0.001_2$，所以 $4100.125_{10} = 10000000000100.001_2$。\n接下来对该二进制数进行规格化，就是将小数点左移变成 1.xxx 的形式，每左移动一次指数就加一：$1.0000000000100001 \\times 2^{12}$。\nS = 0 E = 12 + 127 = 10001011 F = 00000000010000100000000 浮点运算 浮点数不能直接相加，我们要先对齐浮点数的小数点，然后使它们的指数大小相同，然后才对尾数进行运算，最后再对结果进行规格化。\n下面给出书上的流程图，但要注意几点：\n因为指数有时和尾数位于同一个字中，所以在加法过程开始之前要将它们分开。 如果两个指数的差大于 $p+1$ ，这里 $p$ 为尾数的位数，那么较小的数就无法影响大的数。 结果规格化的时候会检查指数，看它是是否比最小指数小或比最大指数大，分别检测指数下溢或上溢，下溢会导致结果为 0，上溢会造成结果错误。 ","date":"2024-03-25T10:55:32+08:00","image":"https://yikuanzz.github.io/2024/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/cover_hu2a12c6b4de696aee97ce970a68d98a3e_1194101_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/","title":"计组-计算机算术"},{"content":"程序的基本概念 程序和编程语言 程序（Program） 是由一系列指令（Instruction）组成，它告诉计算机应如何完成一个计算任务。\n这些指令通常会有：输入（从输入设备中获取数据）、输出（在输出设备中输出数据）、基本运算（例如数学上的四则运算）、流程控制（条件分支或者循环其他指令）。\n编写程序就是将指令进行组合，来完成复杂任务。\n编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。\n机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，它们用语句（Statement）来编写程序，语句是计算机指令的抽象表示。\n编译器（Compiler）将C语言的语句编译（Compile）成汇编或机器指令，计算机才能执行。\n虽然说编译需要花费一些时间，但是这样会使编程变得更加容易。\nC语言是 可移植的（Portable） 的，为什么这么说呢。\n因为不同的计算机体系是有不同的指令集（Instruction Set）的，那么能识别到机器指令格式也不同。如果不同机器上都有C语言的编译器，那么我们就可以将C语言编译成不同机器都能识别的机器指令。\n那么，程序执行的流程就是：源码通过编译生成可执行文件，然后在操作系统上加载运行这个可执行程序。\n当然，如果是脚本语言，比如：Shell、Python等等，则省去编译的这个过程。\n程序的调试 程序的编写通常没有那么容易，程序中错误叫做 BUG，修正 BUG 的过程叫做 调试（Debug） ，程序中的 BUG 通常有这么几类：\n编译时错误，例如一些语法错误。 运行时错误，可以编译成可执行文件，但是在执行时程序会崩溃。 逻辑错误和语义错误，编译和执行都很顺利，但是没有按期望去执行。 第一个程序 我们将 C语言程序写在 main.c 的文件里。\n# include \u0026lt;stdio.h\u0026gt; int main(){ pritf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } 我们通过 gcc 对 C语言进行编译，它会将我们的 main.c 源代码编译生成可执行文件 a.out ，当然我们也可以指定其生成的文件名。\ngcc -Wall main.c -o main ./main\t# Hello, World! 一个好的习惯是打开 gcc 的 -Wall 选项，也就是让 gcc 提示所有的警告信息，不管是严重的还是不严重的，然后把这些问题从代码中全部消灭。\n常量、变量和表达式 简单的规则 # include \u0026lt;stdio.h\u0026gt; // 单行注释 /* 多行注释 */ int main(void){ printf(\u0026#34;注释不会影响编译！\u0026#34;); return 0; } 除了注释，我们用到了由双引号（Double Quote）引起来的一串字符，它称为 字符串字面值（String Literal） 或者字符串。\n打印的时候，我们并不会打印双引号，因为它是字符串字面值的界定符号。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ printf(\u0026#34;Hello, world.\\n\u0026#34;); printf(\u0026#34;Goodbye, \u0026#34;); printf(\u0026#34;cruel world!\\n\u0026#34;); return 0; } 上面的代码中，我们用到了 转义序列（Escape Sequence） ，它们代表着一些特殊的意义。\n\\n：换行符号。 \\t：制表符号。 \\b：回退符号。 常量 常量（Constant） 是程序中最基本的元素，有字符（Character）常量、整数（Integer）常量、浮点数（Floating Point）常量和枚举常量。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ printf(\u0026#34;character: %c\\ninteger: %d\\nfloating point: %f\\n\u0026#34;, \u0026#39;}\u0026#39;, 34, 3.14); return 0; } 这里需要注意的是，计算机中整数和小数点内部表达方式不同，这是因为它们的基本存储方法不同。\n其中，%c、%f、%d 是字符类型的转换说明，这种用法通常叫做占位符（Placeholder），只是在打印输出的时候改变显示的内容，但不是对实际的内容进行修改。\n变量 变量（Variable） 是编程语言最重要的概念之一，变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value）。\nC语言规定必须以字母或下划线_（Underscore）开头，后面可以跟若干个字母、数字、下划线，但不能有其它字符。\n# include \u0026lt;stdio.h\u0026gt; int main(){ // 变量声明 char cc;\t// 字符型变量 int bb;\t// 整型变量 float ss;\t// 单精度浮点数 double tom;\t// 双精度浮点数 return 0; } C语言中的声明（Declaration）有变量声明、函数声明和类型声明三种。如果一个变量或函数的声明要求编译器为它分配存储空间，那么也可以称为定义（Definition），因此定义是声明的一种。\n赋值 声明或定义了变量之后，我们要把值存到它们所表示的存储空间里，可以用赋值（Assignment）语句。\n变量的定义和赋值也可以一步完成，这称为变量的 初始化（Initialization）。\n# include \u0026lt;stdio.h\u0026gt; int main(){ // 变量赋值 char firstletter; int hour, minute; firstletter = \u0026#39;a\u0026#39;; /* give firstletter the value \u0026#39;a\u0026#39; */ hour = 11; /* assign the value 11 to hour */ minute = 59; /* set minute to 59 */ return 0; } 注意变量一定要先声明后使用，它们代表着各自的存储空间，编译器必须先看到变量声明，才知道怎么对变量进行读写。\n表达式 常量和变量都可以参与加减乘除运算，比如 +、-、*、/ 就代表着四则运算的符号，就叫运算符（Operator），参与运算的变量叫操作数（Operand）比如 a + b ，a 和 b 就是操作数，而 a + b 这一整个式子，就是表达式（Expression）\n# include \u0026lt;stdio.h\u0026gt; int main(){ int total_minute; total_minute = hour * 60 + minute; } 字符类型和字符编码 # include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;%c\\n\u0026#34;, \u0026#39;a\u0026#39;+1); } 在计算机内，每个符号都有对应的整数来进行表示，我们称为 字符编码（Character Encoding） ，最常用的字符编码规则就是 ASCII码（American Standard Code for Information Interchange，美国信息交换标准码）。\n简单函数 数学函数 在数学中我们用过sin和ln这样的函数，例如sin(π/2)=1，ln1=0等等，在C语言中也可以使用这些函数。\n# include \u0026lt;math.h\u0026gt; # include \u0026lt;stdio.h\u0026gt; int main(void){ double pi = 3.1416; printf(\u0026#34;sin(pi/2)=%f\\nln1=%f\\n\u0026#34;, sin(pi/2), log(1.0)); return 0; } 我们编译运行这个程序。\ngcc main.c ./a.out\t# sin(pi/2)=1.000000 ln1=0.000000 上面的代码中，log 我们叫它 函数（Function） log(1.0) 我们叫函数调用（Function Call），这些函数就放在 math.h 的这个文件内，所以要使用这些函数就要导入这个文件。\n其实，我们已经接触过函数了，就是我们的 main 函数，它前面的 int 是指函数运行完毕后返回的值类型是一个整数，return 语句负责函数的返回。\n自定义函数 #include \u0026lt;stdio.h\u0026gt; void newline(void) { printf(\u0026#34;\\n\u0026#34;); } void threeline(void) { newline(); newline(); newline(); } int main(void) { printf(\u0026#34;Three lines:\\n\u0026#34;); threeline(); printf(\u0026#34;Another three lines.\\n\u0026#34;); threeline(); return 0; } 上述代码说明了几个事情，就是函数的调用只需要写它的函数名和圆括号就行了，除非它有要求参数，不然就不用进行参数传递。\n此外，如果函数没返回值，那么在定义的时候写上 void，这样函数就不用写 return 语句了。\n最后，同一个函数是可以被多次调用的，但是要在调用前进行定义。\n形参和实参 #include \u0026lt;stdio.h\u0026gt; void print_time(int hour, int minute) { printf(\u0026#34;%d:%d\\n\u0026#34;, hour, minute); } int main(void) { print_time(23, 59); return 0; } 形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化，如果我们对形参进行修改，结果并不会影响到实际参数。\n其实就是相当于将实际参数复制了一份给函数内部进行使用，使用完后，形式参数就会被回收。\n全局变量、局部变量 我们把函数中定义的变量称为 局部变量（Local Variable） 。它的含义是，函数中定义的变量不能被其他函数使用，每次调用函数的时候会创建新的局部变量，它们的存储空间是不同的。\n全局变量（Global Variable），全局变量定义在所有的函数体之外，它们在程序开始运行时分配存储空间，在程序结束时释放存储空间，在任何函数中都可以访问全局变量。\n分支语句 if 语句 # include \u0026lt;stdio.h\u0026gt; int main(){ int x = 12; if (x != 0) { printf(\u0026#34;x is nonzero.\\n\u0026#34;); } } 其中，!= 表示不等于的意思，x != 0这个表达式称为 控制表达式（Controlling Expression），如果条件成立，那么 {} 里面的语句就会执行，否则就不执行。\n!= 是关系运算符，此外还有 == 表示相等的关系运算符，自然还有其他的关系运算符，这里就按下不表了。\nif/else 语句 # include \u0026lt;stdio.h\u0026gt; int main(){ int x = 7; // if - else if (x % 2 == 0) printf(\u0026#34;x is even.\\n\u0026#34;); else printf(\u0026#34;x is odd.\\n\u0026#34;); // if - else if - else if (x \u0026gt; 0) printf(\u0026#34;x is positive.\\n\u0026#34;); else if (x \u0026lt; 0) printf(\u0026#34;x is negative.\\n\u0026#34;); else printf(\u0026#34;x is zero.\\n\u0026#34;); } 通常 if 语句与 else 语句搭配使用，要解释一下的是 % ，它是取模（Modulo）运算符，计算余数用的。\n布尔代数 # include \u0026lt;stdio.h\u0026gt; int main(){ int a = 1, b = 2, c =3; if (a \u0026lt; b \u0026amp;\u0026amp; b \u0026lt; c) { printf(\u0026#34;b is between a and c.\\n\u0026#34;); } return 0; } 其中 \u0026amp;\u0026amp; 是逻辑运算符号，叫做逻辑与（Logical AND），仅仅当左右两边的条件成立时才为真。此外，还有逻辑或（Logical OR）||，仅有一个条件成立就为真。逻辑非（Logical NOT）! ，直接取反条件。\nswtich 语句 # include \u0026lt;stdio.h\u0026gt; void print_day(int day){ switch (day){ case 1: case 2: case 3: case 4: case 5: printf(\u0026#34;Work Day！\u0026#34;); break; case 6: case 7: printf(\u0026#34;Weekend!\u0026#34;); break; default: printf(\u0026#34;Illegal Day Number!\u0026#34;); break; } } int main(){ printf_day(2); return 0; } 深入理解函数 return 语句 # include \u0026lt;stdio.h\u0026gt; int absolute_value(int x) { if (x \u0026lt; 0) { return -x; } else if (x \u0026gt; 0) { return x; } } int main(){ printf(absolute_value(-10)); return 0; } 函数返回一个值相当于定义一个和返回值类型相同的临时变量并用 return 后面的表达式来初始化。\n增量式开发 增量式（Incremental） 开发的思路就是将大的问题分成小的问题，然后再让小问题分成更小的问题，这个过程在代码中的体现就是函数的分层设计（Stratify）。\n编写一个程序求圆的面积，圆的半径以两个端点的座标(x1, y1)和(x2, y2)给出。\n1、根据两点坐标求出圆的半径。 2、根据半径求出圆的面积。 # include \u0026lt;stdio.h\u0026gt; double distance(double x1, double y1, double x2, double y2){ return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); } double area(double r){ return r*r*3.1416; } int main(){ printf(are(distance(1.0, 2.0, 4.0, 6.0))); return 0; } 递归 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ if (n == 0){ return 1; } return factorial(n-1)*n } int Fibonacci(int n){ if (n == 0 || n == 1){ return n } return Fibonacci(n-1) + Fibonacci(n-2) } int main(){ // 阶乘 printf(\u0026#34;10的阶乘是：%d\u0026#34;, factorial(10)); // 斐波那契 printf(\u0026#34;第10项的斐波那契数是：%d\u0026#34;, Fibonacci(10)); } 循环语句 while 语句 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ int result = 1; while (n \u0026gt; 0) { result = result * n; n = n - 1; } return result; } int main(){ printf(factorial(10)); return 0; } do while 语句 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ int result = 1; int i = 1; do { result = result * i; i = i + 1; } while (i \u0026lt;= n); return result; } int main(){ printf(factorial(10)); return 0; } for 语句 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ int result = 1; int i; for(i = 1; i \u0026lt;= n; ++i) result = result * i; return result; } int main(){ printf(factorial(10)); return 0; } break 和 continue #include \u0026lt;stdio.h\u0026gt; int is_prime(int n){ int i; for (i = 2; i \u0026lt; n; i++) if (n % i == 0) break; if (i == n) return 1; else return 0; } int main(void){ int i; for (i = 1; i \u0026lt;= 100; i++) { if (!is_prime(i)) continue; printf(\u0026#34;%d\\n\u0026#34;, i); } return 0; } 结构体 复合类型与结构体 根据语法规则由基本类型组合而成的类型称为 复合类型（Compound Type），例如字符串是由很多字符组成的。\n现在，我们用 C语言来表示一个复数：从直角坐标系来看，复数由实部和虚部组成；从极座标系来看，复数由模和辐角组成，两种座标系可以相互转换。\n# include \u0026lt;stdio.h\u0026gt; struct complex_struct{ double x, y; }z1, z2; int main(){ // 结构体字段赋值 z1.x = 3.0; z1.y = 4.0; // 结构体的初始化 struct complex_struct z3 = {0}; } 数据抽象 用 C 语言实现一个完整的复数运算程序。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;math.h\u0026gt; struct complex_struct{ double x, y; }; double real_part(struct complex_struct z){ return z.x; } double img_part(struct complex_struct z){ return z.y; } double magnitude(struct complex_struct z){ return sqrt(z.x*z.x + z.y*z.y); } double angle(struct complex_struct z){ return atan2(z.y, z.x) } struct complex_struct make_from_real_img(double x, double y){ struct complex_struct z; z.x = x; z.y = y; return z; } struct complex_struct make_from_mag_ang(double r, double A){ struct complex_struct z; z.x = r * cos(A); z.y = r * sin(A); return z; } struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2) { return make_from_real_img(real_part(z1) + real_part(z2), img_part(z1) + img_part(z2)); } struct complex_struct sub_complex(struct complex_struct z1, struct complex_struct z2){ return make_from_real_img(real_part(z1) - real_part(z2), img_part(z1) - img_part(z2)); } struct complex_struct mul_complex(struct complex_struct z1, struct complex_struct z2){ return make_from_mag_ang(magnitude(z1) * magnitude(z2), angle(z1) + angle(z2)); } struct complex_struct div_complex(struct complex_struct z1, struct complex_struct z2){ return make_from_mag_ang(magnitude(z1) / magnitude(z2), angle(z1) - angle(z2)); } int main(){ return 0; } 数据类型标志 通过枚举类型，定义复数的类型。\n# include \u0026lt;stdio.h\u0026gt; enum coordinate_type { RECTANGULAR, POLAR }; struct complex_struct { enum coordinate_type t; double a, b; }; int main(){ return 0; } 数组 数组的基本概念 数组（Array） 也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。它的特点就是这些元素是相邻存储的，并且其中的每个元素可以通过下标索引进行访问。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ int count[4] = { 3, 2, }, i; for (i = 0; i \u0026lt; 4; i++) printf(\u0026#34;count[%d]=%d\\n\u0026#34;, i, count[i]); return 0; } 我们做一个案例：要求成一列0~9的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;stdlib.h\u0026gt; # define N 10000 int a[N]; void gen_random (int upper_bound){ int i ; for (i = 0; i \u0026lt; N; i++) a[i] = rand() % upper_bound; } void print_random(){ int i; for (i = 0; i \u0026lt; N; i++) printf(\u0026#34;%d \u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); } int howmany(int value){ int count = 0, i; for (i = 0; i \u0026lt; N; i++) if (a[i] == value) ++count; return count; } int main(){ int i; gen_random(10); printf(\u0026#34;value\\thow many\\n\u0026#34;); for (i = 0; i \u0026lt; 10; i++) printf(\u0026#34;%d\\t%d\\n\u0026#34;, i, howmany(i)); return 0; } 然后我们使用 -E 可以看到预处理（Preprocess）阶段之后、编译之前的程序。\ngcc -E main.c 这里预处理器做了两件事情，一是把头文件 stdio.h 和 stdlib.h 在代码中展开，二是把 #define 定义的标识符 N 替换成它的定义20。\n字符串 字符串可以看作一个数组，它的每个元素是字符型的。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ // 通过下标获取字符串的字符 char c = \u0026#34;Hello, world.\\n\u0026#34;[0]; // 字符数组存储字符串 char str1[10] = { \u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39; }; char str2[10] = \u0026#34;Hello, world.\\n\u0026#34;; char str3[] = \u0026#34;Hello, world.\\n\u0026#34;; print(\u0026#34;字符是：%c\u0026#34;, c); print(\u0026#34;字符串是：%s\u0026#34;, str3); return 0; } 数组后面元素没有指定，就会自动初始化为 0，就是 Null 字符。当然，以 \\0 为结尾的也叫字符串，所以只要是 Null 字符结尾，那么就是字符串。\n多维数组 多维数组（Multi-dimensional Array） 就是在数组里面嵌套数组。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ // a -\u0026gt; a[0]、a[1]、a[2] int a[3][2] = { 1, 2, 3, 4, 5}; int b[][2] = { { 1, 2 }, { 3, 4 }, { 5, } }; return 0; } 简单的小游戏 - 剪刀石头布\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;stdlib.h\u0026gt; # include \u0026lt;time.h\u0026gt; int main(void){ char gesture[3][10] = {\u0026#34;剪刀\u0026#34;, \u0026#34;石头\u0026#34;, \u0026#34;布\u0026#34;}; int man, computer, result, ret; srand(time(NULL)); printf(\u0026#34;现在开始剪刀石头布游戏！\\n\u0026#34;); while (1){ computer = rand() % 3; printf(\u0026#34;请选择(剪刀-0，石头-1，布-2)：\u0026#34;); ret = scanf(\u0026#34;%d\u0026#34;, \u0026amp;man); if (ret != 1 || man \u0026lt; 0 || man \u0026gt; 2) { printf(\u0026#34;无效输入! 请输入 0, 1 或 2.\\n\u0026#34;); sleep(3); system(\u0026#34;clear\u0026#34;); continue; } printf(\u0026#34;你出了: %s\\t电脑出了: %s\\n\u0026#34;, gesture[man], gesture[computer]); result = (man - computer + 4) % 3 - 1; if (result \u0026gt; 0) printf(\u0026#34;你赢了!\\n\u0026#34;); else if (result == 0) printf(\u0026#34;平局!\\n\u0026#34;); else printf(\u0026#34;你输了!\\n\u0026#34;); sleep(3); system(\u0026#34;clear\u0026#34;); } } GDB调试 调试工具 gdb，可以完全操控程序的运行。\n调试的基本思想就是“分析现象-\u0026gt;假设错误原因-\u0026gt;产生新的现象去验证假设”这样一个循环。\n单步执行和跟踪函数调用 #include \u0026lt;stdio.h\u0026gt; int add_range(int low, int high){ int i, sum; for (i = low; i \u0026lt;= high; i++) sum = sum + i; return sum; } int main(void){ int result[100]; result[0] = add_range(1, 10); result[1] = add_range(1, 100); printf(\u0026#34;result[0]=%d\\nresult[1]=%d\\n\u0026#34;, result[0], result[1]); return 0; } 在编译时要加上 -g 选项，生成的可执行文件才能用 gdb 进行源码级调试：\ngcc -g main.c -o main 通过 gdb 命令进入调试：\ngdb main 这里要说明的是，gdb 并不是将源码嵌入到可执行文件中的，它也是从外部获取源码来进行调试分析的。\n我们通过 start 命令开始调试，gdb 会停在变量定义后的第一条语句等待我们的命令，可以使用 next 进行下一步语句：\n(gdb) start Temporary breakpoint 1 at 0x400568: file zz2.c, line 14. Starting program: /root/testdir/zz2 Temporary breakpoint 1, main () at zz2.c:14 14 result[0] = add_range(1, 10); (gdb) next 15 result[1] = add_range(1, 100); 此外，我们还可以通过 step 命令就进入到函数的执行中：\n(gdb) start The program being debugged has been started already. Start it from the beginning? (y or n) y Temporary breakpoint 2 at 0x400568: file zz2.c, line 14. Starting program: /root/testdir/zz2 Temporary breakpoint 2, main () at zz2.c:14 14 result[0] = add_range(1, 10); (gdb) step add_range (low=1, high=10) at zz2.c:5 5 int i, sum = 0; 使用 backtrace 命令可以查看函数调用的栈帧：\n(gdb) backtrace #0 add_range (low=1, high=10) at zz2.c:5 #1 0x0000000000400577 in main () at zz2.c:14 可见当前的 add_range 函数是被 main 函数调用的，main 传进来的参数是 low=1, high=10。main 函数的栈帧编号为1，add_range 的栈帧编号为 0 。现在可以用 info 命令查看 add_range 函数局部变量的值：\n(gdb) info locals i = 32767 sum = -138851417 如果初始化有错误，我们也可以直接修改初始化变量：\n(gdb) set sum = 0 (gdb) info locals i = 32767 sum = 0 如果想查看 main 函数当前局部变量的值也可以做到，先用 frame 命令选择 1 号栈帧然后再查看局部变量：\n(gdb) frame 1 #1 0x0000000000400570 in main () at zz2.c:14 14 result[0] = add_range(1, 10); (gdb) info locals result = {0, 0, 4, 0, 0, 0, -8264, 32767, -8304, 32767, 0, 0, -8208, 32767, -134223256, 32767, -134224160, 32767, -136425313, 32767, 0, 0, -8208, 32767, 0, 0, 0, 0, 0, 832, -134224160, 32767, 960, 1472, 2496, 2496, 2496, 2496, 2496, 2496, 0, 0, -134223256, 32767, -8448, 32767, -8464, 32767, 1700966438, 0, -138851417, 32767, 11538501, 0, -140227432, 32767, -8368, 32767, -138865760, 32767, 256, 64, 118, 0, -8368, 32767, 194, 0, -8272, 32767, -8256, 32767, 9, 0, -139772531, 32767, 118, 0, 0, 0, 0, 0, 15775231, 0, 1, 0, 4195837, 0, -8272, 32767, 0, 0, 4195760, 0, 4195392, 0, -8048, 32767, 0, 0} 通过 print 命令还可以直接打印变量的值：\n(gdb) print sum $1 = 0 最后，可以使用 finish 函数让程序运行到从当前函数返回为止：\n(gdb) finish Run till exit from #0 add_range (low=1, high=10) at zz2.c:7 0x0000000000400577 in main () at zz2.c:14 14 result[0] = add_range(1, 10); Value returned is $2 = 55 断点 #include \u0026lt;stdio.h\u0026gt; int main(void){ int sum = 0, i = 0; char input[5]; while (1) { scanf(\u0026#34;%s\u0026#34;, input); for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) sum = sum*10 + input[i] - \u0026#39;0\u0026#39;; printf(\u0026#34;input=%d\\n\u0026#34;, sum); } return 0; } 程序的作用是：首先从键盘读入一串数字存到字符数组 input 中，然后转换成整型存到 sum 中，然后打印出来，一直这样循环下去。\n例如输入是 \u0026quot;2345\u0026quot; ，则循环累加的过程是 (((0*10+2)*10+3)*10+4)*10+5=2345。\n我们可以用 display 命令使得每次停下来的时候都显示当前sum的值，然后继续往下走：\n(gdb) display sum 1: sum = 0 (gdb) next 10 scanf(\u0026#34;%s\u0026#34;, input); 1: sum = 0 undisplay 命令可以取消跟踪显示，变量 sum 的编号是1，可以用 undisplay 1 命令取消它的跟踪显示：\n(gdb) n 10 scanf(\u0026#34;%s\u0026#34;, input); 1: sum = 123345 (gdb) undisplay 1 通过 break 命令在第 10 行打个断点，然后用 continue 连续运行到达断点：\n(gdb) list 10 5 int sum = 0, i = 0; 6 char input[5]; 7 8 while (1) 9 { 10 scanf(\u0026#34;%s\u0026#34;, input); 11 for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) 12 sum = sum * 10 + input[i] - \u0026#39;0\u0026#39;; 13 printf(\u0026#34;input=%d\\n\u0026#34;, sum); 14 } (gdb) break 10 Breakpoint 2 at 0x4005b3: file zz3.c, line 10. (gdb) continue Continuing. 123 input=123345123 Breakpoint 2, main () at zz3.c:10 10 scanf(\u0026#34;%s\u0026#34;, input); 我们可以用 info 命令查看断点情况：\n(gdb) info breakpoint Num Type Disp Enb Address What 2 breakpoint keep y 0x00000000004005b3 in main at zz3.c:10 breakpoint already hit 2 times 我们可以用 disable 命令禁用断点，用 enable 重新启用断点，用 delete 删除断点：\n(gdb) disable breakpoints 2 (gdb) info breakpoints Num Type Disp Enb Address What 2 breakpoint keep n 0x00000000004005b3 in main at zz3.c:10 breakpoint already hit 2 times (gdb) enable 2 (gdb) info breakpoints Num Type Disp Enb Address What 2 breakpoint keep y 0x00000000004005b3 in main at zz3.c:10 breakpoint already hit 2 times (gdb) delete breakpoints Delete all breakpoints? (y or n) t Please answer y or n. Delete all breakpoints? (y or n) y (gdb) info breakpoints No breakpoints or watchpoints. gdb 的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当sum不等于0时才中断，然后用 run 命令重新从程序开头连续运行：\n(gdb) break 10 if sum != 0 Breakpoint 3 at 0x4005b3: file zz3.c, line 10. (gdb) i breakpoints Num Type Disp Enb Address What 3 breakpoint keep y 0x00000000004005b3 in main at zz3.c:10 stop only if sum != 0 (gdb) run The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /root/testdir/zz3 123 input=123 Breakpoint 3, main () at zz3.c:10 10 scanf(\u0026#34;%s\u0026#34;, input); 2: sum = 123 想要退出 gbd 调试的话，只需要输入 quit 就可以了：\n(gdb) quit A debugging session is active. Inferior 1 [process 14749] will be killed. Quit anyway? (y or n) y 观察点 #include \u0026lt;stdio.h\u0026gt; int main(void) { int sum = 0, i = 0; char input[5]; while (1) { sum = 0; scanf(\u0026#34;%s\u0026#34;, input); for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) sum = sum*10 + input[i] - \u0026#39;0\u0026#39;; printf(\u0026#34;input=%d\\n\u0026#34;, sum); } return 0; } 如果我们想查看某个数的输出可以用 x 来输出：\n(gdb) n 11 scanf(\u0026#34;%s\u0026#34;, input); (gdb) n 12345 12 for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) (gdb) x/8b input 0x7fffffffdfa0: 0x31 0x32 0x33 0x34 0x35 0x00 0x00 0x00 如果我们想观察某个值的变化，可以用 watch 来设置观察点：\n(gdb) watch input[0] Hardware watchpoint 4: input[0] (gdb) c Continuing. input=12345 234 Hardware watchpoint 4: input[0] Old value = 49 \u0026#39;1\u0026#39; New value = 50 \u0026#39;2\u0026#39; 0x00007ffff7a68382 in __GI__IO_vfscanf () from /lib64/libc.so.6 段错误 如果程序运行时出现段错误，用 gdb 可以很容易定位到究竟是哪一行引发的段错误：\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int man = 0; scanf(\u0026#34;%d\u0026#34;, man); return 0; } 然后我们用 gdb 调试这段程序：\n(gdb) run Starting program: /root/testdir/zz5 123 Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7a69341 in __GI__IO_vfscanf () from /lib64/libc.so.6 (gdb) backtrace #0 0x00007ffff7a69341 in __GI__IO_vfscanf () from /lib64/libc.so.6 #1 0x00007ffff7a790b9 in __isoc99_scanf () from /lib64/libc.so.6 #2 0x0000000000400580 in main () at zz5.c:6 gdb 显示段错误出现在 _IO_vfscanf 函数中，用 bt 命令可以看到这个函数是被我们的 scanf 函数调用的，所以是 scanf 这一行代码引发的段错误。仔细观察程序发现是 man 前面少了个 \u0026amp;。\n","date":"2024-03-24T14:37:07+08:00","image":"https://yikuanzz.github.io/2024/linux-c%E4%B8%80%E5%85%A5%E9%97%A8/cover_huc77e13b628f6c253544f486e9b91b9b1_1927448_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/linux-c%E4%B8%80%E5%85%A5%E9%97%A8/","title":"Linux C（一）入门"},{"content":"开发技术革新 CGI 通用网关接口 通用网关接口（Common Gateway Interface, CGI） 是一种Web服务器与外部应用程序之间进行数据交互的标准协议。\n背景： 早期的Web服务器只能响应浏览器发来的HTTP静态资源请求，并将存储在服务器中的静态资源返回给浏览器。 随着Web技术的发展，动态技术逐渐出现，但Web服务器不能直接运行动态脚本。 为了解决Web服务器与外部应用程序（即CGI程序）之间的数据互通问题，CGI（通用网关接口）应运而生。 工作原理： CGI允许Web服务器获取客户端提交的信息，并将其传递给服务端的CGI程序进行处理，然后将结果返回给客户端。 CGI通信系统由两部分组成: HTML页面：显示在用户浏览器上的页面。 运行在服务器上的CGI程序：处理客户端提交的数据。 一次网页请求与响应的过程如下： 浏览器通过URL请求一个网页，服务器返回该网页文件。 通常我们看到的网页是动态生成的，比如PHP/JSP网页，根据请求参数不同返回不同内容。 类似地，请求一个CGI程序时，CGI程序解析前端传递的参数，理解意图并返回数据，如HTML、XML或JSON等。 前端知识： 前端页面发送数据的方式包括： 表单提交（HTML原生）。 JavaScript操作表单提交。 JavaScript通过Ajax请求数据。 \u0026lt;!-- 用户访问时就会访问，cgi-bin 下对应对的脚本 --\u0026gt; \u0026lt;form action=\u0026#34;/cgi-bin/hello.cgi\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;用户名：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input name=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;密码：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input name=\u0026#34;password\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;OK\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; MVC （Model-View-Controller） MVC（Model-View-Controller） 是一种常见的软件架构模式，广泛应用于Web应用程序和桌面应用程序的开发。在这种模式下，应用程序被分为三个不同的部分：\n模型（Model）： 负责处理应用程序的业务逻辑和数据。 模型不包含与数据显示相关的代码，只关注数据的处理和业务规则的执行。 视图（View）： 负责显示数据给用户，以及与用户的交互功能，例如表单、网页等。 视图是应用程序的外观，通常由HTML、JSP等实现。 控制器（Controller）： 类似于一个分发器，用来决定对于视图发来的请求，需要用哪一个模型来处理，以及处理完后需要跳回到哪一个视图。 控制器连接视图和模型，协调它们之间的交互。 MVC模式的流程如下：\n浏览器通过视图向控制器发出请求。 控制器接收请求，选择合适的模型进行处理。 处理完请求后，控制器再转发到视图，进行视图界面的渲染并做出最终响应。 在MVC模式中，视图可以用JSP、HTML、CSS实现，模型可以用JavaBean实现，而控制器通常使用Servlet来实现。这种分层架构使得应用程序更易于维护、扩展和重用。\n另外，还有一个与MVC类似的架构模式叫做三层架构，它将应用程序分为表示层、业务逻辑层和数据访问层。这三层各自负责不同的功能，也有助于代码的分层和复用。\n后台服务化与前端一致化 后台服务化和前端一致化架构是现代软件开发中的两个关键概念。\n后台服务化： 在传统的软件架构中，前端和后端是分离的。前端专注于页面渲染，而后台则处理业务逻辑。前后端之间最常见的交互方式是通过接口实现的。 后台服务化的架构将后端业务逻辑进一步拆分成独立的服务。每个服务负责特定的功能，例如用户管理、订单处理、支付等。 这种架构有助于提高系统的可维护性、扩展性和性能。它允许不同的团队并行开发不同的服务，而无需相互干扰。 前端一致化架构： 前端一致化架构旨在解决前端开发中的一些痛点。 传统的前端开发模式中，前端工程师负责将设计图切成 HTML 页面，而后端工程师负责将 HTML 转换为 JSP 页面并处理逻辑和数据展示。 这种模式导致了人员分工不明、效率低下以及不利于项目迭代等问题。 前端一致化架构通过前后端分离，让前端专注于页面展示，后端只提供接口数据。这样可以降低耦合度，提高开发效率，同时满足多端应用开发的需求。 开发模式革新 瀑布开发 瀑布模型（也称为Waterfall Model）是一种软件生命周期模型，其开发过程按照一系列阶段的顺序展开，从系统需求分析开始，直到产品发布和维护。这个模型的名称来源于项目开发进程从一个阶段“流动”到下一个阶段，就像瀑布流水逐级下落。\n瀑布模型的核心思想是将问题分解为工序，将功能的实现与设计分开，以便于分工协作。它将软件生命周期划分为以下六个基本活动，并规定了它们自上而下、相互衔接的固定次序：\n制定计划：确定项目的范围、时间和资源。 需求分析：收集、分析和定义系统需求。 软件设计：设计系统的架构、模块和接口。 程序编写：根据设计规范编写代码。 软件测试：验证系统是否满足需求并修复错误。 运行维护：发布产品并进行后续维护。 瀑布模型的优点和缺点如下：\n优点： 强制开发人员采用规范的方法（如结构化技术）。 严格规定每个阶段必须提交的文档。 要求所有产品都必须经过质量保证小组的仔细验证。 缺点： 瀑布模型依赖于书面的规格说明，用户只能通过文档来了解产品。 可能导致最终开发出的软件产品不能真正满足用户的需求。 不适合需求模糊的系统。 此外，还有一种加入迭代过程的瀑布模型，用于解决传统瀑布模型过于理想化的问题。在这种模型中，当后续阶段发现前面阶段的错误时，需要返回前面的阶段进行修改，以确保产品质量。\n总之，瀑布模型在软件开发中曾经广泛采用，但现在更多的团队倾向于使用敏捷方法，以更灵活和迭代的方式开发软件。\n敏捷开发 敏捷开发是一种高效的软件开发方法，起源于美国。许多大型公司为了提高产品的开发效率，已经开始运用敏捷开发。让我用通俗易懂的语言解释一下：\n迭代开发： 敏捷开发的核心是迭代开发。 迭代开发通过短期增量（通常称为冲刺）的方式来完成工作，从而缩短开发周期。 每个冲刺通常为一到四周。 在敏捷开发中，软件项目被切分成多个子项目，每个子项目都经过测试，具备可视、可集成和可运行的特征。 换言之，就是把一个大项目分成多个相互联系、但也可独立运行的小项目，并分别完成。在此过程中，软件一直处于可使用状态。 优势和不足： 优势： 敏捷开发将一艘大船变成许多条小船，每条小船各司其职，分配小目标，所有的小目标合起来就能完成大目标。 效率高，每个人职责分明。 不足： 小团队难以拥有开阔的视野，看不到全局。 对于不可分割的大需求，敏捷开发不再合适。 敏捷开发适用于成熟的应用做高效的版本迭代，对于初创型或快速增长的公司不适合。 混合式开发： 对于大需求，可以采用传统的瀑布式开发。 对于小优化和小迭代，可以采用敏捷开发。 现在很多大型公司结合了两者的优势。 产品经理在敏捷开发团队中的不同： 敏捷开发中，产品经理有更多时间思考产品细节，不用花太多时间在沟通和传递需求上。 敏捷开发让产品经理更专注于大方向的事务。 总之，敏捷开发是一种高效、迭代式的开发方法，适用于成熟的应用做版本迭代。\n​\n精益开发 精益开发是一种用于开发产品和服务的方法论，旨在缩短产品开发周期，并快速发现产品创意构思是否可行。它通过采用商业假设驱动的实验、迭代产品发布和验证学习的组合来实现。\n让我们深入了解一下精益开发的核心思想和原则：\n杜绝浪费： 将所有的时间花在能够增加客户价值的事情上。 除去不必要的环节，专注于创造价值的活动。 推迟决策： 保持可选方案的开放性，但时间不能过长。 尽可能多地提出可行方案，但不要拖延决策。 加强学习： 使用科学的学习方法。 培养有战斗力的团队，持续学习和改进。 快速交付： 当客户索取价值时应立即交付价值。 缩短迭代周期，提供稳定可运行且有价值的软件。 打造精品： 使用恰当的方法确保质量。 追求完美，不断改进产品。 授权团队： 让创造增值的员工充分发挥自己的潜力。 培养健康的团队，不被琐碎的细节束缚。 优化整体： 防止以损害整体为代价而优化部分的倾向。 考虑局部优化对整体利益的影响。 总之，精益开发是一种追求尽善尽美、注重价值创造和持续改进的方法，适用于不同行业和产品开发领域。\n","date":"2024-03-23T20:46:07+08:00","image":"https://yikuanzz.github.io/2024/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%92%8C%E6%A8%A1%E5%BC%8F/cover_hu7d4fceec4d5a30dfc826354c0be764cc_547485_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%92%8C%E6%A8%A1%E5%BC%8F/","title":"开发技术和模式"},{"content":"我们做随机实验(ramdom trial)，记为 $E$ ，把实验的所有结果的集合叫作样本空间(sample sapce)，记为 $\\Omega$ 。\n随机事件(random event) 是样本空间的子集，简单称为事件。\n频率 $P$ 那么，我们假设在同一条件下进行了 $n$ 次实验，再假设随机事件 $A$ 在实验中发生了 $k$ 次，那么就事件的频率为 :\n$$ f_n(A)=\\frac{k}{n} $$\n当 $n$ 很大的时候，频率 $\\frac{k}{n}$ 趋于某一数值 $p$ ，则称 $p$ 为事件 $A$ 发生的概率，记为：\n$$ P(A) = p $$\n公理化的定义是说，$P(A)$ 满足以下公理：\n非负性：$P(A)\\geq0$ 规范性：$P(\\Omega) = 1$ 可数可加性： $P(\\cup ^ {\\infty} _ {n=1} A_n ) = \\sum ^ {\\infty} _ {n=1} P(A_n) $ 条件概率 $P(A|B) = \\frac{P(AB)}{P(B)}$ 我们说，在事件 $B$ 发生的前提下，事件 $A$ 发生的条件概率为: $$ P(A|B) = \\frac{P(AB)}{P(B)} $$ 条件概率 $P(A|B)$ 满足以下公理：\n对任一事件 $A$ ，有 $P(A|B) \\geq 0$ $P(\\Omega|B) = 1$ $P( \\cup ^ {\\infty} _ {i=1} A_i|B) = \\sum^{ \\infty } _ {i=1} P(A_i|B)$ 另外，乘法公式是说，当 $P(B) \u0026gt; 0$ 时，则有： $$ P(AB) = P(B)P(A|B) $$\n全概率公式 $P(B)=\\sum^{n}_{i=1}P(A_i)P(B|A_i)$ 我们定义 $A_1, A_2, \u0026hellip;, A_n$ 为样本空间 $\\Omega$ 的一个划分，它满足：\n划分中的任两个事件之间不相容 划分中的所有事件的总和构成样本空间 那么，这里我们认定事件 $B$ 为样本空间 $\\Omega$ 中的任意事件，因为 $P(B\\Omega) = P(B) * P(\\Omega) = P(B) * 1 = P(B) $，所以这里给出公式推理：\n$$ \\begin{aligned} P(B) \u0026amp;= P(B\\Omega)= P(B(A_1 \\cup A_2 \\cup \\cdots \\cup A_n))\\\\ \u0026amp;= P(BA_1 \\cup BA_2 \\cup \\cdots \\cup BA_n) \\\\ \u0026amp;= P(BA_1) + P(BA_2) + \\cdots + P(BA_n) \\\\ \u0026amp;= P(A_1)P(B|A_1) + P(A_2)P(B|A_2) + \\cdots + P(A_n)P(B|A_n) \\end{aligned} $$\n贝叶斯公式 $P(A_i|B) = \\frac{P(B|A_i)P(A_i)}{\\sum^{n}_{j=1}P(B|A_i)P(A_j)}$ 贝叶斯公式由条件概率和全概率公式组合而来，推理如下： $$ \\begin{aligned} P(A_i|B) \u0026amp;= \\frac{P(A_iB)}{P(B)} = \\frac{P(BA_i)}{P(B)}\\ \u0026amp;= \\frac{P(B|A_i)P(A_i)}{P(B)} \\ \u0026amp;= \\frac{P(B|A_i)P(A_i)}{\\sum^{n}_{j=1}P(B|A_j)P(A_j)} \\end{aligned} $$ 一般来说，我们将划分 $A_1,A_2,\u0026hellip;,A_n$ 作为已知的结果，是说我们通过实验或者以往的信息经验之类的得到了 $P(A_j)$ 的值，所以我们称 $P(A_j)$ 为先验概率。此外，我们称 $P(A_i|B)$ 为后验概率，因为 $P(A_i|B)$ 是说在事件 $B$ 发生后，$A_i$ 再发生的概率。\n通俗来说，就是我们通过了那么多的事件 $A_1,A_2,\u0026hellip;,A_n$ 得到了结果，也就是事件 $B$ 的概率，但是我们还想要知道这个结果，也就是事件 $B$ 发生的情况下，某个 $A_j$ 发生的概率是多少这样。\n分布函数 $F(x)=P\\{X \\leq x \\}$ 我们这里给出一个函数为： $$ X = X(A) $$ 这里，我们把样本空间 $\\Omega$ 中的每一个结果，或者说每一个事件都放入函数里，得到一个实数，比如 $X_1 = X(A_1),X_2=X(A_2),\\dots,X_n=X(A_n)$ 。\n这样做的好处是，我们将一些实验的结果用数字进行替代，比如，我们要在一个装有红、绿、蓝小球的箱子里摸球，我们可以用数字来替代红、绿、蓝的结果，$X(红)=1,X(绿)=2，X(蓝)=3$。\n因为我们的函数 $X$ 的值会随着实验的不同结果而变化，所以我们称 $X$ 函数为随机变量(random variable)。\n当然，我们一般用区间对 $X$ 的值进行描述，因为有时候不能将每一个值都列出来，所以我们会说随机变量 $X$ 的取值落在区间 $(x_1,x_2]$ 的概率，就是要求 $P \\{ x_1\\leq X \\leq x_2 \\}$ 的值。\n求 $P\\{x_1\\leq X \\leq x_2\\}$ 的值就相当于要计算 $P\\{X \\leq x_2\\} - P\\{ X \\leq x_1\\}$ 的值，那么就很容易知道我们其实是要研究 $P\\{X \\leq x \\}$ 的概率问题了。因为它的值也是随着不同的 $x$ 而变化的，所以我们叫 $P\\{X \\leq x \\}$ 为$P\\{X \\leq x \\}$ ，这里给出它的公式： $$ F(x) = P \\{X \\leq x \\} $$ 分布函数有以下特点：\n$F(x_2) - F(x_1) = P \\{x_1 \u0026lt; X \\leq x_2 \\} \u0026gt; 0$ $0 \\leq F(x) \\leq1 $ 我们在这里对随机变量有个区分：\n离散型随机变量：随机变量的取值为有限个或者可数无穷多个 连续型随机变量：随机变量的取值连续地充满某个区间 离散型随机变量-两点分布 $X \\sim (0-1)$ 当随机变量 $X$ 的取值只有 $x_1$ 和 $x_2$ 这两个结果时，它的分布为：\n$$ \\begin{aligned} P\\{ X=x_1 \\} \u0026= p \\quad , \\\\ P\\{ X=x_2 \\} \u0026= 1 - p \\quad, \\quad0 \u003c p \u003c 1 \\\\ \\end{aligned} $$ 我们称 $X$ 服从参数为 $p$ 的两点分布，也叫 (0-1) 分布，记作 $X \\sim (0-1)$。\n离散型随机变量-二项分布 $X\\sim b(n, p)$ 当随机变量 $X$ 的分布满足： $$ P\\{X=k\\} = C_n^k p ^k(1-p)^{n-k} $$ 则称 $X$ 为服从参数为 $n $ , $p$ 的二项分布(binomial distribution)，记作 $X\\sim b(n, p)$。\n一般我们会使用 泊松(Posisson)定理 来进行近似计算，这里做个简单介绍。\n设 $np_n = \\lambda$ ，对任意非负整数有： $$ \\lim\\limits_{x\\rightarrow\\infty}C^k_np^k_n(1-p)^{n-k}=\\frac{\\lambda^ke^{-\\lambda}}{k!} $$\n离散型随机变量-泊松分布 $X \\sim P(\\lambda)$ 当随机变量 $X$ 的分布满足： $$ P\\{X=k\\} = \\frac{\\lambda^ke^{-\\lambda}}{k!} \\quad,\\quad k=0,1,2,\\dots, $$ 则称 $X$ 为服从参数为 $\\lambda$ 的泊松分布(poisson distribution)，记作 $X \\sim P(\\lambda)$，其中 $\\lambda$ 为常数。\n概率密度函数 $f(x)$ 这里介绍一个概念，概率密度函数(density sunction)。它可以用来描述随机变量 $X$ 的分布函数 $F(x)$： $$ F(x) = \\int^x_{\\infty}f(t)dx $$ 它有以下特点：\n$f(x) \\geq 0$ $\\int^{{+\\infty}}_{-\\infty}f(x)dx = 1$ $P \\{ x_1 \u0026lt; X \u0026lt;x_2 \\} = F(x_2) - F(x_1) = \\int^{x_2}_{x_1}f(t)dx$ 连续型随机变量-均匀分布 $X\\sim U(a,b)$ 当随机变量 $X$ 具有概率密度：\n$$ f(x)=\\left\\{ \\begin{aligned} \u0026 \\frac{1}{b-a},\u0026 a \u003c x\u003c b, \\\\\\ \u00260,\u0026 其他. \\end{aligned} \\right. $$ 则称 $X$ 在区间 $(a, b)$ 上服从均匀分布(unniform distribution)，记作 $X\\sim U(a,b)$\n积分求得 $X$ 的分布函数：\n$$ F(x)=\\left\\{ \\begin{aligned} \u0026 0,\u0026 x \u003c a, \\\\\\ \u0026 \\frac{x-a}{b-a},\u0026a \\leq x \u003c b, \\\\\\ \u0026 1,\u0026 x \\geq b. \\end{aligned} \\right. $$ 连续型随机变量-指数分布 $X\\sim E(\\lambda)$ 当随机变量 $X$ 具有概率密度：\n$$ f(x)=\\left\\{ \\begin{aligned} \u0026 \\lambda e^{-\\lambda x}, \u0026x \u003e 0, \\\\\\ \u00260,\u0026 x \\leq 0. \\end{aligned} \\right. $$ 则称 $X$ 服从 $\\lambda$ 的指数分布(exponential distribution)，记作 $X\\sim E(\\lambda)$，其中 $\\lambda$ 为常数。\n积分求得 $X$ 的分布函数：\n$$ F(x)=\\left\\{ \\begin{aligned} \u0026 1-e^{-\\lambda x},\u0026 x \u003e 0, \\\\ \u0026 0,\u0026x \\leq 0. \\end{aligned} \\right. $$ 连续型随机变量-正态分布 $X \\sim N(\\mu, \\sigma^2)$ 当随机变量 $X$ 具有概率密度： $$ f(x)= \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{- \\frac{(x-\\mu)^2}{2 \\sigma^2}},-\\infty\u0026lt;x\u0026lt;+\\infty $$ 则称 $X$ 服从参数为 $\\mu$ , $\\sigma$ 的正态分布(normal distribution)，记作 $X \\sim N(\\mu, \\sigma^2)$， 其中 $\\mu$ 和 $\\sigma (\\sigma\u0026gt;0)$ 为常数。\n积分求得 $X$ 的分布函数： $$ F(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\int^x_{-\\infty}e^{-\\frac{(t-\\mu)^2}{2 \\sigma^2}}dt $$ 特别的，当 $\\mu=0,\\sigma=1$时，我们称 $X$ 服从标准正态分布 $N(0,1)$，这时它的概率密度表示为：\n$$ \\varphi(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{x^2}{2}} $$\n分布函数表示为：\n$$ \\phi(x)=\\frac{1}{\\sqrt{2\\pi}} \\int ^x _{-\\infty} e^{\\frac{t^2}{2}}dt $$\n一般地，若 $X \\sim N(\\mu, \\sigma^2)$ ，那么 $\\frac{X-\\mu}{\\sigma}\\sim N(0, 1)$，我们可以通过正态函数表来计算正态分布：\n$$ \\begin{aligned} P \\{\\mu- \\sigma \u003c X \u003c \\mu + \\sigma \\} = \\phi(1) - \\phi(-1) = 2\\phi(1) -1 = 0.6826 \\\\ P \\{\\mu-2 \\sigma \u003c X \u003c \\mu + 2 \\sigma \\} = \\phi(2) - \\phi(-2) = 2\\phi(2) -1 = 0.9544 \\\\ P \\{\\mu-3 \\sigma \u003c X \u003c \\mu + 3 \\sigma \\} = \\phi(3) - \\phi(-3) = 2\\phi(3) -1 = 0.9974 \\end{aligned} $$ 联合分布函数 $F(x,y) = P{ X \\leq x, Y \\leq y}$ 在这里，我们考虑两个随机变量 $X(e)$ 和 $Y(e)$ 的组合。我们把 $(X(e), Y(e))$ 称为二维随机向量(2-dimensional random vector)，简单记作 $(X, Y)$。\n显然，我们可以得到二维随机向量 $(X, Y)$ 的分布函数，或者说，随机变量 $X$ 和随机变量 $Y$ 的联合分布函数： $$ F(x,y) = P\\{ X \\leq x, Y \\leq y\\} $$\n边缘分布函数 $F_X(x), F_Y(y)$ 我们说到联合分布函数是二维随机变量 $(X, Y)$ 的分布函数，自然随机变量 $X$ 和 $Y$ 是有分布函数的，那么我们通过联合分布函数来求得变量 $X$ 和 $Y$ 的分布函数，就可以得二维随机变量 $(X, Y)$ 关于 $X$ 和 $Y$ 的边缘分布函数(marginal distribution function)：\n$$ \\begin{aligned} F_X(x) \u0026amp;= P\\{X \\leq x \\} = P\\{X \\leq x, Y \u0026lt; +\\infty \\} = F(x, +\\infty) \\\\ F_Y(y) \u0026amp;= P\\{Y \\leq y \\} = P\\{X \u0026lt; +\\infty, Y \\leq y \\} = F(+\\infty, y) \\end{aligned} $$\n数学期望 $E(X)$ 我们现在知道一个离散型变量 $X$ 的分布律为：\n$$ P\\{X = x_k\\} = p_k, k=1,2.\\dots $$\n如果满足条件 $\\sum ^ {\\infty} _ {k=1} x_kp_k$ 绝对收敛，那么有数学期望(mathematical expectation)，记作 $E(X)$，即： $$ E(X) =\\sum^{\\infty}_{k=1}x_kp_k $$\n当然，如果是一个连续型的随机变量 $X$ 的话，我们就假设它有概率密度函数 $f(x)$ 。\n如果满足积分 $\\int^{+\\infty}_{-\\infty}xf(x)dx$ 绝对收敛，那么同样有数学期望为：\n$$ E(X) = \\int^{+\\infty}_{-\\infty}xf(x)dx $$\n数学期望有一些性质：\n$E(c) = c$ ，其中 $c$ 为常数； $E(cX) = cE(X)$； $E(X+Y) = E(X) + E(Y)$； $E(XY) = E(X)E(Y)$，其中 $X,Y$ 相互独立。 $(0-1)$分布 二项分布 泊松分布 均匀分布 指数分布 正态分布 $ E(X) $ $ p $ $ np $ $ \\lambda $ $ \\frac{a+b}{2} $ $ \\frac{1}{\\lambda} $ $ \\mu $ 方差 $D(X)$ 数学期望描述了随机变量取值的“平均数”，而 方差(variance) 是用来度量随机变量取值的分散程度的，记作 $D(X)$，即： $$ D(X) = E[X-E(X)]^2 = E(X^2) - [E(X)]^2 $$\n其中，我们称 $\\sqrt{D(X)}$ 为随机变量 $X$ 的标准差(standard deviation)，或均方差(mean square deviation)，记作 $ \\sigma(X)$。\n方差有一些性质：\n$D(c) = 0$，其中 $c$ 为常数； $D(cX) = c^2D(X)$； $D(X±Y) = D(X) + D(Y) ±2E[(X-E(X))(Y-E(Y))]$； $D(X±Y) = D(X) + D(Y)$，其中 $X,Y$ 相互独立。 $(0-1)$分布 二项分布 泊松分布 均匀分布 指数分布 正态分布 $ D(X) $ $ p(1-p) $ $ np(1-p) $ $ \\lambda $ $ \\frac{(a+b)^2}{12} $ $ \\frac{1}{\\lambda^2} $ $ \\sigma^2 $ 协方差 $cov(X, Y)$ 数学期望和方差反映的都是随机变量自身的内容，这里我们考虑随机变量相互之间的影响，一般会使用协方差(convariance) 来描述，即：\n$$ cov(X, Y) = E{[X-E(X)][Y-E(Y)]} $$ 其中，我们称 $\\frac{cov(X, Y)}{\\sqrt{D(X)}{\\sqrt{D(Y)}}}$ 为随机变量 $X,Y$ 的相关系数(correlation corfficient)，或标准协方差(standard convariance)，记作 $\\rho_{XY} $，即：\n$$ \\rho_{XY} =\\frac{cov(X, Y)}{\\sqrt{D(X)}{\\sqrt{D(Y)}}} $$\n一些实用的计算公式：\n$$ D(X±Y) = D(X) + D(Y) ± 2cov(X, Y) \\\\ cov(X, Y) = E(XY) - E(X)E(Y) $$\n","date":"2024-03-22T20:39:03+08:00","image":"https://yikuanzz.github.io/2024/%E6%A6%82%E7%8E%87%E8%AE%BA/cover_hu8470374154b02d0cb208d1f67de517c1_1238996_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E6%A6%82%E7%8E%87%E8%AE%BA/","title":"概率论"},{"content":"基础篇 MySQL概述 数据库相关概念 数据库（Data Base）：存储数据的仓库，并且是有组织的存储。\n数据库管理系统（Data Base Management System）：操纵和管理数据库的大型软件。\nSQL（Structured Query Language）：操作关系型数据库的编程语言。\nMySQL 数据库 # 连接 MySQL mysql -u username -p 数据模型：客户端 \u0026raquo; 数据库管理系统 \u0026raquo; 数据库。\n关系型数据库（RDBMS）：由多张互相连接的二维表组成的数据库。\nSQL SQL 通用语法 -- 注释写法1 : 不区分大小写，关键字建议大写 # 注释写法2 : 可以使用缩进或空格 /*\t注释写法3 */ SQL 分类 DDL（Data Definition Language）：定义数据库、表、字段。\nDML（Data Manipulation Language）：表中数据增、删、改。\nDQL（Data Query Language）：查询数据库表记录。\nDCL（Data Control Language）：创建数据库用户、控制数据库访问权限。\n数据类型 数值类型：\nTINYINT（1 byte）、SMALLINT（2 bytes）、MEDIUMINT（3 bytes）、INT（4 bytes）、BIGINT（8 bytes）、FLOAT（4 bytes）、DOUBLE（8 bytes）。\n字符串类型：\nCHAR、VARCHAR、TINYBLOB、TINYTEXT、BLOB、TEXT、MEDIUMBLOB、MEDIUMTEXT、LONGBLOB、LONGTEXT。\n日期类型：\nDATE（YYYY-MM-DD）、TIME（HH:MM:SS）、YEAR（YYYY）、DATETIME（YYYY-MM-DD HH:MM:SS）、TIMESTAMP（YYYY-MM-DD HH:MM:SS）\nDDL /* 数据库的操作 */ # 查询所有数据库 SHOW DATABASES; # 查询当前数据库 SELECT DATABASE(); # 创建数据库 CREATE DATABSE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; # 使用数据库 USE 数据库名; # 删除 DROP DATABASE [IF NOT EXISTS] 数据库名; /* 表操作 */ # 查询所有数据表 SHOW TABLES; # 查询表结构 DESC 表名; # 查询表的建表语句 SHOW CREATE TABLE 表名; # 创建表 CREATE TABLE 表名( 字段1 字段1类型[COMMENT 字段1注释], 字段2 字段2类型[COMMENT 字段2注释], 字段3 字段3类型[COMMENT 字段3注释], )[COMMENT 表注释]; # 添加字段 ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束]; # 修改数据类型 ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); # 修改字段名和字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; # 删除字段 ALTER TABLE 表名 DROP 字段名; # 修改表名 ALTER TABLE 表名 RENAME TO 新表名; # 删除表 DROP TABLE [IF EXISTS] 表名; # 删除指定表并重新创建该表 TRUNCATE TABLE 表名; DML # 给指定字段添加数据 INSERT INTO 表名(字段名1, 字段名2, ...) VALUES(值1, 值2, ...); # 给全部字段添加数据 INSERT INTO 表名字 VALUES(值1, 值2, ...); # 修改数据 UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件]; # 删除数据 DELETE FROM 表名 [WHERE 条件]; DQL SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 # 查询多个字段 SELECT 字段1, 字段2, 字段3 ... FROM 表名; SELECT * FROM 表名; # 设置别名 SELECT 字段1[AS 别名1], 字段2[AS 别名2] .. FROM 表名; # 去除重复记录 SELECT DISTINCT 字段列表 FROM 表名; # 查询没有身份证号的员工信息 SELECT * FROM emp WHERE idcard IS NULL; # 查询 15岁 到 20岁 之间的员工信息 SELECT * FROM emp WHERE age \u0026gt;= 15 and age \u0026lt;= 20; SELECT * FROM emp WHERE age BETWEEN 20 and 15; # 查询年龄为 18岁 或 20岁 或 40岁 的员工信息 SELECT * FROM emp WHERE age = 18 OR age = 20 OR age = 40; SELECT * FROM emp WHERE age IN(18, 20, 40); # 查询姓名为两个字的员工信息 SELECT * FROM emp WHERE name LIKE \u0026#39;__\u0026#39;; # 查询身份证最后一位是X的员工信息 SELECT * FROM emp WHERE idcard LIKE \u0026#39;%X\u0026#39;; # 统计企业员工数据量 SELECT COUNT(*) FROM emp; # 根据性别分组，统计男性员工和女性员工的数量 SELECT gender, count(*) FROM emp GROUP BY gender; # 查询年龄小于 45岁 的员工，并根据工作地址分组，获取员工数量大于3的工作地址 SELECT workaddress, count(*) FROM emp WHERE age\u0026lt;45 GROUP BY workaddress HAVING count(*)\u0026gt;3; # 根据年龄对公司的员工进行升序排序 SELECT * FROM emp ORDER BY age ASC; # 根据入职时间对员工进行降序排序 SELECT * FROM emp ORDER BY entrydate DESC; # 先按年龄升序排，年龄同的按入职时间降序排 SELECT * FROM emp ORDER BY age ASC, entrydate DESC; # 查询第 1 页员工数据，每页展示 10 条记录 SELECT * FROM emp LIMIT 0, 10; # 查询第 2 页员工数据，每页展示 10 条记录 SELECT * FROM emp LIMIT 10,10; DCL # 查询用户 USE mysql; SELECT * FROM USER; # 创建用户 CREATE USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; # 修改用户密码 ALTER USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;新密码\u0026#39;; # 删除用户 DROP USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 查询权限 SHOW GRANTS FOR \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 授予权限 GRANT 权限列表 ON 数据库名.表名 TO \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 撤销权限 REVOKE 权限列表 ON 数据库名.表名 FROM \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; 函数 字符串函数 -- concat SELECT CONCAT(\u0026#39;Hello \u0026#39;, \u0026#39;MySQL\u0026#39;); -- LOWER SELECT LOWER(\u0026#39;Hello\u0026#39;); -- UPPER SELECT UPPER(\u0026#39;Hello\u0026#39;); -- LPAD SELECT LPAD(\u0026#39;01\u0026#39;, 5, \u0026#39;-\u0026#39;); -- RPAD SELECT RPAD(\u0026#39;01\u0026#39;, 5, \u0026#39;-\u0026#39;); -- TRIM SELECT TRIM(\u0026#39; Hello MySQL \u0026#39;); -- SUBSTRIMG SELECT SUBSTRING(\u0026#39;Hello MySQL\u0026#39;, 1, 5); 数值函数 -- CEIL(x) SELECT CEIL(1.1); -- FLOOR(x) SELECT FLOOR(1.9); -- MOD(x,y) SELECT MOD(3, 4); -- RAND() SELECT RAND(); -- ROUND(x,y) SELECT ROUND(3.1415926, 2); 日期函数 -- CURDATE() SELECT CURDATE(); -- CURTIME() SELECT CURTIME(); -- NOW() SELECT NOW(); -- YEAR, MONTH, DAY SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); -- DATE_ADD(date, INTERVAL expr type) SELECT DATE_ADD(NOW(), INTERVAL 70 DAY); -- DATEDIFF(date1, date2) SELECT DATEDIFF(\u0026#39;2024-02-29\u0026#39;, \u0026#39;2023-11-11\u0026#39;); 流程函数 -- IF SELECT IF(FALSE, \u0026#39;OK\u0026#39;, \u0026#39;ERROR\u0026#39;); -- IFNULL SELECT IFNULL(\u0026#39;Get\u0026#39;, \u0026#39;DEFAULT\u0026#39;); SELECT IFNULL(\u0026#39;\u0026#39;, \u0026#39;DEFATLT\u0026#39;); SELECT IFNULL(null, \u0026#39;DEFATLT\u0026#39;); -- CASE WHEN[val1] THEN[res1] ... ELSE[default] END SELECT name, CASE WHEN score \u0026gt;= 85 THEN \u0026#39;优秀\u0026#39; WHEN score \u0026gt;= 60 THEN \u0026#39;及格\u0026#39; ELSE \u0026#39;不及格\u0026#39; END FROM student_score; -- CASE [expr] WHEN[val1] THEN[res1] ... ELSE[default] END SELECT name, CASE workaddress WHEN \u0026#39;北京\u0026#39; THEN \u0026#39;一线城市\u0026#39; WHEN \u0026#39;上海\u0026#39; THEN \u0026#39;一线城市\u0026#39;ELSE \u0026#39;二线城市\u0026#39; END FROM emp; 约束 约束包括：\n1、主键约束：每个表会有一个唯一标识表的字段。 2、外键约束：表中的某字段由另外一个表的主键决定。 3、唯一约束：确保该字段的每个字段值是唯一的，允许空值。 4、检查约束：用于检查数据表中，字段值是否有效。 5、非空约束：用来约束数据表中，字段值不能为空。 6、默认值约束：当表中某字段不输入值时，自动为其添加设定好的值。 常见约束 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) NOT NULL UNIQUE COMMENT \u0026#39;姓名\u0026#39;, age INT CHECK(age \u0026gt; 0 AND age \u0026lt;= 120) COMMENT \u0026#39;年龄\u0026#39;, status CHAR(1) DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;状态\u0026#39;, gender CHAR(1) COMMENT \u0026#39;性别\u0026#39; ) COMMENT \u0026#39;用户表\u0026#39;; 外键约束 CREATE TABLE emp( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) NOT NULL UNIQUE COMMENT \u0026#39;姓名\u0026#39;, age INT CHECK(age \u0026gt; 0 AND age \u0026lt;= 120) COMMENT \u0026#39;年龄\u0026#39;, salary INT CHECK(salary \u0026gt; 0) NOT NULL COMMENT \u0026#39;薪资\u0026#39;, entrydate NOT NULL COMMENT \u0026#39;入职时间\u0026#39;, managerid INT COMMENT \u0026#39;直属领导ID\u0026#39;, dept_id INT \u0026#39;部门ID\u0026#39; ) COMMENT \u0026#39;员工表\u0026#39;; CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;ID\u0026#39;, name VARCHAR(50) NOT NULL COMMENT \u0026#39;部门名称\u0026#39; ) COMMENT \u0026#39;部门表\u0026#39;; # 添加外键 ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE CASCADE; ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE SET NULL; # 删除外键 ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept_id; 多表查询 多表关系 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) COMMENT \u0026#39;姓名\u0026#39;, sid VARCHAR(10) COMMENT \u0026#39;学号\u0026#39; ) COMMENT \u0026#39;学生表\u0026#39;; CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) COMMENT \u0026#39;课程名称\u0026#39; )COMMENT \u0026#39;课程表\u0026#39;; CREATE TABLE student_course( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, studentid INT COMMENT \u0026#39;学生ID\u0026#39;, courseid INT COMMENT \u0026#39;课程ID\u0026#39;, CONSTRAINT fk_courseid FOREIGN KEY (courseid) REFERENCES course(id), CONSTRAINT fk_studentid FOREIGN KEY (studentid) REFERENCES student(id) )COMMENT \u0026#39;学生选课表\u0026#39;; 多表查询概述 # 多表查询 - 笛卡尔积 SELECT * FROM emp, dept WHERE emp.detp_id = dept.id; 内连接 # 内连接查询的是两张交集的部分 SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件; 外连接 # 左外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 ...; # 右外连接 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...; 自连接 # 自连接可以是内连接也可以是外连接 SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; SELECT 字段列表 FROM 表A 别名A LEFT[OR RIGHT] [OUTER] JOIN 表B 别名B ON 条件 ...; 联合查询 # UNION ALL 是不合并相同信息 SELECT * FROM emp WHERE salary \u0026lt; 5000 UNION ALL SELECT * FROM emp WHERE age \u0026gt; 50; 子查询 # 嵌套查询就是子查询 SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); # 查询销售部所有员工信息 SELECT * FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = \u0026#39;销售部\u0026#39;); # 查询销售部和市场部所有员工信息 SELECT * FROM emp WHERE dept_id IN((SELECT id FROM dept WHERE name IN(\u0026#39;销售部\u0026#39;, \u0026#39;市场部\u0026#39;))); # SOME、ANY、ALL 使用 # 比财务部所有人工资都高 SELECT * FROM emp WHERE salary \u0026gt; ALL(SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = \u0026#39;财务部\u0026#39;)); 事务 事务：就是一组操作，不可分割单工作单位，将作为一个整体提交到系统。\n默认 MySQL 的事务是自动提交的，也就是，当执行一条 DML 语句， MySQL 会隐式地提交事务。\n事务操作 # 查看、设置事务提交方式 SELECT @@autocommint; SET @@autocommint = 0; # 开启事务 START TRANSACTION; BEGIN; # 提交事务 COMMIT; # 回滚事务 ROLLBACK; CREATE TABLE account( ID INT AUTO_INCREMENT PRIMARY KEY COMMENT \u0026#39;主键\u0026#39;, NAME VARCHAR(10) COMMENT \u0026#39;姓名\u0026#39;, MONEY INT COMMENT \u0026#39;余额\u0026#39; ) COMMENT \u0026#39;账户表\u0026#39;; INSERT INTO account(ID, NAME, MONEY) VALUES (null, \u0026#39;张三\u0026#39;, 2000), (null, \u0026#39;李四\u0026#39;, 2000); # 恢复数据 UPDATE account SET MONEY = 2000 WHERE NAME IN(\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); # 张三给李四转账 1000 # 1.查询张三账户余额 SELECT MONEY FROM account WHERE name = \u0026#39;张三\u0026#39;; # 2.将张三用户余额 -1000 UPDATE account SET MONEY = MONEY - 1000 WHERE name = \u0026#39;张三\u0026#39;; # 3.将李四用户余额 +1000 UPDATE account SET MONEY = MONEY + 1000 WHERE name = \u0026#39;李四\u0026#39;; 事务特性 原子性（Atomicity）：事务不可分割。\n一致性（Consistency）：事务完成时，所有数据状态一致。\n隔离性（Isolation）：保证事务在不受并发操作下独立运行。\n持久性（Durabiliry）：事务一旦提交或回滚，数据改变是永久的。\n并发事务 脏读：一个事务读到另一个事务还没有提交的数据。\n不可重复读：一个事务先后读取同一条记录，但是两次读取的数据不同。\n幻读：查询时没有对应数据行，但插入数据时数据又存在。\n事务隔离级别 隔离级别 脏读 不可重复读 幻读 Read uncommitted ✓ ✓ ✓ Read committed × ✓ ✓ Repeatable Read (Default) × × ✓ Serializable × × × # 查看事务隔离级别 SELECT @@TRANSACTION_ISOLATION; # 设置事务隔离级别 SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}; 进阶篇 Linux MySQL 使用 MySQL 服务 # 启动 systemctl start mysqld # 重启 systemctl restart msyqld # 停止 systemctl stop mysqld 查询自动生成的 root 密码 grep \u0026#39;temporary password\u0026#39; /var/log/mysqld.log 修改 root 密码 # 设置密码复杂度和密码长度 SET GLOBAL VALIDATE_PASSWORD.policy = 0; SET GLOBAL VALIDATE_PASSWORD.length = 4; # 修改密码 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;1234\u0026#39;; 创建用户 CREATE USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;1234\u0026#39;; 分配所有权限 grant all on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; 存储引擎 MySQL 体系结构 MySQL 客户端 \u0026laquo; === \u0026raquo; MySQL Server （连接层 + 服务层 + 引擎层 + 存储层）\nMySQL Server = 连接池 + 系统管理工具 + SQL 接口 + 解析器 + 查询优化器 + 缓存 + 可插拔存储引擎 + 系统文件 + 文件和日志\n存储引擎简介 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储殷勤是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。\n# 创建表时指定存储引擎 CREATE TABLE 表名( )ENGINE = INNODB； # 查询数据库支持的存储引擎 SHOW ENGINES； 存储引擎特点 InnoDB：高可靠性和高性能的通用存储引擎。\nxxx.ibd：xxx 代表表名，innoDB 引擎每张表都会对应一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。\nTablespace -\u0026gt; Segment -\u0026gt; EXtent -\u0026gt; Page -\u0026gt; Row (Trx id + Roll Pointer + col1 + col2 + col3 + \u0026hellip;)\nDML 操作遵循 ACID 模型，支持事务； 行级锁，提高并发访问性能； 支持外键 FOREIGN KEY 约束，保证数据的完整性和正确性。 MyISAM：MySQL 早期默认存储引擎。\nxxx.sdi：存储表结构信息。\nxxx.MYD：存储数据。\nxxx.MYI：存储索引。\n不支持事务，不支持外键； 支持表锁，不支持行锁； 访问速度快。 Memoery：表数据存储在内存中，只做临时表或缓存。\nxxx.sdi：存储表结构信息。\n内存存放； hash 索引（默认）。 存储引擎选择 InnoDB：对事务完整性要求高，并发条件下数据的一致性，除了插入和查询外，还包含很多更新、删除，则选该引擎。\nMyISAM：以读取和插入为主，很少更新和删除操作，对事务完整性、并发性要求不是很高，就用该引擎。\nMEMORY：访问速度快，但大小有限制，因为是临时存储也无法保证数据的安全性。\n索引 索引概述 索引（Index） ： 是帮助 MySQL 高效获取数据的数据结构。数据之外，数据库管理系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n优点：提高检索的效率，降低数据库的 IO 成本；通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗； 缺点：索引列也是要占用空间的；索引提高了查询效率，同时也降低了更新表的速度。 索引结构 MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的结构：\nB+Tree：最常见的索引类型，大部分引擎支持。\nHash：底层数据用哈希表实现，只有精确匹配索引列查询才有效。\nR-tree：空间索引为MyISAM引擎的特殊索引类型，主要用于地理空间数据类型。\nFull-text：一种通过建立倒排索引，快速匹配文档的方式。\n二叉树：顺序插入到时候，会形成一个链表，查询性能会大大降低，大数据量情况下，层级较深，检索速度慢。\n红黑树：大量数据情况下，层级深，检索速度慢。\nB-Tree：（最大度数为 5 的 b-tree 每个节点存 4 个 key）。\nB+-Tree：所有的数据都有在叶子节点形成单向链表，非叶子节点起到索引的作用。\nMySQL 索引在经典 B+Tree 进行了优化，增加了一个指向相邻叶子节点的链表指针。\nHash 索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，再映射到对应的槽位上，然后存储在 hash 表中。如果两个或多个键值，映射到相同的位置上，就产生了哈希冲突，可以通过链表来解决。\nHash的特点：不支持范围搜索，无法通过索引完成排序，查询效率高。\nMemory 引擎支持 hash 索引，而 InnoDB 自适应 hash 功能。\n为什么 InnoDB 用 B+tree 索引结构？\n相对于二叉树，层级更少，搜索的效率高；\n对于 B-tree ，因为他叶子和非叶子都保存数据，这样一个页内存储的键值对少，如果要保存大量数据，只能增加树都高度；\n相对于 Hash 索引，B+tree 支持范围匹配和排序操作。\n索引分类 主键索引：针对表中主键创建的索引，默认自动创建。PRIMARY。\n唯一索引：避免同一个表中某数据列中的值重复，可以有多个。UNIQUE。\n常规索引：快速定位特定数据，可以有多个。\n全文索引：全文索引查找的是文本中的关键词，可以有多个。FULLTEXT。\n在 InnoDB 存储引擎中，根据索引的存储形式，还可以划分：\n聚群索引（Clustered Index）将数据与索引放到一块，索引结构的叶子节点保存了数据。必须有，且只一个。\n如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用第一个 UNIQUE 索引作为聚集索引。 如果都没有，则 InnoDB 自动生成 rowid 为隐藏的聚集索引。 二级索引（Secondary Index）将数据与索引分开存储，索引结构的叶子节点关联对应主键。可以存在多个。\n例如：SELECT * FROM USER WHERE NAME='Arm';\n1、进行 NAME 字段的二级索引，找到对应的 ID；\n2、根据 ID 进行回表查询，即聚集索引找到 ID 下那一行的数据。\n索引语法 # 创建索引 CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name, ...); # 查看索引 SHOW INDEX FROM table_name; # 删除索引 DROP INDEX index_name ON table_name; SQL 性能分析 SQL 执行频率：SHOW [SESSION|GLOBAL] STATUS; 可以查看数据库指令的访问频次。\nSHOW GLOBAL STATUS LIKE \u0026#39;com______\u0026#39;; 慢查询日志：它记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志。MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（/etc/my.cnf）中配置信息：\n# 开启 MySQL 慢日志查询 slow_query_log = 1 # 设置超 2 秒就视为慢查询 long_query_time = 2 # 重启后，慢查询日志 SHOW VARIABLES LIKE \u0026#39;slow_query_log\u0026#39;; # 生成文件 /var/lib/mysql/localhost-slow.log show profiles 能够在 SQL 优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看见 MySQL 是否支持 profile 操作：\n# 默认关闭，通过 SET 在 session / global 开启 SET profiling = 1; # 查看 profiles 是否开启 SELECT @@have_profiling; # 查看每一条 SQL 的耗时基本情况 SHOW profiles; # 查看指定 query_id 的 SQL 语句各个阶段的耗时情况 SHOW profile FOR query query_id; # 查看指定 query_id 的 SQL 语句 CPU 使用情况 SHOW profile cpu FOR query query_id; EXPLAIN 或 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接或连接的顺序。\n# 直接在 SELECT 语句前加上关键字 explain / desc EXPLAIN SELECT 字段 FROM 表名 WHERE 条件; /* id 相同，从上到下顺序执行；不同则值大的先执行。 select_type 表示 SELECT 类型。 tyep 表连接类型，性能好到差为 NULL、system、const、eq_ref、ref、range、index、all。 possible_key 显示可能应用这个表上的索引，一个或多个。 key 为实际使用的索引。 key_len 索引中使用的字节数，即索引字段最大可能值。 rows MySQL 认为必须要执行查询的行数，这是估计值。 filtered 表示返回结果的行数占所需读取行数的百分比，值越大越好。 */ 索引使用 验证索引效率\n# 未建立索引前执行 SQL SELECT * FROM tb_sku WHERE sn = \u0026#39;100000003145001\u0026#39;; # 针对字段建立索引 CREATE INDEX idx_sku_sn ON tb_sku(sn); # 再次执行 SELECT * FROM tb_sku WHERE sn = \u0026#39;100000003145001\u0026#39;; 最左前缀法：如果进行了联合索引，要遵循最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n范围查询：联合索引中，出现范围查询（\u0026gt;, \u0026lt;），范围查询右侧的列索引失效。在业务允许的情况，尽量使用 \u0026gt;= 或 \u0026lt;=。\n索引列运算：不要在索引列上进行运算操作，索引将失效。此外，如果字符串不加引号，也不会走索引的。\n模糊查询：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失败。\nor 连接条件：如果 or 前字段有索引，而后面的没有索引，则不会用到索引。\n数据分布影响：如果 MySQL 评估使用索引比全表更慢，则不使用索引。\nSQL 提示：就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。\n# USE INDEX explain select * from tb_user use index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; # IGNORE INDEX explain select * from tb_user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; # FORCE explain select * from tb_user force index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 覆盖索引：尽量使用覆盖索引（查询使用了索引，且需要返回的列，在该索引中已经全部能够找到），减少 select *。\nusing index condition ： 查找使用了索引，但是需要回表查询数据。\nusing where; using index ：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。\n前缀索引：当字段类型为字符串时，要索引很长的字符串，这样会浪费磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以节约索引空间。\nCREATE INDEX idx_xxx ON table_name(column(n)); # 前缀长度：不重复数据 和 总数据的比值 SELECT count(distinct email)/count(*) FROM tb_user; SELECT count(distinct substring(email, 1,5)) / count(*) FROM tb_user; 单列索引：即一个索引只包含单个列。\n联合索引：即一个索引包含了多个列。\n业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n# 单列索引情况 MysQL 优化器会自动评估哪个字段的索引效率更高 EXPLAIN select id,phone,name from tb_user where phone=\u0026#39;12314123\u0026#39; and name = \u0026#39;李白\u0026#39;; 索引设计原则 1、数据量大，且查询比较频繁就建立索引；\n2、针对尝作为查询、排序、分组的字段建立索引；\n3、选择区分度高的建立索引，尽量建立唯一索引；\n4、字符串类型字段可建立前缀索引；\n5、尽量使用联合索引，很多时候可以覆盖索引；\n6、控制索引数量，维护索引结构代价要考虑；\n7、索引列不能存储NULL值，就用NOT NULL进行约束。\nSQL 优化 插入数据 -- 批量插入 INSERT INTO tb_test VALUES (1, \u0026#39;Tom\u0026#39;), (2, \u0026#39;Cat\u0026#39;); -- 手动提交事务 START TRANSACTION; INSERT INTO tb_test VALUES (1, \u0026#39;Tom\u0026#39;), (2, \u0026#39;Cat\u0026#39;); INSERT INTO tb_test VALUES (3, \u0026#39;Jerry\u0026#39;), (4, \u0026#39;Mike\u0026#39;); COMMIT; -- 主键顺序插入 -- 大批量插入 # 连接服务器 mysql --local-infile -u root -p # 设置变量，从本地加载文件导入数据 SET GLOBAL local_infile = 1; # 执行 load 指令，加载数据到表 load data local infile \u0026#39;/root/sql1.log\u0026#39; into table \u0026#39;tb_user\u0026#39; fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;; 主键优化 在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为 索引组织表（index organized table IOT）。\n逻辑结构为：TableSpace \u0026gt; Segement \u0026gt; Extend \u0026gt; Page \u0026gt; Row。\n页可以为空，也可以填充一半。每个页包含了 2-N 行数据，如果一行数据太大会行溢出，是根据主键排序的。\n页分裂：主键乱序插入的时候会新建一个页空间，将原有的页一分为二，然后插入新数据。\n页合并：当页删除记录达到 MERGE_THRESHOLD，会查找前后页是否可以进行合并。\n设计原则：\n满足业务需求的情况下，尽量降低主键的长度； 插入数据尽量顺序插入，选择 AUTO_INCREMENT； 尽量不用 UUID 做主键或是其他自然主键，如身份证号； 业务操作时，尽量不对主键修改。 order by 优化 Using filesort：通过表索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 Using index：通过有序索引顺序扫描直接返回有序数据，不需要额外排序。 可以通过指定索引时排序字段的升降序，来进行优化； 注意要遵循左前缀法进行索引。 如果要 filesort 可以适当增加排序缓冲区大小 sort_buffer_size。 group by 优化 分组操作时，可以通过索引来提高效率。 分组操作时，索引的使用也是满足最左前缀法。 limit 优化 # 不直接使用 limit 获取全部数据，而是只获取 id 然后再作为表查询 SELECT s.* FROM tb_sku s, (SELECT id FROM tb_sku ORDER BY id LIMIT 9000000, 10) a WHERE s.id = a.id; count 优化 MyISAM 引擎会把一个表的总行数存在磁盘上；InnoDB 引擎则需要一行一行地计算。\n# 效率排行 ：count(*) \u0026gt; count(1) \u0026gt; count(主键) \u0026gt; count(字段) update优化 InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n视图/存储过程/触发器 视图 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。其实，视图就是保留了 SQL 逻辑，不保存查询结果。\nWITH CHECK OPTION 子句创建时，MySQL 会检查正在更改的行是否符合视图的定义。MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查范围，MySQL 提供了两个选项： CASCADED（默认） 和 LOCAL。\n# 创建 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [with cascaded check option]; # 查询 SHOW CREATE VIEW 视图名称; SELECT * FROM 视图名称 ...; # 修改 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句。 ALTER VIEW 视图名称[(列名列表)] AS SELECT语句。 # 删除 DROP VIEW [IF EXISTS] 视图名; 视图若包含一下项则不可更新：\n1、聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等）； 2、DISTINCT、GROUP BY、HAVING、UNION 或 UNION ALL。 作用：\n经常使用的查询可以被定义为视图，从而用户不必每次操作都指定操作来进行查询了； 数据库授权，通过视图用户只能查询和修改所能见到的数据； 视图可以帮助用户屏蔽真实表结构变化带来的影响。 存储过程 存储过程就是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。\n存储过程思想上，就是数据库 SQL 语句层面的代码封装与重用。可以接收参数，也可以返回数据，减少网络交互，提高效率。\n# 创建 # 通过关键字 delimiter 指定 SQL 语句结束符 /* delimiter $$ CREATE PROCEDURE 存储过程名称([参数列表]) BEGIN -- SQL 语句 END$$ */ CREATE PROCEDURE 存储过程名称([参数列表]) BEGIN -- SQL 语句 END; # 调用 CALL 名称([参数]); # 查看 SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = \u0026#39;xxx\u0026#39;; SHOW CREATE PROCEDURE 存储过程名称; # 删除 DROP PROCEDURE [IF EXISTS] 存储过程名称; 系统变量 是 MySQL 服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSIOM）。\n默认是改变 SESSION 变量。 MySQL 服务器重启后，设置的全局参数会失效，想要不失效，可以在 /etc/my.cnf 中配置。 # 查看系统变量 SHOW [SESSION|GLOBAL] VARIABLES; SHOW [SESSION|GLOBAL] VARIABLES LIKE ...; SELECT @@[SESSION|GLOBAL] 系统变量名; # 设置系统变量 SET [SESSION|GLOBAL] 系统变量名 = 值; SET @@[SESSION|GLOBAL] 系统变量名 = 值; 用户定义变量 是用户根据自己定义的变量，用户变量不用提前声明，在用的时候直接用 \u0026ldquo;@变量名\u0026rdquo; 使用。其作用域为当前连接。\n# 赋值 SET @var_name = expr; SET @var_name := expr; SELECT @var_name := expr; SELECT 字段名 INTO @var_name FROM 表名; # 使用 SELECT @var_name; 局部变量 根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 BEGIN \u0026hellip; END 块。\n# 声明 DECLARE 变量名 变量类型 [DEFAULT ...]; # 赋值 SET 变量名 = 值; SET 变量名 := 值; SELECT 字段名 INTO 变量名 FROM 表名 ...; # if 语句 IF 条件1 THEN ... ELSEIF 条件2 THEN\t... ELSE ... END IF; # 参数 IN、OUT、INOUT CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型]) BEGIN -- SQL 语句 END; # case 语句 CASE case_value WHEN when_value1 THEN statement_list1 ... END CASE; CASE WHEN search_condition1 THEN statement_list1 ... END CASE; # while 语句 WHILE 条件 DO SQL 逻辑 END WHILE; # repeat 语句 REPEAT SQL 逻辑 UNTIL 条件 END REPEAT; # loop 函数 # LEAVE：退出循环；ITERATE：跳过当前循环，进入下次循环。 [begin_label:]LOOP SQL 逻辑 END LOOP [end_label]; CREATE PROCEDURE pp(IN n INT) BEGIN DECLARE total INT DEFAULT 0; sum:LOOP IF n \u0026lt;= 0 THEN LEAVE sum; END IF; SET total := total + n; SET n := n - 1; END LOOP sum; SELECT total; END; /* 游标（CURSOR）用来存储查询结果集的数据类型， 在存储过程和函数中可使用游标对结果集进行循环处理。 */ # 游标声明 DECLARE 游标名称 CURSOR FOR 查询语句; # 打开游标 OPEN 游标名称; # 获取游标记录(循环获取) FETCH 游标名称 INTO 变量; # 关闭游标 CLOSE 游标名称; # 条件处理程序 Handler # handler_action：CONTINUE 继续执行当前程序、EXIT 终止执行当前程序。 # SQLSTATE sqlstate_value 状态码、SQLWARNING 以01开头的SQLSTATE代码简写、NOT FOUND 以02开头的SQLSTATE代码简写、SQLEXCEPTION 其他。 DECLARE handler_action HANDLER FOR condition_value statement; DECLARE exit HANDLER FOR SQLSTATE \u0026#39;02000\u0026#39; CLOSE u_cursor; 存储函数 存储函数是有返回值的存储过程，存储函数的参数只能是 IN 类型的。\n/* DETREMINISTIC：相同的输入参数总是产生相同的结果; NO SQL：不包含 SQL 语句; READS SQL DATA：包含连续读取数据的语句，但不包含写入数据语句。 */ CREATE FUNCTION 存储函数名称([参数列表]) RETURNS type [characteristic ...] BEGIN -- SQL 语句 RETURN ...; END; 触发器 触发器是与表有关的数据库对象。在 insert/update/delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。\n触发器可以协助应用在数据库端保证数据的完整性，日记记录，数据校验等操作。\nOLD 和 NEW 引用触发器中变化的记录内容。支持行级触发。\nINTER 型触发器：NEW 表示将要或者已经新增的数据；\nUPDATE 型触发器：OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据。\nDELETE 型触发器：OLD 表示将要或已经删除的数据。\n# 创建 CREATE TRIGGER trigger_name BEFORE / AFTER INSERT / UPDATE / DELETE ON table_name FOR EACH ROW BEGIN triggle_statement; END; # 查看 SHOW TRIGGERS; # 删除 DROP TRIGGER [schema_name.]trigger_name; -- 通过触发器记录 tb_user 表的变更数据，将变更日志插入到日志表 user_logs 中，包含增加、修改、删除 # 日志表 user_log create table user_logs( id int(11) not null auto_increment; operation varchar(20) not null comment \u0026#39;操作类型\u0026#39;, operation_tim datetime not null comment \u0026#39;操作时间\u0026#39;, operate_id int(11) not null comment \u0026#39;操作ID\u0026#39;, operate_params varchar(500) comment \u0026#39;操作参数\u0026#39;, primary key(id) )engine=innodb default charset=utf8; # 插入数据触发器 create trigger tb_user_insert_trigger after insert on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params) values (null, \u0026#39;insert\u0026#39;, now(), new.id, concat(\u0026#39;插入的数据内容为：id=\u0026#39;, new.id, \u0026#39;, name=\u0026#39;, new.name, \u0026#39;, phone=\u0026#39;, new.phone, \u0026#39;, email=\u0026#39;, new.email)) end; # 更新数据触发器 create trigger tb_user_update_trigger after insert on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params) values (null, \u0026#39;update\u0026#39;, now(), new.id, concat(\u0026#39;更新前内容为：id=\u0026#39;, old.id, \u0026#39;, name=\u0026#39;, old.name, \u0026#39;, phone=\u0026#39;, old.phone, \u0026#39;, email=\u0026#39;, old.email,\u0026#39;更新后内容为：id=\u0026#39;, new.id, \u0026#39;, name=\u0026#39;, new.name, \u0026#39;, phone=\u0026#39;, new.phone, \u0026#39;, email=\u0026#39;, new.email)) end; 锁 锁是计算机协调多个进程或线程并发访问某一资源的机制。\n全局锁：锁定数据库中的所有表。 表级锁：每次操作都锁住整张表。 行级锁：每次操作锁住对应的行数据。 全局锁 加锁后，整个实例就处于只读状态。\n典型场景为全库数据的逻辑备份，对所有表进行锁定。\n1、如果在主库备份，那么备份期间数据不能更新，业务基本停摆；\n2、如果在从库备份，那么备份期间无法执行主库同步过来的二进制日志，主从不一致。\n# 不加锁一致性数据备份 mysqldump --single-transaction -h [address] -uroot -p1234 TestDB \u0026gt; TestDB.sql; # 加锁 flush tables with read lock; # 备份 mysqldump -h [address] -uroot -p1234 TestDB \u0026gt; TestDB.sql; # 解锁 unlock tables; 表级锁 锁定粒度大，发生锁冲突的概率最高，并发度最低。\n主要有这几类:\n表锁 表共享读锁（read lock）：不会阻塞其他客户端的读，但会阻塞写。 表独享写锁（write lock）：写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 元数据锁（meta data lock）：系统自动控制，维护表元数据的一致性，在表上有活动事务时，不可以对元数据进行写入操作。 意向锁：避免行锁和表锁冲突，用意向锁使表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁（IS）：与表共享锁（read）兼容，与表共享锁（read）互斥。 意向排他锁（IX）：与表共享锁（read）和表共享锁（read）都互斥。意向锁之间不互斥。 /* 当开启事务时，就不能对元数据进行操作，只有事务结束了才能操作。 一般来说，读数据是可以加表锁；而改数据是不能加表锁的。 */ # 表锁 LOCK TABLES 表名 READ / WRITE; UNLOCK TABLES / 客户端断开连接; # 加锁 SELECT 语句 LOCK IN SHARE MODE; # 查看元数据锁 SELECT * FROM performance_schema.metadata_locks; # 查看意向锁和行锁 SELECT * FROM performance_schema.data_locks; 行级锁 行级锁，每次操作锁对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。\nInooDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对应记录加的锁。\n行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行 update 和 delete。在 RC、RR 隔离级别下都支持。 间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录间隙不变，防止其他事务在间隙进行 insert ，产生幻读。在 RR 隔离级别下都支持。 临键锁（Next-Key-LOCK）：行锁和同隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 共享锁（S）：允许一个事务去读一行，组织其他事务获取相同数据集的排他锁。\n排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务活得相同的数据集的共享锁和排他锁。\nSQL 行锁类型 说明 INSERT 排他锁 自动加锁 UPDATE 排他锁 自动加锁 DELETE 排他锁 自动加锁 SELECT 不加锁 / SELECT \u0026hellip; LOCK IN SHARE MODE 共享锁 手动加锁 SELECT \u0026hellip; FOR UPDATE 排他锁 手动加锁 1、对唯一索引进行检索，就是行锁。\n2、对没有索引的条件进行检索，会升级为表锁。\n3、索引上进行等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。\n4、索引上进行等值查询（普通索引），向右遍历到最后一个值都不满足查询需求时，next-key lock 退化为间隙。\n5、索引上进行范围查询（唯一索引），会访问直到不满足条件的第一个值为止。\nInnoDB 引擎 逻辑存储结构 TableSpace \u0026raquo;\u0026gt; Segment \u0026raquo;\u0026gt; Extent \u0026raquo;\u0026gt; Page \u0026raquo;\u0026gt; ROW\n表空间（ibd文件）：一个 MySQL 实例可以对应多个表空间，用于存储记录、索引等数据。\n段：数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）、InnoDB 是索引组织表，数据段就是 B+ 树的叶子节点，索引段为 B+ 树的非叶子几点。段用来管理区。\n区：表空间的单元结构，每个区大小为 1M。默认情况，InnoDB 存储引擎页大小为 16k，即一个区中一共有 64个 连续的页。\n页：InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。\n行：InnoDB 存储引擎数据是按行进行存放的。\nTrx_id：每次对某条记录进行改动时，都会把对应的事务 id 赋值给 trx_id 隐藏列。\nRoll_pointer：每次对某条引记录改动时，都会把旧版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它找到该记录修改前的信息。\n架构 内存架构\nBuffer Pool：缓冲池是主内存中的一个区域，缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若没有数据，则从磁盘加载并缓冲），然后以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n缓冲池以 Page 页为单位，底层采用链表数据结构管理 Page。根据状态，将Page分为三种类型：free page 空闲页，没使用过；clean page 被使用过，但数据未修改；dirty page 脏页，就是被使用过也被修改过，与磁盘中的数据产生了不一致。\nChange Buffer：更改缓冲区（针对于二级索引页），在执行 DML 语句，如果数据没有在 Buffer Pool中，不会直接操作磁盘，而是将数据变更后的内容存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到 Buffer Pool中，再将合并后的数据刷新到磁盘中。\n因为二级索引是非唯一的，并且插入顺序是相对随机的，如果要对其更改每次操作都要依赖磁盘，这样会造成大量的磁盘 IO，有了 ChangeBuffer 后，我们可以在缓冲池汇总进行合并处理，减少磁盘 IO。\nAdaptive Hash Index：自适应 hash 索引，用于优化对 Buffer Pool 数据的查询。InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到 Hash 索引可以提升速度，则建立 Hash 索引，称之为自适应 Hash 索引。参数：adaptive_hash_index。\nLog Buffer：日志缓冲区，用来保护要写入到磁盘中的 log 日志数据（redo log、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除多行的事务，增加日志缓冲区的大小可以节省磁盘 IO。参数：innodb_log_buffer_size、innodb_flush_log_at_trx_commit。1：日志在每次事务提交时写入并刷新到磁盘；0：每秒将日志写入并刷新到磁盘一次；2：日志在每次事务提交后写入，并每秒刷新到磁盘一次。\n磁盘结构\nSystem TableSapce：系统表空间是更改缓冲区的存储区域。如果表是在系统空间而不是每个表文件或通用表空间创建的，它也可能包含表和索引数据。参数：innodb_data_file_path。\nFile-Per-Table Tablespace：每个表的文件表空间包含单个 InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件。参数：innodb_file_per_table。\nGeneral Tablespaces：通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。\n# 创建表空间 CREATE TABLESPACE xxx ADD DATAFILE \u0026#39;file_name\u0026#39; ENGINE = engine_name; # 创建表 CREATE TABLE xxx TABLESPACE ts_name; Undo TableSpaces：撤销表空间，MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小16M），用于存储undo log日志。\nTemporay Tablespaces：InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表数据。\nDoublewrite Buffer Files：双写缓冲区，InnoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，线将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。\nRedo Log：重写日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事务提交后会把所有修改信息都会存到日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。循环写入重做日志文件，涉及两个文件：ib_logfile0、ib_logfile1。\n后台线程\nMaster Thread：核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓冲、undo页的回收。\nIO Thread：AIO负责IO请求的回调。Read thread （4）、Write thread（4）、Log thread（1）、Insert buffer thread（1）。\nSHOW ENGINE innodb status; Purge Thread：主要用于回收事务已经提交了的undo log，在事务提交后，undo log可能不用了，就用它来回收。\nPage Cleaner Thread：协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。\n事务原理 事务就是一组操作的集合，将所有操作视作是一个整体向系统提交，若是其中某个操作失败了，就会执行回滚操作。\n事务具有 ACID 的特性：\n原子性，就是事务不可分割，要么全部执行成功，要么全部执行失败。\n一致性，事务完成时，必须让所有数据保持一致性。\n隔离性，事务不受外部并发操作影响。\n持久性，事务一旦提交或回滚，数据的改变就是永久的。\n原子性 - undo log\n持久性 - redo log\n一致性 - undo log + redo log\n隔离性 - 锁 + MVCC\nredo：重做日志，记录的是事务提交时数据页的物理修改，用来实现事务的持久性。\n该日志文件由两部分组成，重做日志缓冲（redo log buffer）、重做日志文件（redo log file）。前者是在内存中，后者在磁盘中，当事务提交后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。\nundo：回滚日志，用于记录数据被修改前的信息，包括提交回滚和MVCC（多版本并发控制）。undo log 和 redo log 记录物理日志不一样，他是逻辑日志。也就是当用户执行一次 delete 记录时，undo log 会记录一条 insert 记录，以方便回滚。\nundo log 销毁：undo log 在事务执行时产生，事务提交时，不会立刻删除 undo log，因为这些日志还用于 MVCC。\nundo log 存储：undo log 采用段方式进行管理和记录，存放在前面介绍 rollback segment 回滚段中，内部包含 1024 个 undo log segment。\nMVCC 当前读：读取记录的最新版本，读取时保证其他并发事务不能修改当前记录，会对读取记录进行加锁。\n快照读：简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。\nRead Committed：每次 select 都生成一个快照读。 Repetabel Read：开启事务后第一个 select 语句是快照读。 Serializable：快照读退化为当前读。 MVCC：Multi-Version Concurrency Control，多版本并发控制。也就是维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，依赖数据库记录中的三个隐式字段、undo log日志、readView。\n隐藏字段：\nDB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改为该记录的事务ID。 DB_ROLL_PTR 回滚指针，指向这条记录的上个版本，用于配合 undo log，指向上个版本。 DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。 undo log：回滚日志，在 insert、update、delete 时产生便于数据回滚的日志。当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。\n不同事务或相同事务对同一条记录修改，会导致该记录的 undo log 生成一条记录版本链表，链表头部是最新的旧记录，链表尾部是最早的旧记录。\nreadview：读视图，是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。\nm_ids 当前活跃的事务ID集合。 min_trx_id 最小活跃事务ID。 max_trx_id 预分配事务ID，当前最大事务ID+1。 creator_trx_id ReadView 创建者事务ID。 版本链数据访问规则：\nREAD COMMITED：在事务中每一次执行快照读时生成ReadView。\nREPEATABLE READ：仅在事务第一次执行汇快照读时生成ReadView，后续复用该 ReadView。\nTRX_ID == CREATOR_TRX_ID（✓）- 数据是当前事务更改的。 TRX_ID \u0026lt; MIN_TRX_ID（✓）- 说明数据已经提交了。 TRX_ID \u0026gt; MAX_TRX_ID（×）- 说明事务是在 ReadView 生产后才开启。 MIN_TRX_ID \u0026lt;= TRX_ID \u0026lt;= MAX_TRX_ID（不在集合中可访问）- 说明数据已经提交。 MySQL 管理 系统数据库 MySQL 自带四个数据库：\nmysql 存储 MySQL 服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）。 information_schema 提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等。 performance_schema 为 MySQL 服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数。 sys 包含了一系列方便 DBA 和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图。 常用工具 MySQL 客户端\n语法：mysql [options] [database]\n选项：-u, \u0026ndash;user=name\n​\t-p,\u0026ndash;password[=name]\n​\t-h,\u0026ndash;host=name\n​\t-p,\u0026ndash;port=port\n​\t-e,\u0026ndash;excute=name\nmysql -uroot -p123456 db01 -e \u0026#34;select * from stu*\u0026#34; mysqladmin：执行管理操作的客户端程序，用它来检查服务器的配置和当前状态、创建并删除数据库等。\nmysqladmin -uroot -p123456 drop \u0026#39;test01\u0026#39; mysqladmin -uroot -p123456 version mysqlbinlog：由服务器生成对二进制日志文件以二进制格式保存，如果想要检查这些文本格式，就会用到该日志管理工具\n语法：mysqlbinlog [options] log-files1 log-file2\n选项：-d,\u0026ndash;database=name\t指定数据库名称，只列出指定的数据库相关操作\n​\t-o,\u0026ndash;offset=#\t忽略日志中的前n行命令\n​\t-r,\u0026ndash;result-file=name\t将输出的文本格式日志输出到指定文件\n​\t-s,\u0026ndash;short-form\t显示简单格式，省略掉一些信息\n​\t-v\t将行事件（数据变更）重构为 SQL 语句\n​\t-vv\t将行事件（数据变更）重构为 SQL 语句，并输出注释信息\n​\t\u0026ndash;start-datetime=date1 \u0026ndash;stop-datetime=date2\t指定日期间隔内的所有日志\n​\t\u0026ndash;start-position=pos1 \u0026ndash;stop-position=pos2\t指定位置间隔内的所有日志\nmysqlshow：mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。\n语法：mysqlshow [options] [db_name [table_name [col_name]]]\n选项：\u0026ndash;count\t显示数据库及表的统计信息（数据库，表均可以不指定）\n​\t-i\t显示指定数据库或者执行表的状态信息\n# 查询每个数据库的表的数量以及表中记录的数量 mysqlshow -uroot -p1234 --count # 查询 test 库中每个表的字段数，以及行数 mysqlshow -uroot -p1234 test --count # 查询 test 库中 book 表的详细情况 mysqlshow -uroot -p1234 test book --count mysqldump：用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，以及插入表的 SQL 语句。\n语法：mysqldump [options] db_name [tables]\n​\tmysqldump [options] \u0026ndash;database/-B db1 [db2 db3 \u0026hellip;]\n​\tmysqldump [options] \u0026ndash;all-database/-A\n连接选项：-u,\u0026ndash;user=name\n​\t-p,\u0026ndash;password[=name]\n​\t-h,\u0026ndash;host=name\n​\t-p,\u0026ndash;port=#\n输出选项：\u0026ndash;add-drop-database\t在每个数据库创建语句前加上 drop database\n​\t\u0026ndash;add-drop-table\t在表创建语句前加上 drop table\n​\t-n,\u0026ndash;no-create-db\t不包含数据库的创建\n​\t-t,\u0026ndash;no-create-info\t不包含数据表的创建\n​\t-d,\u0026ndash;no-data\t不包含数据\n​\t-T,\u0026ndash;tab-name\t自动生成两个文件，一个.sql文件，创建表结构;一个.txt文件，数据文件。（show variables liek '%secure_file_priv;'）\nmysqlimport/soucre：数据导入工具，用来导入 mysqldump -T 导出的文本文件。\n语法：mysqlimport [options] db_name textfile1 [textfile2 \u0026hellip;]\n​\tsource /root/xxxx.sql\nsource /root/test.sql mysqlimport -uroot -p1234 test /tmp/city.txt 运维篇 日志 错误日志 错误日志记录了 mysqld 启动和停止时，以及在运行过程中发生任何错误时的相关信息。该日志默认开启，存放目录为 /var/log/，默认日志文件名mysqld.log。\n# 查看日志文件地址 SHOW VARIABLES LIKE \u0026#39;%log_error%\u0026#39;; 二进制日志 二进制日志（BINLOG）记录了所有 DDL 和 DML 语句，但不包含 DQL 语句。\n作用：灾难时的数据恢复；MySQL 主从复制\n# 查看日志文件地址 SHOW VARIABLES LIKE \u0026#39;%log_bin\u0026#39;; MySQL 提供了多种格式来记录二进制日志：\nSTATEMENT - 基于 SQL 语句的日志记录，记录的是 SQL 语句，对数据进行修改的 SQL 都会记录在日志文件中。 ROW - 基于行的日志记录，记录的是每一行的数据。 MIXED - 混合了 STATEMENT 和 ROW 两种格式，默认采用 STATEMENT，在某些特殊情况下会自动切换为 ROW 进行记录。 # 查看格式 SHOW VARIABLES LIKE \u0026#39;%binlog_format%\u0026#39;; 日志删除方式：\nreset master\t删除全部 binlog 日志，删除后，日志编号，将从 binlog.000001 重新开始 purge master logs to \u0026lsquo;binlog.xxxxxx\u0026rsquo; 删除 xxxxxx 编号之前的所有日志 purge master logs before \u0026lsquo;yyyy-mm-dd hh24:mi:ss\u0026rsquo; 删除日志为 \u0026lsquo;yyyy-mm-dd hh24:mi:ss\u0026rsquo; 之前产生的所有日志 可以在 MySQL 配置文件 /etc/my.cnf 中配置二进制日志：\nSHOW VARIABLES LIKE \u0026#39;%binlog_expire_logs_seconds%\u0026#39;; 查询日志 查询日志记录了客户端所有操作语句，而二进制日志不包含数据的 SQL 语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置配置：\n# 查询 general_log 是否开启 SHOW VARIABLES LIKE \u0026#39;%general%\u0026#39;; # 在配置中开启查询日志 general_log = 1 # 设置文件名默认为 host_name.log general_log_file = mysql_query.log 慢查询日志 慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录不小于 min_examined_row_limit 的所有 SQL 语句日志，默认未开启。long_query_time 默认为 10 秒，最小为 0，精度可到微秒。\n# 慢查询日志 slow_query_log = 1 # 执行时间参数 long_query_time = 2 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements 和更改此行为 log_queries_not_using_indexes。\n# 记录执行较慢的管理语句 log_slow_admin_statements = 1 # 记录执行较慢的未使用索引的语句 log_queries_not_using_indexs = 1 主从复制 概述 主从复制就是将数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。\nMySQL 支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。\n1.主库出现问题，可以快速切换到从库提供服务。 2.实现读写分离，降低主库的访问压力。 3.可以在从库中执行备份，以避免备份期间影响主库服务。 原理 1、Master 主库提交事务时，会将数据变更记录在二进制日志文件 Binlog 中。\n2、从库读取主库的二进制文件 Binlog ，写入到从库的中继日志 Replay Log。\n3、slave 重做中继日志中的事件，将改变反映它自己的数据。\n搭建 服务器准备：\n192.168.200.200（master）\n192.168.200.201（slave）\n# 开放指定 3306 端口号 firewall-cmd --zone=public --add-port=3306/tcp -permanent firewall-cmd -reload # 关闭服务器防火墙 systemctl stop firewalld systemctl diable firewalld 主库配置：\n1、修改配置文件 /etc/my.cnf\n# mysql 服务器 ID，确保集群中唯一 server-id = 1 # 是否只读，1 代表只读，0代表读写 read-only = 0 # 忽略的数据，指不需要同步的数据库 # binlog-ignore-db = mysql # 指定同步的数据库 # binlog-do-db = db01 2、重启 MySQL 服务器\nsystemctl restart mysqld 3、登录 MySQL，创建远程连接账号，并授予主从复制权限\n# 创建用户 CREATE USER \u0026#39;master\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;root@123456\u0026#39;; # 分配主从复制权限 GRANT REPLICATION SLAVE ON *.* TO \u0026#39;master\u0026#39;@\u0026#39;%\u0026#39; 4、查看二进制日志坐标\n/* file 从哪个日志文件开始推送 postions 从哪个位置开始推送 binlog_ignore_db 指定不需要同步的数据库 */ SHOW MASTER STATUS; 从库配置：\n1、修改配置文件 /etc/my.cnf\n# 设置服务器 ID server-id = 2 # 是否只读 read-only = 1 2、重启 MySQL\nsystemctl mysql restart 3、登录 MySQL，设置主库配置\nCHANGE REPLICATION SOURCE TO SOURCE_HOST=\u0026#39;xxx.xxx\u0026#39;,SOURCE_USER=\u0026#39;xxx\u0026#39;,SOURCE_PASSWORD=\u0026#39;xxx\u0026#39;,SOURCE_LOG_FILE=\u0026#39;xxx\u0026#39;,SOURCE_LOG_POS=xxx; 4、开启同步操作\nSTART REPLICA; 5、查看主从同步状态\nSHOW REPLICA STATUS; ​\n","date":"2024-03-22T15:51:46+08:00","image":"https://yikuanzz.github.io/2024/mysql/cover_huf4d320014c591f4e374d934afecc756b_255935_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/mysql/","title":"MySQL"}]