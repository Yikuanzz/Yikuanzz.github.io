[{"content":"输入/输出（I/O）是在主存和外部设备之间复制数据的过程。\n在 Linux 系统中，通过使用由内核提供的系统级 Unix I/O 函数来实现高级别的 I/O 函数。\nUnix I/O 一个 Linux 文件就是一个 $m$ 个字节的序列： $$ B_0, B_1,\\dots,B_k,\\dots,B_{m-1} $$ 所有的 I/O 设备被模型化为文件，而所有的输入和输出都被当作对应文件的读写来执行，允许 Linux 内核引出一个简单、低级的应用接口，称为 Unix I/O，这样使所有的输入和输出能用统一的方式来执行：\n打开文件：程序要求内核打开文件，内核会返回一个小的非负整数的描述符，它在后续对此文件的所有操作中标识这个文件。 每个进程开始时打开三个文件：标准输入（描述符0）、标准输出（描述符1）和标准错误（描述符2）。头文件 \u0026lt;unistd.h\u0026gt; 定义了常量 STDIN_FILENO、STDOUT_FILENO 和 STDERR_FILENO。 改变当前文件位置：对于每个打开的文件，内核保持一个文件的位置 k ，初始为 0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek 操作，设置文件的位置。 读写文件：一个读操作就是从文件复制 n \u0026gt; 0 个字节到内存，从当前文件位置 k 开始增加到 k+n 。给定一个大小为 m 字节的文件，当 k \u0026gt;= m 时执行读操作会触发 end-of-file（EOF）的条件。那么写操作就是从内存复制 n \u0026gt; 0 个字节到文件。 关闭文件：程序通知内核关闭这个文件，内核会释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。 文件 文件类型如下：\n普通文件（regular file）包含任意数据，通常区分文本文件和二进制文件。只是文本文件中有 ASCII 或 Unicode 字符。 目录（directory）是包含一组链接（link）的文件，每个链接都将一个文件名映射到一个文件，每个目录至少有 . 和 ..，代表当前目录的链接和到父目录的链接。 套接字（socket）用来与另一个进程进行跨网络通信的文件。 打开和关闭文件 进程通过 open 函数来打开或创建文件的：\n# include \u0026lt;sys/types.h\u0026gt; # include \u0026lt;sys/stat.h\u0026gt; # include \u0026lt;fcntl.h\u0026gt; // 成功返回文件描述符，出错返回 -1 int open(char *filename, int flags, mode_t mode);\tflags 参数可选：\nO_RDONLY：只读。 O_WRONLY：只写。 O_RDWR：可读可写。 fd = open(\u0026#34;foo.txt\u0026#34;, O_RDONLY, 0); flags 参数是多位掩码的或：\nO_CRETE：如果文件不存在就创建一个空文件。 O_TRUNC：如果文件存在就截断。 O_APPEND：写操作时设置文件位置到文件结尾。 fd = open(\u0026#34;foo.txt\u0026#34;, O_WRONLY|O_APPEND, 0); mode 参数指定了新文件的访问权限。\numask\n在 Linux 中，umsak 用于设置新建文件和目录的默认权限。它由3位八进制数表示，分别表示用户、组和其他用户的权限掩码。\n# define DEF_MODE S_IRUSR|S_IWUSR|S_IROTH|S_IWOTH # define DEF_UMASK S_IWGRP|S_IWOTH umask(DEF_UMASK); fd = open(\u0026#34;foo.txt\u0026#34;, O_CREAT|O_TRUNC|O_WRONLY, DEF_MODE); 最后进程通过 close 函数关闭文件。\n# include \u0026lt;unisted.h\u0026gt; // 成功返回 0， 否则返回 -1 int close(int fd); 读和写文件 通过调用 read 和 write 函数来执行读写：\n# include \u0026lt;unistd.h\u0026gt; // 成功返回读的字节数；EOF 为 0；出错 -1 ssize_t read(int fd, void *buf, size_t n); // 成功返回写的字节数，错为 -1. ssize_t write(int fd, const void *buf, size_t n); size_t 和 ssize_t\nsize_t 一般用来表示一种计数，比如有多少东西被拷贝等。它在数组下标和内存管理函数等地方广泛使用。 ssize_t 用来表示可以被执行读写操作的数据块的大小，它表示的是有符号的 size_t 类型。 char c; while (read(STDIN_FILENO, \u0026amp;c, 1) != 0) write(STDOU_FILENO, \u0026amp;c, 1); exit(0); RIO 健壮地读写 RIO（Robust I/O）提供了两种函数处理不足值（short count）。\n无缓冲输入输出：直接在内存和文件之间传送数据，没有应用级缓冲。\nrio_readn 函数：\n此函数尝试从文件描述符 fd 中读取 n 个字符到用户缓冲区 usrbuf 中。 如果被信号处理函数中断，它会再次尝试读取，确保读取到 n 个字节。 与普通的 read 函数不同，rio_readn 解决了在网络编程中可能读取到的字节数少于请求数量的问题。 // 成功返回读的字节数；EOF 为 0；出错 -1 ssize_t rio_readn(int fd, void *usrbuf, size_t n) { size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft \u0026gt; 0) { if ((nread = read(fd, bufp, nleft)) \u0026lt; 0) { if (errno == EINTR) nread = 0; // 被信号处理函数中断，再次尝试读取 else return -1; // 出错，errno 由 read 设置 } else if (nread == 0) // 读取到 EOF break; nleft -= nread; // 剩下的字符数减去本次读到的字符数 bufp += nread; // 缓冲区指针向右移动 } return (n - nleft); // 返回实际读取的字符数 } rio_writen 函数：\n此函数类似于 rio_readn，但用于写出数据。 它保证写出 n 字节，不会返回不足值。 // 成功返回写的字节数，错为 -1. ssize_t rio_writen(int fd, void *usrbuf, size_t n) { size_t nleft = n; ssize_t nwritten; char *bufp = usrbuf; while (nleft \u0026gt; 0) { if ((nwritten = write(fd, bufp, nleft)) \u0026lt;= 0) { if (errno == EINTR) nwritten = 0; else return -1; } nleft -= nwritten; bufp += nwritten; } return n; } 带缓冲带输入：\nrio_readlineb 从内部读缓冲区复制一个文本行，当缓冲区变空时，会自动地调用 read 重新填满缓冲区，如果文件既包含 文本行也二进制数据文件，就用 rio_readn 的缓冲版本 rio_readnb，它从和 rio_readlineb 一样的缓冲区中传送原始字节。\nvoid rio_readinitb(rio_t *rp, int fd); ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen); ssize_t rio_readnb(rio_t *rp, void *userbuf, size_t n); 每打开一个描述符，都会调用一次 rio_readinitb 函数，它将描述符 fd 和 地址 rp 处的一个类型为 rio_t 的缓冲区联系起来。\n# define RIO_BUFSIZE 8192 typedef struct{ int rio_fd; int rio_cnt; char *rio_bufptr; char rio_buf[RIO_BUFSIZE]; } void rio_readinitb(rio_t *rp, int fd){ rp-\u0026gt;rio_fd = fd; rp-\u0026gt;fio_cnt = 0; rp-\u0026gt;rio_bufptr = rp-\u0026gt;rio_buf; } rio_readlineb 函数从文件 rp 读出下一个文本行（包括结尾的换行符），复制到 usrbuf ，并用 NULL 字符来结束这个文本行。超过 maxlen-1 的文本行会被截断，并用一个 NULL 字符结束。\n注意：带缓冲的函数调用不应该和无缓冲的 rio_readn 交叉调用。\nint main(int argc, char **argv){ int n; rio_t rio; char buf[MAXLINE]; // 先初始化将数据读取到内置的缓冲区中 Rio_readinitb(\u0026amp;rio, STDIN_FILENO); while ((n = Rio_readlineb(\u0026amp;rio, buf, MAXLINE)) != 0) Rio_write(STDOUT_FILENO, buf, n); } 我们一起看一下 rio_read 函数的实现：\nstatic ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n){ int cnt; // 处理缓冲区 while (rp-\u0026gt;rio_cnt \u0026lt;= 0){ // 用 read 读取到缓冲区中 rp -\u0026gt; rio_cnt = read(rp-\u0026gt;rio_fd, rp-\u0026gt;rio_buf, sizeof(rp-\u0026gt;rio_buf)); if (rp-\u0026gt;rio_cnt \u0026lt; 0){ if (errno != EINTR) return -1 } else if (rp -\u0026gt; rio_cnt == 0) return 0; else // 加载成功后重置 buffer 地址 rp-\u0026gt;rio_bufptr = rp-\u0026gt;rio_buf; } // 将数据从缓冲区复制到用户缓冲区 cnt = n; if (rp-\u0026gt;rio_cnt \u0026lt; n) cnt = rp -\u0026gt; rio_cnt; memcpy(usrbuf, rp-\u0026gt;rio_bufptr, cnt); rp-\u0026gt;rio_bufptr += n; rp-\u0026gt;rio_cnt -= cnt; return cnt; } errno\nerrno 是一个全局变量，用于表示最近一次发生的错误代码，它被定义在 errno.h 头文件中。\n接着，我们再看到 rio_readlineb 函数和 rio_readnb 函数：\nssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen){ int n, rc; char c, *bufp = usrbuf; for (n = 1; n \u0026lt; maxlen; n++){ if ((rc = rio_read(rp, \u0026amp;c, 1)) == 1){ *bufp++ = c; if (c == \u0026#39;\\n\u0026#39;){ n++; break; } }else if (rc == 0){ if (n == 1) return 0; else break; } else return -1; } *bufp = 0; return n-1; } ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n){ size_t nleft = n; ssize_t nread; char *bufp = usrbuf; while (nleft \u0026gt; 0){ if ((nread = rio_read(rp, bufp, nleft)) \u0026lt; 0) return -1; else if(nread == 0) break; nleft -= nread; bufp += nread; } return (n - nleft); } ​\n读取文件元数据 检索关于文件的信息，也就是元数据（meta data）：\n# include \u0026lt;unistd.h\u0026gt; # include \u0026lt;sys/stata.h\u0026gt; int stat(const char *filename, struct stat *buf); int fstat(int fd, struct stat*buf); st_size 成员包含了文件的字节数大小。st_mode 成员编码了文件访问许可位和文件类型，它的低9位标识了文件所有者、组用户和其他用户的读写执行权限。\n这些权限位的含义如下：\n文件类型： S_IFIFO：管道或 FIFO 文件。 S_IFCHR：字符特殊文件。 S_IFDIR：目录文件。 S_IFBLK：块特殊文件。 S_IFREG：普通文件。 S_IFLNK：链接文件。 S_IFSOCK：套接字。 文件访问权限控制： S_ISVTX：粘住位。 S_ISGID：将进程的有效组 ID 设置为文件的组所有者 ID。 S_ISUID：将进程的有效用户 ID 设置为文件的用户 ID。 文件访问权限： S_IXOTH：其他用户可执行。 S_IWOTH：其他用户可写。 S_IROTH：其他用户可读。 S_IXGRP：组用户可执行。 S_IWGRP：组用户可写。 S_IRGRP：组用户可读。 S_IXUSR：文件所有者可执行。 S_IWUSR：文件所有者可写。 S_IRUSR：文件所有者可读。 粘住位（也称为黏滞位）是 Unix 文件系统权限的一个特殊标志。它在文件或目录的权限中起到重要作用。\n文件的粘住位： 如果一个可执行程序文件设置了粘住位，那么在该程序第一次执行并结束时，该程序正文的一部分会被保存在交换区（swap space）中。 正文部分指的是机器指令部分，这使得下次执行该程序时能更快地将其装入内存区。 在交换区中，文件是连续存放的，而在一般的 Unix 文件系统中，文件的各数据块很可能是随机存放的。 常用的应用程序，例如文本编辑程序和编译程序，通常设置了它们所在文件的粘住位。 现今较新的 Unix 系统大多数都具有虚存系统以及快速文件系统，所以不再需要使用这种技术。 目录的粘住位： 在目录上设置粘住位，只有对该目录具有写许可权的用户并且满足以下条件之一，才能删除或更名该目录下的文件： 拥有此文件。 拥有此目录。 是超级用户。 例如，目录 /tmp 和 /var/spool/uucp/public 是设置粘住位的候选者，这两个目录是任何用户都可以在其中创建文件的目录。 这两个目录对任一用户（用户、组和其他）的许可权通常都是读、写和执行。但是用户不应能删除或更名属于其他人的文件，因此在这两个目录的文件上都设置了粘住位。 Linux 在 sys/stat.h 中定义了宏来去定 st_mode 成员的文件类型：\nS_ISREG(m)。这是一个普通文件吗？ S_ISDIR(m)。这是一个目录文件吗？ S_ISSOCK(m)。这是一个网络套接字吗？ int main(int argc, char **argv){ struct stat stat; char *type, *readok; Stat(argv[1], \u0026amp;stat); if (S_ISREG(stat.st_mode)) type = \u0026#34;regular\u0026#34;; else if (S_ISDIR(stat.st_mode)) type = \u0026#34;directory\u0026#34;; else type = \u0026#34;other\u0026#34;; if ((stat.st_mode \u0026amp; S_IRUSR)) redok = \u0026#34;yes\u0026#34;; else readok = \u0026#34;no\u0026#34;; printf(\u0026#34;type: %s, read: %s\\n\u0026#34;, type, readok); exit(0); } 读取目录内容 用 readdir 系列函数来读取目录的内容：\n# include \u0026lt;sys/types.h\u0026gt; # include \u0026lt;dirent.h\u0026gt; // 成功返回处理的指针；出错为NULL DIR *opendir(const char *name); 函数 opendir 以路径名为参数，返回指向目录流（directory stream）的指针，流是对条目有序列表的抽象，在这里指目录项的列表。\n# include \u0026lt;dirent.h\u0026gt; // 成功则为指向下一个目录项的指针没有更多目录或出错就为NULL并设置errno struct dirent *readdir(DIR *dirp); 每次对 readdir 的调用返回到都是指向流 drip 中下一个目录项的指针，每个目录项都是一个结构：\nstruct dirent{ ino_t d_ino;\t// inode number char d_name[256];\t// filename } 什么是 inode？ 理解 inode 需要从文件存储说起。 文件存储在硬盘上，硬盘的最小存储单位叫做“扇区”（Sector）。 每个扇区储存512字节（相当于0.5KB）。 操作系统读取硬盘时，不会一个个扇区地读取，而是一次性连续读取多个扇区，即一次性读取一个“块”（block）。 这种由多个扇区组成的“块”是文件存取的最小单位。 “块”的大小通常是4KB，即连续八个扇区组成一个 block。 文件数据存储在“块”中，但我们还需要找到一个地方来存储文件的元信息，例如文件的创建者、创建日期、大小等等。 这个存储文件元信息的区域就叫做 inode，中文译名为“索引节点”。 每个文件都有对应的 inode，里面包含了与该文件有关的一些信息。 inode 的内容 inode 包含文件的元信息，具体包括： 文件的字节数 文件拥有者的 User ID 文件的 Group ID 文件的读、写、执行权限 文件的时间戳（ctime、mtime、atime） 链接数（有多少文件名指向这个 inode） 文件数据 block 的位置 除了文件名以外的所有文件信息都存在 inode 中。 inode 的大小 inode 也会消耗硬盘空间，因此硬盘格式化时会自动将硬盘分成两个区域：数据区和 inode 区（inode table）。 每个 inode 节点的大小一般是128字节或256字节。 inode 节点的总数在格式化时给定，通常是每1KB或每2KB设置一个 inode。 如果 inode 节点用尽，但硬盘未满，就无法在硬盘上创建新文件。 inode 号码 每个 inode 都有一个号码，操作系统用 inode 号码来识别不同的文件。 Unix/Linux 系统内部不使用文件名，而使用 inode 号码来识别文件。 文件名只是 inode 号码便于识别的别称。 使用 ls -i 命令可以查看文件名对应的 inode 号码。 目录文件 目录（directory）也是一种文件，实际上就是目录文件。 目录文件的结构是一系列目录项（dirent）的列表，每个目录项包含文件名和对应的 inode 号码。 使用 ls -l 命令可以列出文件的详细信息。 硬链接 Unix/Linux 系统允许多个文件名指向同一个 inode 号码，这称为“硬链接”（hard link）。 硬链接可以创建相同 inode 号码的文件，删除一个文件名不影响其他文件名的访问。 软链接 文件 A 的内容是文件 B 的路径，这称为“软链接”（soft link）或“符号链接”（symbolic link）。 文件 A 依赖于文件 B 存在，删除文件 B 会导致打开文件 A 报错。 我们通过 closedir 关闭流并释放所有的资源。\n# include \u0026lt;dirent.h\u0026gt; int closedir(DIR *dirp); 接下来，我们看一看实例：\nint main(int argc, char **argv){ DIR *streamp; struct dirent *dep; streamp = opendir(argv[1]); errno = 0; while ((dep = readdir(streamp)) != NULL){ printf(\u0026#34;Found file: %s \\n\u0026#34;, dep-\u0026gt;d_name); } if (errno != 0) unix_error(\u0026#34;readdir error\u0026#34;); closedir(streamp); eixt(0); } 共享文件 内核用三个相关的数据结构来表示打开的文件：\n描述符表（descriptor table）。每个进程都有它独立的描述表，它的表项是由进程打开的文件描述符来索引的。 文件表（file table）。打开文件集合是由一张文件表来表示的，所有进程共享这张表。每个表项包括： 当前的文件位置：表示下一次读或写的位置。 引用计数：表示有多少个描述符指向该文件表表项。 指向 v-node 表中对应表项的指针。 v-node 表（v-node table）。同文件表一样，所有的进程共享这账 v-node 表。每个 v-node 表表项对应一个文件，记录文件的元数据信息，如权限、大小、类型等。 多个描述符也可以通过不同的文件表项来引用同一个文件。当用同一个 filename 调用 open 函数两次就会出现这种情况。\n在调用 fork 之后，子进程会有父进程的一个描述符表的副本。父子进程共享相同的文件打开集合，因此共享相同的文件位置。\nfork、wait 和 waitpid\nfork()：\nfork() 函数用于创建新进程。当父进程调用fork() 时，会生成一个子进程。子进程与父进程共享相同的代码段、数据段、堆栈段等。 在子进程中，fork() 返回0；在父进程中，返回子进程的进程ID。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { pid_t pid = fork(); if (pid == 0) { printf(\u0026#34;我是子进程，进程ID：%d\\n\u0026#34;, getpid()); } else if (pid \u0026gt; 0) { printf(\u0026#34;我是父进程，进程ID：%d，子进程ID：%d\\n\u0026#34;, getpid(), pid); } else { printf(\u0026#34;fork出错！\\n\u0026#34;); } return 0; } wait()：\nwait() 函数用于等待子进程结束。当子进程终止时，父进程通过 wait() 获取子进程的退出状态。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { pid_t pid = fork(); if (pid == 0) { printf(\u0026#34;我是子进程，进程ID：%d\\n\u0026#34;, getpid()); exit(0); } else if (pid \u0026gt; 0) { printf(\u0026#34;我是父进程，进程ID：%d，子进程ID：%d\\n\u0026#34;, getpid(), pid); int status; pid_t wpid = wait(\u0026amp;status); if (wpid == -1) { perror(\u0026#34;wait出错\u0026#34;); exit(1); } if (WIFEXITED(status)) { printf(\u0026#34;子进程以状态 %d 退出\\n\u0026#34;, WEXITSTATUS(status)); } } else { printf(\u0026#34;fork出错！\\n\u0026#34;); } return 0; } waitpid()：\nwaitpid()函数类似于wait()，但提供更灵活的等待方式。您可以指定等待特定的子进程，以及控制等待的行为。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/wait.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int status; pid_t pid = fork(); if (pid \u0026lt; 0) { printf(\u0026#34;fork出错\\n\u0026#34;); } else if (pid == 0) { printf(\u0026#34;这是子进程，进程ID：%d\\n\u0026#34;, getpid()); sleep(1); return 1; } else { printf(\u0026#34;这是父进程，进程ID：%d\\n\u0026#34;, getpid()); pid_t wait_pid = waitpid(pid, \u0026amp;status, 0); printf(\u0026#34;子进程 %d 以状态 %d 退出\\n\u0026#34;, wait_pid, WEXITSTATUS(status)); } return 0; } I/O 重定向 Linux shell 提供的重定向就是，允许用户将磁盘文件和标准输入输出联系起来。\n当 Web 服务器代表客户运行 CGI 程序的时候，它就执行一种相似类型的重定向。\n# include \u0026lt;unistd\u0026gt; int dup2(int oldfd, int newfd); dup2 函数复制 oldfd 文件内容到 newfd 文件，覆盖 newfd。如果 newfd 是打开了，则会在复制之前被关闭。那么实际上，我们并不需要对 newfd 的内容进行覆盖，我们只需要将描述符指向 oldfd 就可以了。\n通过调用 dup2(4,1) 重定向后，文件A被关闭，原本的描述符会指向文件 B。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;unistd.h\u0026gt; int main(){ int fd1, fd2; char c; fd1 = open(\u0026#34;foo.txt\u0026#34;, \u0026amp;c, 1); fd2 = open(\u0026#34;foo.txt\u0026#34;, \u0026amp;c, 1); read(fd2, \u0026amp;c, 1); dup2(fd2, fd1); read(fd1, \u0026amp;c, 1); printf(\u0026#34;c = %c \\n\u0026#34;, c); } 标准 I/O\n标准 I/O 库将一个打开都文件模型化为 流。一个流就是一个指向 FILE 类型的结构的指针。\n每个 ANSI C 程序开始都有三个打开的流 stdin、stdout 和 stderr。\n# include \u0026lt;stdio.h\u0026gt; extern FILE *stdin;\t// 0 extern FILE *stdout;\t// 1 extern FILE *stderr;\t// 2 类型为 FILE 的流是对文件描述符和流缓冲区的抽象。\n流缓冲区的目的和 RIO 读缓冲区的一样：就是让开销高的 Linux I/O 系统调用的数量尽可能小。\nI/O 函数综合 以下为使用规则：\n只要有可能就尽量用标准 I/O。 不要用 scanf 或 rio_readlineb 来读二进制文件。 对网络套接字的 I/O 使用 RIO 函数。 ","date":"2024-06-06T10:53:23+08:00","image":"https://yikuanzz.github.io/2024/%E7%B3%BB%E7%BB%9F%E7%BA%A7io/cover_hub73ae7b0ed1c4909ac831706abf2ed8e_880514_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E7%B3%BB%E7%BB%9F%E7%BA%A7io/","title":"系统级IO"},{"content":"Go 基础 Go 语言是谷歌 2009 年首次推出并在 2012 年正式发布的一种全新的编程语言，可以在不损失应用程序性能的情况下降低代码的复杂性。\n下面是 Go 的 “Hello world”程序：\npackage main import \u0026#34;fmt\u0026#34; func main(){ fmt.Println(\u0026#34;Hello Go!\u0026#34;) } 题外话：\nFoo 是一个编程中经常使用的占位符，它没有特定的含义。\u0026ldquo;foo\u0026rdquo; 这个词的确有很多不同的起源说法。以下是一些可能的来源：\n\u0026ldquo;Foo\u0026rdquo; 来自于 \u0026ldquo;FUBAR\u0026rdquo;，这个说法已经在前面提到过了。FUBAR 是 \u0026ldquo;Fucked Up Beyond All Recognition\u0026rdquo; 的缩写，意为 \u0026ldquo;完全搞砸了\u0026rdquo;。\u0026ldquo;Foo\u0026rdquo; 可能是在这个词的基础上发展而来的。\n\u0026ldquo;Foo\u0026rdquo; 作为占位符的使用可以追溯到 1965 年，当时计算机科学家 Melvin Conway 在一篇论文中使用了 \u0026ldquo;foo\u0026rdquo; 和 \u0026ldquo;bar\u0026rdquo; 作为变量名。他认为这些词听起来有趣，可以使代码更易于阅读。\n\u0026ldquo;Foo\u0026rdquo; 来自于纽约的一个餐厅，当时计算机科学家们在那里举行了一个会议。他们使用 \u0026ldquo;foo\u0026rdquo; 来代表那个餐厅的名字，后来这个词就成为了占位符的代名词。\nGo 在 Linux 操作系统中，我们安装 Go 之后可以使用命令管理工具来对 Go 进行管理。\n[root@yikuanzz ~]# go -help Go is a tool for managing Go source code. Usage: go \u0026lt;command\u0026gt; [arguments] The commands are: bug start a bug report build compile packages and dependencies clean remove object files and cached files doc show documentation for package or symbol env print Go environment information fix update packages to use new APIs fmt gofmt (reformat) package sources generate generate Go files by processing source get add dependencies to current module and install them install compile and install packages and dependencies list list packages or modules mod module maintenance work workspace maintenance run compile and run Go program test test packages tool run specified go tool version print Go version vet report likely mistakes in packages Use \u0026#34;go help \u0026lt;command\u0026gt;\u0026#34; for more information about a command. Additional help topics: buildconstraint build constraints buildmode build modes c calling between Go and C cache build and test caching environment environment variables filetype file types go.mod the go.mod file gopath GOPATH environment variable gopath-get legacy GOPATH go get goproxy module proxy protocol importpath import path syntax modules modules, module versions, and more module-get module-aware go get module-auth module authentication using go.sum packages package lists and patterns private configuration for downloading non-public code testflag testing flags testfunc testing functions vcs controlling version control with GOVCS Use \u0026#34;go help \u0026lt;topic\u0026gt;\u0026#34; for more information about that topic. 通过 build 命令，我们可以对 Go 程序进行编译；clean 命令则会删除编译生成的可执行文件；run 命令则是编译并且运行。\n除了上面这些常用的命令外，还有一些好用的命令也是值得介绍的：\ngo vet 可以辅助捕获常见的错误； go fmt 会将你的代码布局成和 Go 源码类似的风格； go doc 能阅读包的文档内容，也可以自己去写代码的文档。 包 所有 Go 语言程序会被组成很多组的文件。每一个组就叫做包，放在同个文件夹内。这样每个包的代码都可以作为很小的复用单元，被其他项目引用。\n比如，我们在程序开头声明的就是该程序文件所属的包 package main。\n创建一个 Go 工程主要步骤如下：\n1.新建工程文件目录 goproject。\nmkdir goproject 2.在工程文件中新建 src、pkg、bin 文件目录。\ncd goproject mkdir src pkg bin 3.在 GOPYAH 中添加工程路径。\ngo env GOATH=\u0026#34;/home/goproject\u0026#34; 4.在 src 文件目录下新建自己的包 example 文件目录。\ncd ./src mkdir example 5.在 src下编写主程序代码 goproject.go。\n6.在 example 文件内编写 example.go 和包测试文件 example_test.go。\n7.编译调试包。\ngo build example go test example go install example 8.编译主程序。\ngo build goproject.go 9.运行主程序。\n./goproject 其中，GOPATH 为工程根目录，bin 用来存放生成的可执行文件，pkg 用来生成 .a 文件，在 golang 中的 import name 实际上是去 GoPATH 中寻找 name.a 文件。\n在 Go 语言中，会将命名为 main 的包编译成为 二进制可执行程序。\n如果某个包名叫 main ，那么其中一定会有名为 main() 的函数。\n比如，我们在 $GOPAHT/src/hello 目录中创建 hello.go 并写入我们的“Hello world”程序，然后通过 go build 命令对该程序进行编译，它会产生一个 hello 的可执行程序。\n[root@yikuanzz hello]# ./hello Hello world! 导包 我们注意到程序中，有使用 import \u0026quot;fmt\u0026quot; 的语句。编译器会使用 Go 环境变量设置的路径，通过引入相对路径来去查找磁盘上的包。插个题外话，如果导入包却不适用包中的代码，则会报错。\n但是，我们的 $GOPATH 路径上并没有名为 fmt 的包，显然这是标准库中的包，那么这个查找顺序是怎么样的呢？\n举例，如果 Go 安装在 /usr/local/go 路径下，且 GOPATH=/home/myproject:/homemylibraries的话，那么我们去查找 net/http 包就会按照以下顺序去做：\n1、/usr/local/go/src/pkg/net/http；\n2、/home/myproject/src/net/http；\n3、/home/mylibraries/src/net/http。\n如果所有目录上都没找到要导入的包，那么我们对程序进行 run 或 build 的时候就会出错。后面，我们会介绍 go get 命令来进行处理。\n除了本地导入以外，我们也可以通过远程来导入包，比如 import \u0026quot;github.com/spf13/viper\u0026quot;。\n当我们的包路径包含 URL 时，Go 工具链就会使用 分布式版本控制系统（Distributed Version Control Systems，DVCS）来获取包，并且将包的源代码保存在 GOPATH 执行的路径里与 URL 匹配的目录里。\n这个过程通过 go get 命令完成，go get 将获取任意指定的 URL 的包。\n当我们用的包多起来的时候，就可能会有相同的包名，这时我们可以对包导入进行重命名，就像下面的代码这样：\npackage main import ( \u0026#34;fmt\u0026#34; myfmt \u0026#34;mylib/fmt\u0026#34; ) func main(){ fmt.Println(\u0026#34;Standard Library\u0026#34;) myfmt.Println(\u0026#34;mylib/fmt\u0026#34;) } 函数 init 每个包可以包含任意多个 init 函数，这些函数都会在程序执行开始的时候被调用。所有被编译器发现的 init 函数都会安排在 main 函数之前执行。\n比如，我们看一下 PostgreSQL 数据库驱动中的一段代码：\npackage postgres import \u0026#34;database/sql\u0026#34; func init(){ sql.Register(\u0026#34;postgres\u0026#34;, new(PostgresDriver)) } 如果程序导入了这个包，就会调用 init 函数，促使 PostgreSQL 的驱动最终注册到 Go 的 sql 包里，成为一个可用的驱动。\n为了要注册这个驱动，我们就要倒入这个包，但是呢，我们又不使用包内的代码，只是想要这 init 函数执行。\n那么，在导包的时候需要给包重新命名，要用到 _ 符号。这样一来，我们可以将驱动注册到 sql 包里面了：\npackage main import ( \u0026#34;database/sql\u0026#34; _ \u0026#34;dbdriver/postgres\u0026#34; ) func main(){ sql.Open(\u0026#34;postgres\u0026#34;, \u0026#34;mydb\u0026#34;) } 依赖管理 上面的内容，我们介绍了 Go 的依赖管理方法，就是通过 GOPATH 的方式来管理包和依赖，这样的方式存在很多弊端，也不利于项目的构建。\n因此，社区中出现了很多工具可供我们选择，比如 godep、vender、gb 等等。\n这里我们介绍一下 gb 工程的样式：\n/home/bill/devel/myproject ($PROJECT) |-- src | |-- cmd | | |-- myproject | | | |-- main.go | |-- examples | |-- model | |-- README.md |-- vendor |-- src |-- bitbucket.org | |-- ww | |-- goautoneg | |-- Makefile | |-- README.txt | |-- autoneg.go | |-- autoneg_test.go |-- github.com |-- beorn7 |-- perks |-- README.md |-- quantile |-- bench_test.go |-- example_test.go |-- exampledata.txt |-- stream.go gb 工程会区分开发人员的代码和开发人员需要依赖的代码。开发人员的代码放在 $PROJECT/src/ 中，第三方代码放在 $PROJECT/vendor/src中。\n接下来，我们做一个实例，尝试创建一个 gb 工程：\n1、首先我们先安装 gb 工具：（要将 $GOPATH/bin 加入到环境变量中 export PATH=$PATH:$GOPATH/bin ）\n[root@yikuanzz ~]# go get github.com/constabulary/gb/... 2、我们创建一个文件夹 demo-project 和目录下的 src/hello 文件夹：\n[root@yikuanzz ~]# mkdir /home/demo-project [root@yikuanzz ~]# mkdir -p /home/demo-project/src/hello [root@yikuanzz ~]# tree /home/demo-project/ /home/demo-project/ └── src └── hello 2 directories, 0 files 3、然后我们将写一个简单的 ”Hello world“ 程序到 hello.go 文件中：\n[root@yikuanzz ~]# tree /home/demo-project/ /home/demo-project/ └── src └── hello └── hello.go 2 directories, 1 file 4、进入到目录下，对项目进行编译和运行：\n[root@yikuanzz demo-project]# gb build all hello [root@yikuanzz demo-project]# bin/hello Hello gb [root@yikuanzz demo-project]# tree /home/demo-project/ ├── bin │ └── hello └── src └── hello └── hello.go Go 数据结构 数组 数组的最大一个特点就是占用的内存是连续分布的。\nCPU 能将正在使用的数据缓存更久； 容易计算索引，迭代元素。 // 声明一个包含 5 个 int 元素的数组 var array [5]int 数组初始化时，每个元素都为对应类型的零值。\n如果想要更加快速地创建数组，可以使用数组字面量。\n// 声明一个包含 5 个 int 元素的数组 并且 初始化每个元素 array := [5]int {10, 20, 30, 40 ,50} 当然，我们可以让 Go 根据元素的数量来确定数组长度。\n// 容量初始化值的数量决定 array := [...]int {10, 20, 30, 40, 50} 此外，我们也可以指定对应元素的初始化值。\n// 指定 索引2 和 索引3 的值 array := [5]int {2: 30, 3:40} 除了通过 [] 运算符来访问数组，我们还可以通过指针访问值。\n// 数组元素为 整型指针 arrary := [5]*int {0: new(int), 1:new(int)} // 给 索引0 和 索引1 赋值 *array[0] = 10 *array[1] = 20 在 Go 语言中，数组是一个值。所以，数组是可以用在赋值上的，这样就可以复制数组。\n// 声明一个包含 5 个字符串的数组 var array1 [5]string // 声明另一个包含 5 个字符串的数组 并且 初始化 array2 = [5]string {\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Pink\u0026#34;} // 把 array2 值复制给 array1 array1 = array2 此外，如果复制的是指针数组的话，则是将指针地址的值复制了一遍，它们都指向同一个内容。\n多维度数组也是数组中的一个重要内容，它可以很容易地管理具父子关系的数据或者与坐标相关联的数据。\n// 声明一个二维整型数组，维度为 4 和 2 var array [4][2]int // 数组字面量声明 array := [4][2]int {{10, 11}, {20, 21}, {30, 31}, {40, 41}} 在函数间传递数组是一个很大的开销，因为函数变量的传递都是以值的方式传递的，如果变量是数组的话，就意味着会将一整个完整的数组进行复制，这样显然不太好。\n因此，用指针来传递数组会是个好的选择。\npackage main import \u0026#34;fmt\u0026#34; func valueCopy(arr [5]int){ fmt.Printf(\u0026#34;[value]arr: %p \\n\u0026#34;, \u0026amp;arr) } func addrCopy(arr *[5]int){ fmt.Printf(\u0026#34;[address]arr: %p \\n\u0026#34;, arr) } func main(){ array := [5]int {4, 5, 6, 7, 8} fmt.Printf(\u0026#34;[base]arr: %p \\n\u0026#34;, \u0026amp;array) valueCopy(array) addrCopy(\u0026amp;array) } 输出结果：\n[root@yikuanzz ~]# go run hello [base]arr: 0xc00001e060 [value]arr: 0xc00001e090 [address]arr: 0xc00001e060 切片 切片是一种动态数组，可以按照需要增长大小和缩小。\n// 底层数组指针、切片长度、切片允许增长到的元素个数 ----- ----- ----- | ptr | len | cap | ----- ----- ----- 切片的创建和初始化：\n1、make 和 切片字面量。\n// 创建字符串切片，长度和容量都是 5 slice := make([]string, 5) // 创建整型切片，长度为 3 ，容量为 5 slice := make([]int, 3, 5) 我们还可以通过切片字面量来声明切片，但是要注意与数组的声明方式做区分。如果我们在 [] 运算符中指定了\n// 创建字符串切片 slice := []string {\u0026#34;Red\u0026#34;, \u0026#34;Blue\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Yellow\u0026#34;, \u0026#34;Pink\u0026#34;} // 创建字符串切片 slice := []string {99: \u0026#34;\u0026#34;} 2、nil 和 空切片。\nnil 切片是很常见的创建切片的方法，可以用于很多标准库和内置函数。\n// 创建 nil 整型切片 var slice []int // 使用 make 创建空切片 slice := make([]int, 0) // 使用切片字面量创建空的整型切片 slice := []int {} 切片的使用：\n1、赋值和切片\n// 创建整型切片并赋值 slice := []int{10, 20, 30, 40, 50} 切片之所以叫切片，就是创建一个新的切片就是把底层数组切出一部分。\n// 创建一个新切片 前闭后开 newSlice := slice[1:3] 我们仔细观察知道 slice 的切片容量是 5，而 newSlice 的切片容量是 4。为什么呢？\n还记得切片的三个元素么，除了长度和容量，还有指针。我们对切片再进行切片时，其实是将指针指向原数组的地址，那么之前作为开头的元素地址我们就不知道了。\n2、切片增长\n// 创建一个整型切片 slice := []int {10, 20, 30, 40, 50} // 创建一个新切片 newSlice := slice[1:3] // 使用原容量分配新元素 newSlice = append(newSlice, 60) 当我们使用 append 函数时，如果底层数组有额外容量，那么就修改对应位置上的数；如果底层数组没有可用容量时，append 函数会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值。\n函数 append 会智能地处理底层数组的容量增长。当切片容量小于 1000 个元素的时候，总是成倍地增加容量。一旦元素超过 1000，容量的增长因子会设为 1.25。当然，具体的增长算法可能会改变。\n3、创建切片时的 3 个索引\n// 创建字符串切片 source := []string {\u0026#34;Apple\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Plum\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Grape\u0026#34;} // 将第三个元素切片，并限制容量 slice := source[2:3:4] 第三个索引的含义是限制新建切片的最大容量。\n有一个比较好的用途是，如果切片最大容量为当前切片长度，那么在使用 append 函数时，就能够让其与原有的底层数组分离。\n// 创建字符串切片 source := []string {\u0026#34;Apple\u0026#34;, \u0026#34;Orange\u0026#34;, \u0026#34;Plum\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Grape\u0026#34;} // 将第三个元素切片，并限制容量 slice := source[2:3:3] // 向 slice 追加新字符串 slice = append(slice, \u0026#34;Kiwi\u0026#34;) 此外，append 函数使用 ... 运算符可以将一个切片的所有元素追加到另一个切片里。\n// 创建两个切片，并分别用两个整数进行初始化 s1 := []int {1, 2} s2 := []int {3, 4} // 将两个切片追加在一起，并显示结果 fmt.Printf(\u0026#34;%v \\n\u0026#34;, append(s1, s2...)) 4、迭代切片\nGo 语言中也有 range 可以配合 for 来迭代切片里的元素。\n// 创建一个整型切片 slice := []int {10, 20, 30, 40} // 循环迭代 for index, value := range slice{ fmt.Printf(\u0026#34;Index: %d Value: %d\\n\u0026#34;, index, value) } 当迭代切片时，range 会返回两个值，第一个是当前迭代到的索引位置，第二个值是该位置对应元素的一份副本。\n当然，我们也可以用传统的 for 循环搭配 len 函数 和 cap 函数来进行迭代。\n多维切片\n// 创建一个整型切片的切片 slice := [][]int {{10}, {100, 200}} 因为切片的结构简单，我们通过 append 去增加新的元素也不会有特别大的开销。\n// 为第一个切片追加值为 20 的元素 slice[0] = append(slice[0], 20) 函数间传递切片\n因为切片的尺寸很小，在函数间复制和传递切片的成本也很低。\n// 分配 100 万个整型值的切片 slice := make([]int, le6) // 将 slice 传递给函数 slice = foo(slice) // 函数 foo 接收一个整型切片，并返回这个切片 func foo(slice []int) []int{ ... return slice } 32位 和 64位 系统在 Windows 下基本数据类型的大小都是一样的。只有指针的大小不一样！32位指针大小为 4byte，而 64位 的指针大小为 8byte。\n这样我们知道，在 64 位计算机中传递切片，实际上的开销只有 24 个字节。并且，函数中的切片和函数外的切片都是指向同一个底层数组，所以如果在函数修改了切片中数据，那么外面的切片也会察觉到变化。\n映射 map 是一种无序的基于 key-value 的数据结构，Go 语言中的 map 是引用类型，必须初始化才能使用。\n映射功能强大的地方在于，能够基于键快速检索数据。\n映射是一个集合，所以它可以使用处理数组和切片刀方式迭代映射中的元素，但映射是无序的集合，意味着没办法预测键值对被返回的顺序。\n映射最主要的数据结构有两种：哈希查找表（Hash Table）、搜索树（Search Tree）。\n哈希表用到哈希函数计算 key 的哈希值，然后根据哈希值将 key 分配到不同的桶里面。随着映射存储的增加，哈希值分布就越均匀，访问键值的速度就越快，映射通过合理数量的桶来平衡键值对的分布。\n在 Go 语言中，我们给映射添加键值对时，首先会将根据哈希函数的计算值分别放在“同类”的桶里面，一个桶里面放 8 个 key，就是说桶里面共有 8 个位置，然后同个桶内的 key 会根据哈希值地高 8 位来决定在桶内的具体位置。\nhmap 就是 hashmap 的缩写，bmap 就是“桶”。我们看到 hmap 中的字段，B 是 buckets 数组的长度对数，这里为 5 则 buckets 的长度就是 2 的 5 次方，也就是 32 这么大。\n// 桶的数据结构 type bmap struct{ topbits\t[8]uint8 keys\t[8]keytype values\t[8]valuetype pad\tuintptr overflow\tuintptr } 每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 overflow 指针连接起来。\n创建和初始化：\n// 创建一个映射，键的类型是 string，值的类型是 int dict := make(map[string]int) // 创建一个映射，键和值的类型都是 string // 用两个键值对初始化映射 dict := map[string]string{\u0026#34;Red\u0026#34;: \u0026#34;#da1337\u0026#34;, \u0026#34;Orange\u0026#34;: \u0026#34;#e95a22\u0026#34;} 使用映射：\n// 创建空映射，用来存储颜色以及对应的十六进制代码 colors := map[string]String{} // 将 Red 的代码加入到映射 colors[\u0026#34;Red\u0026#34;] = \u0026#34;#da1337\u0026#34; 当然，我们可以通过声明一个未初始化的映射来创建一个值为 nil 的映射，要知道的是 nil 映射不能用用于存储键值对，否则会产生错误。\n// 通过声明创建一个 nil 映射 var colors map[string]string 如果我们想从映射中取值的话有两种方式：\n1、获得值的同时，得到一个标志来确定这个键是否存在。 2、只获得值，然后判断这个值是否为零值确定其是否存在。 // 方式1 value, exists := colors[\u0026#34;Blue\u0026#34;] if exists{ fmt.Println(value) } // 方式2 value := colors[\u0026#34;Blue\u0026#34;] if value !=\u0026#34;\u0026#34;{ fmt.Println(value) } 同切片一样，映射也能够通过 range 关键字来进行迭代。\n// 创建一个映射，存储颜色以及颜色对应的十六进制代码 colors := map[string]string{ \u0026#34;AliceBlue\u0026#34;: \u0026#34;#f0f8ff\u0026#34;, \u0026#34;Coral\u0026#34;: \u0026#34;#ff7F50\u0026#34;, \u0026#34;DarkGray\u0026#34;: \u0026#34;#a9a9a9\u0026#34;, \u0026#34;ForestGreen\u0026#34;: \u0026#34;#228b22\u0026#34;, } // 显示映射里的所有颜色 for key, value := range colors { fmt.Printf(\u0026#34;Key: %s Value: %s\\n\u0026#34;, key, value) } 如果我们想把一个键值对从映射里面删除，就要用内置的 delete 函数。\n// 删除键为 Coral 的键值对 delete(colors, \u0026#34;Coral\u0026#34;) // 显示映射里面的所有颜色 for key, value := range colors{ fmt.Printf(\u0026#34;Key: %s Value: %s \\n\u0026#34;, key, value) } 函数间传递映射：\n在函数间传递映射并不会重新再建立一个映射副本，它的特性与切片是一样的。就是说，如果在函数中对映射做了修改的话，所有对这个映射的引用都会察觉到这个修改。\nfunc main() { // 创建一个映射，存储颜色以及颜色对应的十六进制代码 colors := map[string]string{ \u0026#34;AliceBlue\u0026#34;: \u0026#34;#f0f8ff\u0026#34;, \u0026#34;Coral\u0026#34;: \u0026#34;#ff7F50\u0026#34;, \u0026#34;DarkGray\u0026#34;: \u0026#34;#a9a9a9\u0026#34;, \u0026#34;ForestGreen\u0026#34;: \u0026#34;#228b22\u0026#34;, } // 显示映射里的所有颜色 for key, value := range colors { fmt.Printf(\u0026#34;Key: %s Value: %s\\n\u0026#34;, key, value) } // 调用函数来移除指定的键 removeColor(colors, \u0026#34;Coral\u0026#34;) // 显示映射里的所有颜色 for key, value := range colors { fmt.Printf(\u0026#34;Key: %s Value: %s\\n\u0026#34;, key, value) } } // removeColor 将指定映射里的键删除 func removeColor(colors map[string]string, key string) { delete(colors, key) } Go 语言系统 Go 语言是一种静态类型的编程语言，编译器在编译时得知道程序里每个值的类型。\n这样，编译器可以确保程序合理地用值，可以减少潜在的内存异常，并使编译器有机会对代码进行性能优化。\n实际上值的类型给编译器提供了两部分信息:\n1、需要分配多少内存给这个值。 2、这段内存表示什么。 用户定义类型 Go 语言允许用户定义类型，其实就是用 struct 关键字来组合字段进行类型的声明。\n// 定义一个用户类型 type user struct{ name string email string ext int privileged bool } 用结构体类型声明变量，初始化时会对其中的字段进行零值初始化。\n// 声明 usr 类型的变量，且初始化为零值 var bill user // 声明 user 类型，并初始化所有字段 lisa := user{ name: \u0026#34;Lisa\u0026#34;, email: \u0026#34;lisa@email.com\u0026#34;, ext: 123, privileged: true, } // 声明 user 类型，并初始化所有字段 john := {\u0026#34;John\u0026#34;, \u0026#34;john@eamil.com\u0026#34;, 123, true} 方法 方法可以给用户定义的类型添加新的行为。\npackage main import \u0026#34;fmt\u0026#34; // user struct type user struct{ name string email string } // notify: print information of user func (u user) notify(){ fmt.Printf(\u0026#34;Sending User Email To %s\u0026lt;%s\u0026gt; \\n\u0026#34;, u.name, u.email) } // changeEmail: change email of user func (u *user) changeEmail(email string){ u.email = email } func main(){ bill := user{\u0026#34;Bill\u0026#34;, \u0026#34;bill@email.com\u0026#34;} bill.notify()\t// value lisa := \u0026amp;user{\u0026#34;Lisa\u0026#34;, \u0026#34;lisa@email.com\u0026#34;} lisa.notify()\t// pointer bill.changeEmail(\u0026#34;bill@newdomain.com\u0026#34;) bill.notify() lisa.changeEmail(\u0026#34;lisa@comcast.com\u0026#34;) lisa.notify() } 关键字 func 和函数名之间的参数被称为接受者，它将函数与接受者的类型绑定。\n[root@yikuanzz ~]# go run test Sending User Email To Bill\u0026lt;bill@email.com\u0026gt; Sending User Email To Lisa\u0026lt;lisa@email.com\u0026gt; Sending User Email To Bill\u0026lt;bill@newdomain.com\u0026gt; Sending User Email To Lisa\u0026lt;lisa@comcast.com\u0026gt; 这里补充一下，Go 语言里面有两种类型的接受者：值接收者 和 指针接收者。\n如果用值接收者，那么参数传递的时候会生成一个副本；如果指针接收者，那么参数传递的时候会操作原地址上的数据。\n虽然我们在 notify 方法有用指针来去调用，但是它仍是复制了副本，实际上是：(*lisa).notify() 的样子。\n类型的本质 1、内置类型。\n内置类型就是\n","date":"2024-06-05T18:01:12+08:00","image":"https://yikuanzz.github.io/2024/%E7%AE%80%E6%98%8E%E7%9A%84go%E5%AD%A6%E4%B9%A0/cover_hu6c64888fb7dba8ea3f9b3ae918b049b3_2340567_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E7%AE%80%E6%98%8E%E7%9A%84go%E5%AD%A6%E4%B9%A0/","title":"简明的GO学习"},{"content":"Daily English Section 1 请求别人帮忙：Could you do me a favor?\n朋友要帮忙：It means a lot to me.\n朋友对你非常感激：What are friends for？\n尽量帮上忙：I\u0026rsquo;ll see what I can do.\nA：Karen, could you do me a favour?\nK：What\u0026rsquo;s up？\nA：Here is the thing. I\u0026rsquo;ll be on a business trip for a week. I\u0026rsquo;m wondering if you can look after my cat.\nK：No problem. I\u0026rsquo;ll take care of it.\nA：Thanks a million!\nK：What are friends for?\nA：Really appreciate it. It means a lot to me.\nSection 2 身边人心情不好：What\u0026rsquo;s bugging you？\n事情困扰得受不了：I can\u0026rsquo;t take it anymore.\n消息难以接受：It\u0026rsquo;s just a lot to take in.\n安慰朋友：I\u0026rsquo;ve been there. / I\u0026rsquo;ve been down this road before.\n困扰放不下：Let it go.\nA：What\u0026rsquo;s bugging you? You seem upset.\nB：My ex-boyfriend got married.\nA：You still have feelings for him？\nB：Not really. I\u0026rsquo;m over him. It\u0026rsquo;s just he\u0026rsquo;s moved on so fast, and this is a lot to take in.\nA：Trust me. I\u0026rsquo;ve been down this road before. You\u0026rsquo;re gonna have to let it go.\nB：Easier said than done.\nA：I know. But it\u0026rsquo;s the right thing to do.\nSection 3 称赞某样东西：It\u0026rsquo;s awesome.\n听到好消息：I\u0026rsquo;m thrilled. / I\u0026rsquo;m on cloud nine.\n听到坏消息：She is devastated.\nA：You seem so thrilled.\nB：I got the offer from one top universtity.\nA：That\u0026rsquo;s awesome. What about Jack?\nB：He failed and now he is devastated.\nSection 4 生活中很忙：I\u0026rsquo;m so swamped.\n感觉很累：I\u0026rsquo;m wiped out. / I\u0026rsquo;m exhausted.\n问题很难：That\u0026rsquo;s a tough one.\n人不好相处：She is a total nightmare.\nA：You look exhausted. Everything is OK?\nB：My boss is a nightmare. He asked me to get all the work done in three days.\nA：No wonder you are so swamped these days. Maybe you can think about changing the job.\nB：That\u0026rsquo;s a tough decision to make.\nSection 5 不好的情绪：It\u0026rsquo;s awful. / I feel awful of it.\n东西过于昂贵：They are ripping us off. / We got ripped off.\n很生气：I\u0026rsquo;m pissed off. / I\u0026rsquo;m furious.\nA：How was the restaurant?\nB：Forget it. The food was awful. And the meall cost us $300.\nA：I think you got ripped off.\nB：And they charged us a lot for the service. I was furious that I wasn\u0026rsquo;t told about it.\nSection 6 去买东西：I\u0026rsquo;m going to make a coffee / grocery store run.\n需要朋友帮忙：I could use a cup of coffee.\n给你：Here you go.\n不用朋友帮忙带：No, thanks. I\u0026rsquo;m good.\nA：I\u0026rsquo;m going to make a coffee run. Do you want anything?\nB：I could really use a cup of coffee. Can you get me a large latte?\nA：Here you go.\nSection 7 催促他人：Can you make it quick?\n别催我：Don\u0026rsquo;t rush me.\n我没有催你：I\u0026rsquo;m not rushing you.\nA：Can you make it quick?\nB：Don\u0026rsquo;t rush me.\nSection 8 需要休息：I need to take a breather.\n吃点东西：Let\u0026rsquo;s grab a bite to eat.\n带上什么东西：Let me get my key.\n马上就来：I\u0026rsquo;ll be right with you.\n你慢一点：Take your time with that.\nA：I need to take a breather. Let\u0026rsquo;s grab a bite to eat.\nB：Sure, Let me get my keys. I\u0026rsquo;ll be right with you.\nA：Take your time.\nSection 9 理解：Are you with me? / No, I\u0026rsquo;m totally lost. Can you repeat what you said?\n失望：This really bums me out. / I\u0026rsquo;m bummed out.\n一言难尽： It\u0026rsquo;s complicated.\n放轻松：Take it easy.\nA：This break-up really bums me out.\nB：How come you two broke up? I thought he was the one for you.\nA：It\u0026rsquo;s complicated.\nB：Just take it easy. These things happen.\nSection 10 你能搞定吗：Can you handle that? / I can handle it. / I\u0026rsquo;ll give it a shot.\n可疑：It seems kinda fishy.\n蒙在鼓里：They have kept me in the dark. / I\u0026rsquo;m in the dark about this.\n你生气了吗：Are you cool with this?\n接受某个想法：I\u0026rsquo;m open to it.\nA：What he said sounds very fishy. He has kept me in the dark about the situation.\nB：Let me be honest with you.\nSection 11 朋友拜访，请进：Come on in.\n介意随意一些吗：Do you mind if I get comfortable?\n就当是自己家：Make yourself at home.\n随便吃：Help yourself to the fridge. / Help yourself to more pizza.\nA：Hey, come on in!\nB：Do you mind if I get comfortable?\nA：Of course not. Make youself at home and help yourself to some snacks.\nSection 12 你怎么去了这么久：What took you so long?\n说来话长：Long story.\n我堵车了：I got stuck in traffic.\nA：What took you so long?\nB：It\u0026rsquo;s a long story.\nA：Come on! Tell me.\nB：I was stuck in traffic for one hour.\nA：That\u0026rsquo;s so lame.\nSection 13 能载我一程吗：Can you give me a ride?\n在这放我下来：Could you drop me off here? / Can you drop me off at the library?\n我待会来接你：I\u0026rsquo;ll pick you up later.\nA：Hey, could you give me a ride to that restaurant?\nB：No problem. That\u0026rsquo;s on my way home.\nA：Just drop me off here. The restaurant is just across the street.\nA：Hey, Mark. Could you give me a rideto the ariport.\nB：Sure, I\u0026rsquo;ll pick you up in an hour.\nSection 14 你有空吗：You got a minute to talk about \u0026hellip;?\n稍等一下：Hang on a sec.\n看看是否如何：I just wanted to see if you were both ok.\nA：You got a minute?\nB：Hang on a sec. What\u0026rsquo;s up?\nA：I\u0026rsquo;m thinking of ordering pizza. I want to see if you\u0026rsquo;d like one.\nB：Sound good. I\u0026rsquo;m hungry.\nSection 15 怎么回事：What\u0026rsquo;s gotten into you?\n欺负、摆布某人：push sb. around\n别往心里去：Don\u0026rsquo;t take it personally.\n换位思考：Put yourself in sb\u0026rsquo;s shoes.\nA：What\u0026rsquo;s gotten into you?\nB：I got told off by the boss again. I won\u0026rsquo;t let him push me around.\nA：Well, don\u0026rsquo;t take it personally. I\u0026rsquo;m sure he was just having a bad day. Have you tried putting youself in his shoes? You\u0026rsquo;ll feel so much better.\nB：It\u0026rsquo;s worth a shot.\nSection 16 进展如何：How is \u0026hellip; coming along?\n还有进步空间：There\u0026rsquo;s still room for improvement.\n鼓励：Keep it up.\nA：How is your project coming along?\nB：I\u0026rsquo;m still working on it. And there\u0026rsquo;s still room for improvement. What about you?\nA：Well, I started learning French weeks ago. I think it\u0026rsquo;s coming along pretty well.\nSection 17 怎样：How was \u0026hellip; ? / How are you doing?\n和往常一样：Same old, same old.\n感兴趣：I\u0026rsquo;m getting into \u0026hellip;\n分享喜欢的事情：The best part is \u0026hellip;\n你一定要：You should definitely do \u0026hellip;\nA：Hi, how was your weekend?\nB：I went to see the latest movie. And it was awesome. You should definitely check it out! How was yours?\nA：I spent the whole weekend painting. I\u0026rsquo;m getting into art these days.\nB：Good for you. Life is frulfilling when you\u0026rsquo;re working on things you love doing.\nA：Toally，the best part though is painting calms me down.\nSection 18 影响了：\u0026hellip; get to me \u0026hellip;\n不想做某事：I\u0026rsquo;ve had enough of \u0026hellip;\n开门见山：cut to the chase\n受够某事：I wish I could\nA：How was work?\nB：Not so good, I\u0026rsquo;ve had enough of it!\nA：What happended?\nB：Well. I have to work long hours to get my work done. And the boss is mean!\nSection 19 开启一个话题：You know what?\n表示震惊：I didn\u0026rsquo;t see that coming.\n不得不说：I gotta say. I didn\u0026rsquo;t see that one coming.\n别告诉别人：Just between us. keep sth. just between us\n知道了(按对方的意思去做)：You got it.\nA：You know what? I heard that the company will lay off many people.\nB：No kidding. I didn\u0026rsquo;t see that one coming. Is it a sure thing?\nA：I got it on the grapevine. But I\u0026rsquo;d appreciate it if you kept this conversation just between us.\nB：You got it. I won\u0026rsquo;t say a word.\nSection 20 搞砸一些事情 / 错失机会：I blew it.\n某事进展如何：How did sth. go?\n安慰朋友：That\u0026rsquo;s the way it goes.\n坚持下去：You gotta hang in here. Everything is gonna be Okay.\n最好的安排：work out for the best.\nA：How did your interview go?\nB：It didn\u0026rsquo;t go well. I sort of blew it.\nA：Sorry to hear that.\nB：You know what? There\u0026rsquo;re 20 people competing for this position.\nA：That\u0026rsquo;s the way it goes. It\u0026rsquo;s a lot harder to land a decent job these days.\nB：What I gonna do? I don\u0026rsquo;t see a future.\nA：Come on. You gotta hang in there. Trust yourself.\nSection 21 想让你知道：Just so you know.\n我告诉你：For your in formation.\n引出自己的话：Actually, \u0026hellip;\n问题在于：The thing is \u0026hellip;\n喜欢某人：be into sb.\n更正自己刚说的话：I just saying \u0026hellip;\nA：I gotta say, this restaurant is not all it\u0026rsquo;s cracked up to be.\nB：Actually, I\u0026rsquo;m a regular here. I think the food is great. Just so you know, this restaurant is the most popular one in the area.\nA：I\u0026rsquo;m not saying the food is awful. I\u0026rsquo;m just saying I\u0026rsquo;m not impressed.\nSection 22 理清事情：Let me get this straight.\n换一种角度：Let me put it this way.\nA：I gotta tell you something. A woman got promoted at the firm\u0026rsquo;s headquarters. So they have a job opening. It\u0026rsquo;s like my dream job!\nB：Let me get this straight. You wanna take this job, which is in London.\nA：Look, I\u0026rsquo;m just saying I wanna give it a shot. It\u0026rsquo;s not like I\u0026rsquo;m going there tomorrow.\nB：The thing is London is so far away. Long distance relationship doesn\u0026rsquo;t work and you know it.\nSection 23 偶遇旧识：Long time no see.\n有什么新鲜事：What\u0026rsquo;s new?\n和往常一样：Same old same old.\n最近在忙什么：What have you been up to?\n我一直在做某事：I\u0026rsquo;ve been doing \u0026hellip;\n关心对方：Enough about me. What about you?\n替我向 \u0026hellip; 问好：Tell some one I said hi.\nA：Long time no see. What have you been up to?\nB：I\u0026rsquo;ve been traveling around the country. I\u0026rsquo; ve met interesting people. I\u0026rsquo;ve had wonderful food. Enough about me. What about you?\nA：I\u0026rsquo;ve taken up a part-time job. I have to work long hours to pay the mortgage.\nB：Take care of yourself.\nA：Tell your mon I said hi.\nB：I will.\nSection 24 尬聊：What are you up to this weekend?\n不确定计划：Keeping busy.\n没啥事：Not a lot. Just chill out.\n结束对话：I need to get some coffee.\n回头见：Catch you later.\nA：What are you up to this weekend?\nB：Keeping busy. What about you?\nA：Not a lot. Just chill out. Oh, I wish I could lie down all day.\nB：I need to get some coffee.\nSection 25 开启对话：I love your pants. Where did you get them?\n礼貌对话：If you don\u0026rsquo;t mind me asking.\n有空会去：I should pop into their store some day.\nA：I love your jacket. Where did you get it?\nB：I bought it at Bloomingdale\u0026rsquo;s.\nA：The quality is the best.\nB：How much is it? If you don\u0026rsquo;t mind me asking.\nA：It\u0026rsquo;s $300. They have a whole bunch of jackets in different sizes.\nB：Wow. I should pop into the store some day.\nSection 26 天气多变：It\u0026rsquo;s really coming down out there!\n讽刺天气：Lovely day, isn\u0026rsquo;t it?\n天气要是好一点就好了：It\u0026rsquo;d be nice if we could get more sunshine.\nSection 27 当我们有一个提议：How does that sound?\n一起去做某事怎么样：How does that sound \u0026hellip;\n算了：Never mind.\n我不介意：I don\u0026rsquo;t mind.\nA：How does that sound if we eat out in that fancy restaurant?\nB：Sound great. Let me check it out. The seats are all booked. We need to wait for an hour to get in.\nA：Never mind. Let\u0026rsquo;s eat somewhere else.\nB：Would you like burgers or sandwiches?\nA：I don\u0026rsquo;t mind. Either is fine.\nSection 28 事情进展很顺利：work out \u0026hellip; / it didn\u0026rsquo;t work out\n感谢：Thanks so much. / I really appreciate it.\n我欠你一个人情：I owe you one.\nA：Thanks so much. I really appreciate you helping me.\nB：You\u0026rsquo;re welcome. I\u0026rsquo;m glad to hear that everything worked out.\nA：Seriously. I owe you one. If there\u0026rsquo;s sth I can do for ya, just let me know.\nSection 29 发泄：I need to vent. -\u0026gt; You can always vent to me.\n我什么都没错：I\u0026rsquo;ve done nothing wrong.\nXX没有任何问题：There\u0026rsquo;s nothing wrong with XX.\n不可能：There\u0026rsquo;s no way.\nA：I need to vent.\nB：I\u0026rsquo;m your best friend. You can always vent to me.\nA：I was wiped out at work. My boss caught me napping. And I got told off.\nB：You did nothing wrong. There\u0026rsquo;s nothing wrong with taking a nap during work.\nA：Did you explain the reasons to her?\nB：There\u0026rsquo;s no way she\u0026rsquo;ll understand me.\nSection 30 近来如何：How is it going with sb. / sth. ? How did it go?\n争取一下：Go for it!\nA：Hey, how is it going?\nB：It\u0026rsquo;s good. You talked about changing your job. How did it go?\nA：I have an interview next week.\nB：Go for it!\nSection 31 我是说：I mean \u0026hellip;\n我是认真的：I mean it!\n我不是故意的：I didn\u0026rsquo;t mean it. / I didn\u0026rsquo;t meant to.\nA：I don\u0026rsquo;t think you should go out with him.\nB：What did you mean by that?\nA：I mean, he is charmer but not the keeper.\nB：Seriously? Why do I keep falling for guys like that?\nA：Look, I didn\u0026rsquo;t mean to upset you. But you deserve so much better. I mean it.\nSection 32 有什么氛围：have got a XXX vibe\n感觉到这种氛围：It\u0026rsquo;s just this vibe I got.\n两个人很来电：have a vibe / give sb. the vibe\nA：Hey, tell me about the guy you met.\nB：I met him at the gym. He was definitely giving me the vibe.\nA：Wow, good for you.\nSection 33 邀约：What do you say we do sth.\n我超想做什么：I am dying to \u0026hellip; / I have been dying to \u0026hellip;\n让我带上：Let me get \u0026hellip; / Let me get you sth.\nA：What do you say we go for a walk nearby?\nB：Sound great. I am dying to get some fresh air.\nC：It\u0026rsquo;s a bit chilly. Let me get my jacket.\nSection 34 随意地问：What are you up to tonight? / What have you been up to?\n要做某事：I have \u0026hellip; coming up / I\u0026rsquo;ve got \u0026hellip; coming up / Do you have any projects coming up?\n我觉得我最好还是：I figure I\u0026rsquo;d better do \u0026hellip;\n如果你不想：If you don\u0026rsquo;t feel like doing \u0026hellip;\nA：What are you up to tonight?\nB：I\u0026rsquo;ve got finals coming up. I figure I\u0026rsquo;d better work on my lessons.\nA：OK. I was going to ask you to go shoping with me. I need your advice.\nB：If you don\u0026rsquo;t feel like being alone, we can do some shopping nearby.\nSection 35 听说：Did you hear about + sth. / sb.\n具体怎么样：What about + sth. / sb.\n怎么回事：How come + \u0026hellip;\n事情是这样的：Here is the deal \u0026hellip;\n我不得不说：I have to say, + \u0026hellip;\nA：What about her?\nB：She broke up with her boyfriend.\nA：How come they broke up?\nOther Itmes get in life get up 起床：I get up late today.\nget + adj. 表状态：I get dressed.\nget sth. for sb. 拿某物给某人：Can you get a towel for me?\nget going 出发：I should get going.\nget sth. 买某物：I will get a burger for my breakfast.\nget on 上车：I got on the bus.\nget round to (doing) sth. 抽时间做某事：I finally get round to reading a book.\nget off 下班：I get off work.\nget lunch / dinner 做饭：I\u0026rsquo;ll get the dinner.\nget out of sth. 戒除\u0026hellip;习惯：I really need to get out of the habit of procrastination. / get out of bed\nget behind with sth. 拖欠工作：I found I\u0026rsquo;ve gotten behind with a lot of work. / get behind with payment.\nget sb. nowhere 没有进展：Checking my phone gets me nowhere.\nget sth. done 完成某事：I didn\u0026rsquo;t get my work done. / get my hair cut\nget it 我不理解：I don\u0026rsquo;t get it. / I get it. / Got it?\nget to sb. 表示让某人烦恼：His words really get to me.\nget along with sb. 表示与某人相处：I get along well with some coworkers. / don\u0026rsquo;t get along\nget together 聚在一起：We often get together for a drink.\nA：Do you have something to get off your chest?\nB：It\u0026rsquo;s the boss. His words really get to me.\nA：Don\u0026rsquo;t take it personally. You\u0026rsquo;ll get used to him. You\u0026rsquo;ll never get him to understand you. You\u0026rsquo;ll feel bad. But you\u0026rsquo;ll get over it.\n","date":"2024-06-02T00:44:02+08:00","image":"https://yikuanzz.github.io/2024/zaharaenglish/cover_hu275f9b2d4ca6c7e163b0e35527362951_1628123_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/zaharaenglish/","title":"ZaharaEnglish"},{"content":"prescribe recreational integrity count suburban problematic splendid deception retort capability strain protect call cleanse carry showy off bilateral separate frank tragedy resolute deceive inquire justice frontier quantity insist affectionate evoke proclaim indigence want substitute endure stammer refer obligatory casual shelter inform ejection emphasis civilian jury innovate contend capability weapon fraction estimate applicable supposition colonial external transport clash inducement extent go up look supervise gloomy emerge laborious pasture completion prospect prefer ordinary amid preservation descend conserve rapid diverse ","date":"2024-05-29T22:23:06+08:00","image":"https://yikuanzz.github.io/2024/%E8%8B%B1%E8%AF%AD%E8%A7%92/cover_hu6e9c681962a00dcad11f3dafdf2579d8_869951_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E8%8B%B1%E8%AF%AD%E8%A7%92/","title":"英语角"},{"content":"概述 OSI 参考模型 网络通信是一个庞大的工程，其中网络协议就采用分层设计的思想。国际化标准组织提出了 开放式系统互联模型（open system interconnection model），简称 OSI 模型。\n物理层（physical layer），负责管理通信设备和通信媒介，对设备的针脚、电压、线缆等做了详尽的定义。物理层为我们屏蔽了物理设备的底层细节，为上层提供信息比特传输能力。至于它对于线缆、电压等的规定，软件研发人员一般不需要关注。\n数据链路层（data link layer）以 帧（frame）为传输单元，负责网络寻址、错误侦测，可以解决同一网络内多台主机的通信问题，最终实现局域网通信。\n网络层（network layer）以 数据包（packet）为传输单元，负责路径选择和数据包转发。网络层建立在数据链路层的基础上，它实现了全网通信能力，可以将数据传送到网络中任一的节点。数据链路层只实现了局域网内的通信能力，为网络层提供服务，将包送至下一节点。两者分工明确，彼此协作。\n传输层（transport layer）在网络层基础上，为应用进程提供端到端的通信服务，支持面向连接的数据流、流量控制以及可靠性保障。一个节点上通常有许多应用进程，为此传输层引入了端口的概念，实现了从进程到进程的传输能力。在 段（segment）中包含端口信息，网络转发后目标节点在包中取出段，再根据端口号送至目标进程。\n应用层（application layer）负责应用的通信逻辑，并提供多样的网络应用服务。\n会话层（session layer）为通信实体实现会话和连接管理功能，主要提供 用户认证、权限控制 等服务。 表示层（presentation layer）为不同终端的用户提供一致的数据表示和变换方法，比如 数据的编解码、数据的加密压缩、数据的压缩解压 等等。 TCP/IP 协议栈 网络访问层（network access layer）负责管理物理介质，并提供将数据从当前节点传输到下一节点的能力，相当于 物理层 + 数据链路层。\n不同的通信介质，有不同的接入设备，采用的协议也不同：Ethernet，以太网协议；PPP，点对点协议；DSL，用户数字线路 等等。 网络互连层（internet layer）在网络访问层提供的局域网通信能力之上，实现网际通信能力，负责路径选择和数据包转发，相当于 网络层。\nIP 协议在该层以 IP 包为通信单元，通过该协议通信的主机需要分配一个 IP 地址，包中用 IP 地址来标识包的来源和目的地。 传输层（transport layer）在网络互连层点到点传输能力基础上，实现端到端的进程间通信。\nUDP 协议引入了一个端口号，当 UDP 段搭载在 IP 包中送给主机后，系统根据段中的数据提交给对应的进程。 TCP 协议相对 UDP协议 来说，它为进程提供可靠、有序的数据流。 应用层（application layer）定义具体网络应用的通信逻辑，让应用进程间的写作成为可能。\n网络应用协议常见的有：HTTP、HTTPS、FTP、SMTP 等等。 Ethernet：以太网协议 物理层+数据链路层 物理层的任务主要是确定与传输媒体接口的一些特性：\n（1）机械特性：指明接口接线器的形状和尺寸、引脚数目和排列、固定和锁定壮志等。 （2）电气特性：指明接口电缆的各线上出现的电压的范围。 （3）功能特性：指明某条线上出现的某一电平的电压的意义。 （4）过程特性：指明对于不同功能的各种可能事件的出现顺序。 对于数据链路，我们先知道链路是指一段物理线路，中间没有任何交换节点；数据链路则是说，我们在这条物理线路上还需要一些通信协议来控制数据的传输。\n一般通过网络适配器来实现这些协议，它通常包括了数据链路和物理层的功能。\n以太网帧结构 在以太网中，数据通信达基本单位是 以太网帧（frame），由 头部（header）、数据（data）以及 校验和（checksum）三部分构成。\n以太网帧头部包含 3 个字段：\n目的地址，长度为 6 个字节，用于标记数据由哪台机器接收。 源地址，长度为 6 个字节，用于标记数据由哪台机器发送。 类型，长度为 2 字节，用于标记数据如何处理，0x0800 表示该帧数据是一个 IP 包。 以太网数据是任何需要发送的信息，长度可变，46 至 1500 字节均可。\n以太网校验和，长度为 4 个字节。因为物理信号可能受到环境干扰，网络设备传输的比特流会出错，为了保证传输以太网帧的时候是完好无损的，我们就要用到校验和。\n发送者负责为每个以太网帧计算校验和，并计算结果填写在校验和字段中；接收者接收到以太网帧后，重新计算校验和并与校验和字段对比；如果两个校验和不一致，说明该帧在传输时出错了。 MAC 地址 MAC（Media Access Control Address）地址也是以太网地址，也叫硬件地址、物理地址、网卡地址。\n物理层上，网卡负责比特流和电信号之间相互转换。 软件层上，内核协议栈负责封装以太网帧，并调用网卡驱动发送；接收数据时，负责验证 目的地址、校验和 并取出数据部分交予上层协议栈处理。 MAC 地址由 6 个字节（48位）组成。\n3 字节长的 厂商代码（OUI），由国际组织分配给不同的网络设备商。 3 字节长的 序列号（SN），由厂商分配给它生产的网络设备。 MAC 地址很难直接用 ASCII 码来解读，所以我们将一个 8 位 字节的字符，分成 高 4 位 和 低 4 位，并且每个部分用 16 进制的字符来表示。\n在 Linux 系统中，我们用 ip link 命令来查看网卡。\n[root@iZ7xvfomazz4187zib4aurZ ~]# ip link 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:16:3e:03:2c:8d brd ff:ff:ff:ff:ff:ff 3: docker0: \u0026lt;NO-CARRIER,BROADCAST,MULTICAST,UP\u0026gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default link/ether 02:42:61:8f:61:b8 brd ff:ff:ff:ff:ff:ff 我们也可以通过套接字编程直接向系统获取，Linux 套接字支持通过 ioctl 系统调用获取网络设备，大致步骤如下：（补充内容请看附录）\n​\t1、创建套接字。\n​\t2、准备 ifreq 结构体，保存网卡设备信息。\n​\t3、将查询网卡名填充到 ifreq。\n​\t4、调用 ioctl 系统，向套接字发送 SIOCGIFHWADDR请求获取物理地址。\n# include \u0026lt;net/if.h\u0026gt; # include \u0026lt;stdio.h\u0026gt; # include \u0026lt;string.h\u0026gt; # include \u0026lt;sys/ioctl.h\u0026gt; # include \u0026lt;sys/socket.h\u0026gt; void mac_ntoa(unsigned char *n, char *a){ // 格式化数据，并写入字符串 a sprintf(a, \u0026#34;%02x:%02x:%02x:%02x:%02x:%02x\u0026#34;, n[0], n[1], n[2], n[3], n[4], n[5]); } int main(int argc, char *argv[]){ if (argc \u0026lt; 2){ fprintf(stderr, \u0026#34;no iface given\\n\u0026#34;); return 1; } // 创建套接字 int s = socket(AF_INET, SOCK_STREAM, 0); if (-1 == s){ perror(\u0026#34;Fail to create socket\u0026#34;); return 2; } // 填充字符串名字 struct ifreq ifr; strncpy(ifr.ifr_name, argv[1], 15); // 调用 ioctl 驱动获得地址 int ret = ioctl(s, SIOCGIFHWADDR, \u0026amp;ifr); if (-1 == ret){ perror(\u0026#34;Fail to get mac address\u0026#34;); return 3; } // 转换为可读形式 char mac[18]; mac_ntoa((unsigned char *)ifr.ifr_hwaddr.sa_data, mac); // 输出结果 printf(\u0026#34;IFace: %s\\n\u0026#34;, ifr.ifr_name); printf(\u0026#34;MAC: %s\\n\u0026#34;, mac); return 0; } MTU 最大传输单元 如果待发送的数据超过帧的最大承载能力，就需要先对数据进行分片，然后再通过若干个帧进行传输。\n待发送的数据总共 4000 字节，假设以太网设备一帧最多只能承载 1500 字节。很明显，数据需要划分成 3 片，再通过 3 个帧进行发送。\n编程发送以太网帧 实现 sendether 命令，用于发送以太网帧，它的用法是：\n-i -iface：用于发送以太网帧的网卡名。 -t -to：目的 MAC 地址。 -T -type：以太类型。 -d -data：待发送数据。 send_ether -i enp0s8 -t 0a:00:27:00:00:00 -T 0x1024 -d \u0026#34;Hello, world!\u0026#34; 使用 enp0s8 网卡，向 0a:00:27:00:00:00 发送一个类型为 0x1024 的以太网帧。\nIP：互联网协议 网络层 在数据链路层中，我们能够实现同一网络内多台主机之间的通信问题，网络适配器将数据封装为以太网帧然后发送给其他主机。\n为了能够实现更大规模的网络互联，我们在数据链路层的基础上添加了网络层。\n网络层做了什么呢？\n它给参与网络层通信的主机都分配一个唯一地址，并且这些地址是按照网络拓扑结构进行分配的，保证一个组织内部的地址是连续的。\n然后，它将多个不同的以太网用转发设备进行互联，这个转发设备维护路由表，规定了目的地址和下一条都对应关系。\nIP 包结构 IP 是 互联网协议 ( internet protocol ) 的简称，是 TCP/IP 协议栈中的网络层协议。IP 协议在发展的过程中，衍生出 IPv4 和 IPv6 两个不同版本。其中，历史版本 IPv4 目前仍广泛使用；后继版本 IPv6 世界各地正在积极部署。\nIP 地址详解 主机号比特全为 0 ，是网络的起始地址，用于表示网络本身，一般称为 网络地址 ； 主机号比特全为 1 ，是网络的结束地址，用于向网络内的所有主机进行广播，一般称为 广播地址 ； 子网掩码 我们可以通过子网长度来划定子网个数，一般使用掩码来记录 IP 地址中的网络号部分。\n掩码位数与 IP 地址一样，1 表示该位属于网络号，0 表示该位属于主机号。如果你学过 C 语言，应该知道通过按位与操作 \u0026amp; ，掩码可以快速取出一个 IP 地址的网络号。\n这就是所谓的 子网掩码 ，它也可以用 点分十进制表示法 来表示，用来描述 IP 地址的网络号部分。因此，子网 10.0.0.x 可以表示成 10.0.0.0/255.255.255.0 ；A 类网络 10.x.x.x可以表示成 10.0.0.0/255.0.0.0 。\n实际上，描述网络号还有更简洁的方法：在 IP 地址后面加上斜杆和网络号的位数。例如：\n10.0.0.0/255.255.255.0 可以表示成 10.0.0.0/24 ； 10.0.0.0/255.0.0.0 可以表示成 10.0.0.0/8 ； TTL，IP 包存活时间 环 （ cycle ），一种首尾相连的特殊路径，是图论中重点研究的对象。如果 IP 包陷入环路的包无法清理，最终将耗尽线路的带宽和路由器的处理资源，影响正常数据的传输，造成大量丢包。\nIP 包中的 TTL 字段是 Time To Live 的缩写，表示 IP 包的存活时间，如果 IP 包存活时间超过 TTL，路由就会将它丢弃。这样就算 IP 包陷入循环，经过一小段时间，它也会从网络中消失，不会造成更大的影响。\n但因为网络路由器数量巨大，很难做到时间同步，因此，在实际工程实现中，TTL 并不是直接保存存活时间，而是保存 IP 包失效前可以经过的路由跳数。IP 包每经过一跳路由，TTL 都会减一；当 TTL 减到 0 ，路由便将它丢弃。\n[root@yikuanzz ~]# cat /proc/sys/net/ipv4/ip_default_ttl 64 网络规划 假设，公司现在要给每个部分组建一个局域网，每个局域网通过一台路由器接到核心路由网络。\n我们还注意到，不同的部门，主机数量也有多有少：\n部门 主机数量 行政部 50 研发部 100 市场部 80 人力部 50 法务部 50 因此，每个部门局域网所需要的网段，大小也是不一样的。假设管理员拿到了一个地址段 192.168.170.0/23 ，如何将地址划分给图中的子网呢？\n按照上述划分，我们就可以将各个部门的子网都分配好了。\nARP：地址解析协议 ARP 协议原理 我们知道，可以通过 IP 地址来指定数据包发送的目标地址，但是在数据链路层封装为帧的时候，怎么知道目标 IP 的 MAC 地址呢？\n最直觉的方法就是让主机发送广播，询问网络中的其他主机来去得到目标 IP 的 MAC 地址。\nff:ff:ff:ff:ff:ff 是一个特殊的广播地址，目的地址为 ff:ff:ff:ff:ff:ff 的以太网帧，将被送到以太网中的每一台主机。交换机收到目的地址为 ff:ff:ff:ff:ff:ff 的帧后，也会将它广播到所有端口。\n当主机收到目标 IP 发给自己的 MAC 地之后将其放在映射表中，后面传输的时候就可以直接从缓存中查询了。当然，为了保证时效性，ARP 缓存是要设置有效期到，如果缓存失效了，系统就必须重新发起 ARP 查询并且缓存最新结果。\n那么，ARP 协议就是对这个过程进行统一的规范，并且 ARP 报文是内嵌在以太网帧之中的。\n一个 ARP 报文中有 9 个字段，分别是：\n硬件类型（ hardware type ），数据链路层协议类型，例如： 1 表示以太网协议； 协议类型（ protocol type ），网络层协议类型，例如 0x0800 表示 IP 协议； 硬件地址长度（ hardware address length ），数据链路层地址长度，对以太网来说，地址长度为 6 字节； 协议地址长度（ protocol addess length ），网络层地址长度，对 IP 协议来说，地址长度为 4 字节； 操作码（ operation ），报文的操作类型，1 表示 请求 （ request ），2 表示 应答 （ reply ）； 源硬件地址（sender hardware address），即发送者的数据链路层地址； 对于 ARP 请求，该字段表示请求发起者的地址； 对于 ARP 应答，该字段表示请求应答者的地址，也就是发起者查找的地址； 源协议地址（ sender protocol address ），即发送者的网络层地址； 目标硬件地址（target hardware address），即接收者的数据链路层地址； 对于 ARP 请求，这个字段被忽略； 对于 ARP 应答，这个字段表示请求发起者的地址； 目标协议地址（ target protocol address），即接收者的网络层地址； 对于 ARP 请求，这个字段就是待查找地址； 对于 ARP 应答，这个字段表示请求发起者的地址； 拓展阅读：RFC828\nARP 攻击 因为 ARP 协议没有真伪校验机制，如果黑客进入到主机所在的网络，他就可以轻易地监听主机发送的网络信息。\n在 ARP 广播的时候，黑客不断地发送伪造的 ARP 回应给主机， 当然黑客为了保持隐蔽，它还是会将包转发给网关。这样，主机以为自己将包发送给了网关，而网关也误以为自己收到了主机发送的数据。\n那么，怎么防止 ARP 攻击呢？\n双绑措施\n在路由和终端上同时进行 IP 地址和 MAC 地址的绑定，相当于人工管理 ARP 缓存，自行维护 IP 地址和 MAC 地址的对应关系。既然将 ARP 协议弃之不用，黑客就无法发起攻击了。\n这个方案虽然可以奏效，但维护非常繁琐。换个网卡或 IP 地址，都需要重新修改配置。当流动电脑临时接入时，也要即时进行绑定，费时费力。\n交换机端口绑定\n跟双绑措施类似，只不过将 IP 和交换机端口进行绑定，缺点也是类似的。\nPPPoE\n使用 PPPoE 协议对网络流量进行二次封装，为每个用户都分配账号密码，上网时必须通过认证。这样 ARP 报文在一个认证的通道中传输，也就不会遭受攻击了。\n但 PPPoE 也不是完美的，由于二次封装的存在，传输效率会打些折扣。更严重的是，PPPoE 方式下局域网内无法互访。如果局域网内需要部署文件服务器、打印机，就有麻烦了。\n其实最关键的一点在于，坚持使用 HTTPS 这样的加密协议。这样就算遭遇 ARP 劫持，信息也不会被窃取。在陌生的网络环境中，应该尽量不用 HTTP 这样的明文协议。\nICMP：互联网控制报文协议 ICMP 协议概述 互联网控制消息协议 ( Internet Control Message Protocol )简称 ICMP ，是 IP 的辅助协议，同样位于网络层，负责网际通信中 控制信息 和 差错信息 的传送。\nICMP 有赖 IP 提供的网际通信能力，它的报文作为数据承载在 IP 包中进行传输。\nICMP 报文同样分为 头部 和 数据 两部分，其中头部字段如下：\n类型 （ type ），顾名思义用来标识 ICMP 报文的类型，例如 目的不可达 （ destination unreachable ）差错报文； 代码 （ code ），进一步划分 ICMP 报文的类型，标识错误的原因，例如目的不可达可以进一步分成网络不可达、主机不可达以及端口不可达等等； 校验和 （ checksum ），用于差错校验，由 ICMP 头部计算得出； 拓展阅读：RFC 792\nUDP：用户数据报协议 传输层概述 在网络层中，我们实现点对点之间的数据传输，就是将数据封装为 IP 包，在包头指定目标主机的 IP 地址，然后在数据链路层封装为以太网帧，发送给路由器，再由路由器进行分发。\n当然，一台主机上不可能指挥允许一个进程，点到点之间的数据传输并不能满足我们的需求，也就是说，我们需要进程与进程之间的传输。\n于是在上述基础上，我们添加了传输层，引入了端口（port）的概念，用来区分不同的通信端点。\n一台主机上可以有很多个通信端口，应用进程可以关联到一个或多个端口。当进程需要发送数据时，它必须申请一个端口，数据从该端口发送出去；当某个端口有数据到达时，操作系统负责将数据提交给对应的应用进程。\n这种从进程到进程的传输能力，可以叫做端到端的传输。\n我们有一些知名的端口号：\n服务 端口 FTP文件传输 20 、 21 SSH安全远程登录 22 SMTP邮件传输 25 DNS域名系统 53 Web 80 、 443 UDP 数据报格式 UDP 是 用户数据包协议 （ user datagram protocol ）的简称，它是一种简单的数据报式传输层协议。UDP 数据报结构非常简单，头部只包含端口号等若干个字段。\n由于 UDP 位于传输层，因而报文有时也称为 UDP 段或 UDP 分组。UDP 报文也分为头部和数据两个部分，结构跟我们在上节讨论的传输层段几乎一模一样。其中，头部只有 4 个字段：\n源端口（ source port ），发送方的端口号； 目的端口（ destination port ），接收方的端口号； 报文长度（ length ），即整个 UDP 报文的长度，包括头部和数据，单位为 字节 。 检验和（ checksum ），与 IP 校验不同，UDP 整个报文都会参与校验和计算，除此之外，UDP 还会在报文前面拼接一个 IP 伪头部，同时参与校验和计算； UDP 报文需要借助 IP 协议提供的主机通信能力，作为数据搭载在 IP 包中发往目标主机。\n拓展阅读：RFC 768\nTCP：传输控制协议 TCP 协议简介 UDP 数据报是借助 IP 包提供的点对点传输能力来实现的端到端的传输，然而 IP 协议只是一种“尽力而为”的网络协议，它无法保证 IP 包一定能够送到目标主机。实际上，由于网路链路拥堵或者中间路由设备故障点存在，会有 IP 丢包的现象出现。此外，UDP 协议也没有流量控制机制、也没有拥塞控制机制，当遇到某些情况时是无法解决的。\n为了解决 UDP 协议的局限性，一种更高级的传输协议被设计出来了 TCP（Transimission Control Protocol）它是一种 面向连接的流式协议 ，可为应用程序提供 可靠的字节流传输服务 。\n连接主动发起方（一般是客户端），向被动连接方（一般是服务端）发出 SYN ； 被动连接方收到 SYN 后，向主动发起方回复 SYN+ACK ； 主动发起方收到 SYN 后，向被动连接方回复 ACK ； 其中，SYN 指令表示序号同步请求，ACK 表示确认，即对同步请求进行确认。\nTCP 将数据组织成连续的字节流，每个字节均可由一个唯一的序号来标识。\nTCP 在发送数据时，会将数据的 起始序号 和 长度 告诉对端，接收方收到数据后，将发送 ACK 对数据进行确认。ACK 中包含确认序号，它的值为最后一个已接收字节的序号加一，也就是接收方期望收到的新数据的起始序号。\n那么，TCP 如何实现 流量控制 和 拥塞控制 的呢？\n流量控制。根据 TCP 协议规定，接收方需要维护一个 接收窗口 ，我们可以将它看作内存中的一个缓冲区。在连接建立和数据传输的过程中，接收方会将自己的接收窗口大小通告给发送方。发送方必须保证，发送的数据不超过接收窗口。如果接收窗口被占满，发送方就暂停发送新数据。\n拥塞控制。TCP 发送方自己在内部维护了一个 发送窗口 ，也叫做 拥塞窗口 。这是一个为发送策略算法服务的虚拟概念，表示可以发送的字节数（包含已经发送但仍未确认部分）。发送窗口一开始呈指数增长，比如每收到一个 ACK 就将它翻倍；当接收窗口增大到一定水平，增长速度降为线性增长。这就是 TCP 的 慢启动 过程，在网络状况良好的前提下，不断提高发送速度。如果网络发生拥塞，有数据丢包，这时 TCP 必须重传数据。发送方在重传数据的同时，还会降低发送窗口大小。这种情况下，大部分 TCP 实现会将发送窗口降为原来的一半，以便快速响应，避免进一步堵塞网络。这个机制也被称为 指数退避 。\n最后是 TCP 的关闭，假设主机①数据发送完毕，它向主机②发出 FIN ，成为主动关闭方；主机②则成为被动关闭方，它回复 ACK 后，从主机①到主机②的数据流关闭。这时，连接处于 半关闭状态 ，反方向的数据流仍然有效。也就是说，这时主机②还可以向主机①发送数据。当主机②也发完数据，它同样发出 FIN 指令，告诉主机①数据流关闭；主机①收到 FIN 并回复 ACK 后，连接就完全关闭了。这就是 TCP 连接关闭的主要步骤，也被形象地称为“四次挥手”。\nTCP 报文段格式 由于 TCP 协议位于传输层，它的传输单元一般叫做 TCP段（ segment ），也可译为 TCP分组 。当然了，也有不少文献将它笼统地称为 TCP报文 。\n三次握手 MSS 选项。最大分组长度（maximum segment size）就表示一个 TCP 分组最多能够承载的数据量。 窗口扩大因子。如果窗口字段表示的范围太小了，我们可用窗口字段大小与穿过扩大因子相乘，该相乘是指将数据左移。 拓展阅读：RFC793\n四次挥手 一个 TCP 连接包含两个方向的传输通道，因此需要两对 FIN/ACK 分组，各自负责关闭对应的方向。因此，这两对 FIN/ACK 交互也被形象地称为 四次挥手 。\nTCP 建立连接需要三次握手，关闭连接需要四次挥手，步骤相对繁琐。这意味着一个 TCP 连接应该有很多中间状态。\n客户端发出 SYN 分组，连接进入 SYN_SENT 状态； 服务端收到客户端发来的 SYN 分组，它回复 SYN/ACK 分组，连接进入 SYN_RECV 状态； 客户端收到服务器的 SYN/ACK 分组，它回复 ACK 分组，连接进入 ESTABLISHED 状态； 服务器收到客户端的 ACK 分组，服务端连接也进入 ESTABLISHED 状态； 当连接处于 ESTABLISHED 状态时，客户端和服务端可以互相传输数据； 时序图中间的数据分组及其后的 ACK 分组，为实验中 SSH 服务向客户机返回自己的版本信息（这部分数据被 telnet 命令直接输出到屏幕中）； 客户端准备退出时，它通过 FIN 分组通知服务端，连接进入 FIN_WAIT1 状态； 服务器收到客户端发来的 FIN 分组，它回复 ACK 分组进行确认，连接进入 CLOSE_WAIT 状态； 客户端收到服务器发来的 ACK 分组，连接进入 FIN_WAIT2 状态； 这时连接处于半关闭状态，服务器仍可以向客户端发送数据； 服务器发完剩余数据后，向客户端发送 FIN 分组，通知客户端关闭连接，服务端连接便进入 LAST_ACK 状态； 客户端收到服务器发来的 FIN 分组，回复 ACK 分组进行确认，客户端连接进行 TIME_WAIT 状态； 服务端收到 ACK 分组后，连接彻底关闭； 由于最后一个 ACK 分组可能会丢，客户端必须在 TIME_WAIT 状态等待一段时间，以便对服务器重传的 FIN 分组进行确认； 其中，可以再看一下的是 TIME_WAIT 状态中的 2MSL时长，MSL 是最大分组寿命（ maximum segment lifetime ）的简称，即一个 TCP 分组被丢弃前能够在网络中存在的最长时间。\n将 TIME_WAIT 状态维持 2MSL 时长是出于这样的考虑：\n假设最后一个 ACK 分组刚好在存活时间耗尽前到达对端主机，这时已经过了 MSL 时间。对端收到 ACK 后，就会立即关闭连接，不可能再发送 FIN 分组。但如果对端在收到 ACK 前刚刚重传了 FIN 分组，就必须再经过 MSL 时间才能保证 FIN 分组从网络中消失。因此，连接必须维持 TIME_WAIT 状态 2MSL 时间后才能释放，否则就可能对潜在的新连接造成干扰。\n如果最后一个 ACK 分组可以到达对端，最多只需要等待 2MSL 时间即可保证网络中没有对端重传的 FIN 分组； 如果最后一个 ACK 分组丢失了，对端在 MSL 内已经重传好多次了； 如果重传的 FIN 分组有一个可以到达本端，TCP 回复 ACK 后会重置定时器在 TIME_WAIT 继续等待 2MSL 时长； 如果重传的 FIN 分组都丢了，说明网络质量很差，再等下去也没有意义了； 主动关闭方一般是客户端，并发一般不高，因此 TIME_WAIT 状态基本不会造成任何影响。如果一个高并发服务（比如 Web 服务）存在大量短连接，则可能留下很多 TIME_WAIT 状态的连接。由于 TIME_WAIT 状态套接字无法立即回收，它们将占用大量的系统资源，对服务的性能造成严重影响。\n滑动窗口，TCP的流量控制 TCP 协议规定：当接收方收到一个数据后，必须回复 ACK 给发送方。这样发送方就能得到反馈，如果数据发出去后很长时间都没有收到 ACK 确认，说明数据很有可能已经丢失了。TCP 每次发送数据后，都会启动一个定时器。如果定时器超时还没收到对方确认，TCP 就会重新发送数据。\n由于承载 TCP 报文段的 IP 包是独立路由的，可能走不同的网络路径，无法保证一定按照发送顺序送达目标主机。 TCP 协议需要向上提供连续字节流传输服务，如果报文段错序到达，TCP 必须根据序号重新排列数据。另一方面，数据到达后目标主机后，接收方应用程序可能忙于其他事情，无法及时处理。鉴于这两个点，TCP 接收方需要在内存中准备一个接收缓冲区，用于临时保存数据。\n接收缓冲区大小是有限的，如果应用进程处理缓慢，发送方还拼命发送，最终肯定会压垮接收方。因此，当缓冲区有变化时，接收方应该通过 窗口大小 字段，将它的剩余大小告知发送方。\n接收方通告的窗口大小通常称为 通告窗口（ advertised window ），可缩写为 awnd 。它起到约束发送方发送速度的作用：\n如果接收方应用进程繁忙，迟迟未读取缓冲区里的数据，那么窗口大小将慢慢变小； 当窗口大小降为零，发送方就停止发送新数据； 通过通告窗口，发送方可以实时感知接收方缓冲区的状态，然后根据缓冲区剩余空间动态调整发送速度，这就是 TCP 的 流量控制（ flow control ）机制。\n从数据发送方来说，数据状态的变化就是用滑动窗口来实现的。\nTCP 协议规定，接收方收到数据后，必须发送 ACK 进行确认，以此实现可靠传输。然而，就算是一个小小的 ACK 确认，也需要一个完整 TCP 分组报文来承载，开销很大！\n众所周知，最小的 TCP 分组包含 20 字节的 TCP 头部和 20 字节的 IP 头部，总共 40 字节。试想发送一个 40 字节的 TCP 报文，仅仅只为了告诉发送方 4 字节的确认号，效率得有多低！有效信息才占 10% ！\n为了提高传输效率，TCP 实现了 延迟确认（ delayed ACK ）机制。延迟确认顾名思义就是收到数据不立马确认，而是等上一段时间，跟其他数据一起发送。\n拥塞窗口，TCP的拥塞控制 为实现可靠传输，TCP 实现了接收确认机制：当数据发生丢包时，重传数据。当网络链路负载很重，甚至发生拥塞时，丢包就会很频繁。这时如果 TCP 还拼命地重传数据，将进一步压垮网络！\n网络拥塞（network congestion）是说，每条网络线路都是有带宽的，如果网络流量超超过带宽，丢包就是不可避免的。\n维护拥塞窗口，限制数据发送量； 根据网络当前状态，实时调节拥塞窗口： 如果长时间未收到 ACK 而发生数据重传，说明网络可能拥塞，缩小拥塞窗口，降低发送速度； 每收到一个有效 ACK 都增大拥塞窗口，提高发送速度，因为这通常意味着网络状态良好； TCP 还维护了 拥塞窗口（ congestion window ），根据链路的拥塞程度来约束发送速度。\n拥塞窗口跟滑动窗口类似，同样规定了发送方此刻能够发送出去的字节数，只不过它通过评估网络链路的拥塞程度，并由一定的算法计算而来的。 $$ W = min(awnd, cwnd) $$ 其中，awnd 为通知窗口大小，cwnd 为拥塞窗口大小。\nTCP 学习 cwnd 的算法可以总结为：慢启动、拥塞避免、快速重传和快速恢复。\n收到重复的确认，说明发出去的数据发生丢包，意味着网络可能发生拥塞。TCP 同样会将 ssthresh 设为当前拥塞窗口 cwnd 的一半，并重新执行慢启动算法加以应对。\n快速重传算法会受到捎带确认机制的制约。试想接收方刚好没有数据要发，因此 ACK 确认被延迟，乃至合并，发送方就不会检测到重复确认。\n为了解决这个矛盾，TCP 规定接收方接到乱序数据后就立马发送 ACK 确认。\n新版 TCP（ Reno ）选择跳过慢启动，直接进入拥塞避免阶段，这就是所谓的 快速恢复。\n将 ssthresh 设为当前窗口的一半； 将当前窗口设为 ssthresh ； 执行拥塞避免，窗口大小线性扩张； 实际上，在 TCP 检测到网络拥塞时，窗口和 ssthresh 都是立马减半，因而被称为 乘法减小 或者 指数退避 。每次降低一半，这种下降速度其实也是很快的。\nDNS：域名系统 域名系统的概述 域名是 网域名称 （ domain name ）的简称，它是一串以点号分隔的字符串，用于标识一台或一组计算机。域名可作为 IP 地址的别名，更便于记忆。\n实际上，域名是一个分层次的命名空间，各种域名都隶属于根域 . 。位于第一层的域名称为 一级域名 或 顶级域名 ；第二层的域名称为 二级域名 ；以此类推。\n以 www.fasionchan.com.为例，从右往左读依次是：\n根 一级域名（顶级域名）：com 二级域名：fasionchan 三级域名：www 域名注册后，所有人拥有域名的管理权：不仅可以修改域名关联的 IP ，还可以分配子域名。域名 fasionchan.com 被注册后，可以修改它关联的 IP ，还可以随意添加子域名 www.fasionchan.com 。\n域名的第一级是 顶级域 ，包括\n通用顶级域 ，例如 .com 、 .net 和 .org 等； 国家和地区顶级域 ，例如 .cn 、 .us 等； 通用顶级域 含义 .com 商业公司 .edu 教育机构 .net 互联网服务供应商 .org 非营利组织、国际机构等 国家和地区顶级域 含义 .cn 中国 .hk 中国香港 .mo 中国澳门 .tw 中国台湾 .jp 日本 .us 美国 域名系统 （ domain name system ，简称 DNS ），是互联网提供的一项名字服务。我们可以将 DNS 看作一个分布式数据库，它保存着域名和 IP 的映射关系。\n有了这个对应关系，我们就可以通过 域名 （ domain name ）来访问网络服务，不用再苦苦记忆 IP 地址。要知道域名 www.fasionchan.com 比 IP 地址 163.181.33.224 好记多了。\n域名注册后，所有人可将域名关联的 IP 登记到域名系统。这是一个分布式数据库，以域名为键，以 IP 为值。域名系统提供一些服务器用户查询，这就是 DNS服务器（ dns server ）。\nDNS服务器工作原理 全球域名的最高管理机构是 ICANN （ Internet Corporation for Assigned Names and Numbers ），它是一个总部位于美国加州的组织。ICANN 负责管理整个域名系统的运作，主要工作是规划 顶级域名 （ top level domain ，简写为 TLD ）。\n顶级域名是域名的第一级，可分为两种：\n通用顶级域 ，例如 .com 、 .net 、 .edu 、 .org 等等； 国家地区顶级域 ，例如 .cn 、 .hk 、.jp 、 .us 等等； 理论上，查询任何域名都需要先查询 ICANN 的根域。因为只有根域才能知道：某个域由谁托管，服务器是哪些。事实上也确实如此，ICANN 维护着一张映射表，记录了每个顶级域名和对应的托管商。\n根域名服务器 （ root name server ）保存 DNS 的根区列表。\n根域名服务器列表可在 root-servers.org 上查询。 Anycast 路由技术：分散在不同地理位置的多台服务器，可以使用相同的 IP 地址。当发送方向这个 IP 地址发送数据时，路由协议会自动选择一个最近的节点。\n[root@yikuanzz ~]# dig . NS ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.4-P2-RedHat-9.11.4-26.P2.el7_9.15 \u0026lt;\u0026lt;\u0026gt;\u0026gt; . NS ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 24903 ;; flags: qr rd ra; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;.\tIN\tNS ;; ANSWER SECTION: .\t7\tIN\tNS\tj.root-servers.net. .\t7\tIN\tNS\tg.root-servers.net. .\t7\tIN\tNS\tc.root-servers.net. .\t7\tIN\tNS\th.root-servers.net. .\t7\tIN\tNS\te.root-servers.net. .\t7\tIN\tNS\tl.root-servers.net. .\t7\tIN\tNS\tm.root-servers.net. .\t7\tIN\tNS\td.root-servers.net. .\t7\tIN\tNS\tb.root-servers.net. .\t7\tIN\tNS\ta.root-servers.net. .\t7\tIN\tNS\ti.root-servers.net. .\t7\tIN\tNS\tf.root-servers.net. .\t7\tIN\tNS\tk.root-servers.net. ;; Query time: 0 msec ;; SERVER: 100.100.2.136#53(100.100.2.136) ;; WHEN: Wed Jun 05 14:48:29 CST 2024 ;; MSG SIZE rcvd: 433 当我们查询一个域名时，必须从根服务器开始，逐层查询，这就是所谓的 迭代查询 （ iterative query ）。\n当我们查询一个域名，例如 www.fasionchan.com 时：\n先查根域名服务器； 根域名服务器就 13 台，IP 大家都知道，极少改动； 根域名服务器保存根区列表，列表包含顶级域名的托管商，以及相关服务器信息； 根域名服务器根据根区列表，告诉我们 .com 顶级域应该找谁查询； 根据根服务器返回结果，继续查询负责 .com 解析的服务器，一般叫做顶级域名服务器； 主域名 fasionchan.com 注册后，需要将负责该域名解析的服务器，登记在 .com 顶级域名服务器上； .com 顶级域名服务器根据这个信息，告诉我们 fasionchan.com 这个域名应该找谁查询； 根据顶级域名服务器返回结果，继续查询负责fasionchan.com解析的服务器，一般叫做权威域名服务器； fasionchan.com 子域信息一般都登记在权威服务器上； 权威服务器取出 www.fasionchan.com 对应记录，并返回给我们，查询结束； 如果某个子域由其他权威服务器负责，我们还需要继续迭代，直到查询完毕； 一般来说，本地主机会通过本地的 递归解析器 去对网址进行递归，递归解析对客户端来说是完全透明的，客户端完全不用关心递归解析器背后的其他 DNS 服务器。\n此外，递归解析器还会将查询结果在本地缓存起来。当域名再次被查询时，它可直接返回缓存结果，无须重新查询其他 DNS 服务器。正因如此，递归解析器通常被称为 DNS缓存服务器 。\nDNS 报文格式 DNS 是一个典型的 Client-Server 应用，客户端发起域名查询请求，服务端对请求进行应答。\nDNS 一般采用 UDP 作为传输层协议（TCP也行），端口号是 53。请求报文和应答报文均作为数据，搭载在 UDP 数据报中进行传输。\nDNS 报文分为 请求 和 应答 两种，结构是类似的，大致分为五部分：\n头部（ header ），描述报文类型，以及其下 4 个小节的情况； 问题节（ question ），保存查询问题； 答案节（ answer ），保存问题答案，也就是查询结果； 授权信息节（ authority ），保存授权信息； 附加信息节（ additional ），保存附加信息； QR 位标记报文是一个查询请求，还是查询应答； 0 表示查询请求； 1 表示查询应答； 操作码（opcode）占 4 位，表示操作类型； 0 是标准查询； 1 是反向查询； 2 是服务器状态请求； AA 表示 权威回答（authoritative answer），意味当前查询结果由域名的权威服务器给出； TC 表示 截短（truncated），使用 UDP 时，如果应答超过 512 字节，只返回前 512 个字节； RD 表示 期望递归（recursion desired），在请求中设置，并在应答中返回； 该位为 1 时，服务器必须处理这个请求：如果服务器没有授权回答，它必须替客户端请求其他 DNS 服务器，这也是所谓的 递归查询 ； 该位为 0 时，如果服务器没有授权回答，它就返回一个能够处理该查询的服务器列表给客户端，由客户端自己进行 迭代查询 ； RA 表示 可递归（recursion available），如果服务器支持递归查询，就会在应答中设置告知客户端； 保留位，未来扩展。 响应码（response code）表示请求结果； 0 表示没有差错； 3 表示名字差错，该差错由权威服务器返回，表示待查询的域名不存在； 问题节支持保存多条问题记录，记录条数则保存在 DNS 头部中的问题记录数字段。这意味着，DNS 协议单个请求能够同时查询多个域名，虽然通常只查询一个。\n待查域名（Name），字段长不固定。 查询类型（Type），除了关联 IP 地址，还可以关联其他信息常见类型包括： 1 表示 A 记录，即 IP 地址； 28 表示 AAAA 记录，即 IPv6 地址； 类（Class）通常为 1，表示 TCP/IP 互联网地址； 服务端处理查询请求后，需要向客户端发送应答报文；域名查询结果作为资源记录，保存在答案以及其后两节中.\n有效期（ TTL ），域名记录一般不会频繁改动，所以在有效期内可以将结果缓存起来，降低请求频率； 数据长度（ Resource Data Length ），即查询结果的长度； 数据（ Resource Data ），即查询结果； 1、请求报文实例。\n2、应答报文实例\n附录：补充知识点 Linux 内核 - ioctl ioctl是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。\n# include \u0026lt;sys/ioctl.h\u0026gt; int ioctl(int fd, int cmd, ...) ","date":"2024-05-21T08:10:37+08:00","image":"https://yikuanzz.github.io/2024/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/cover_hu7de092c981d04a68ecb78876337b6c3c_1423095_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","title":"计算机网络学习"},{"content":"How to Write an Email in English Greetings Formal:\nDear xxx\tand no greeting Informal:\nHi xxx\tor Hello xxx I hope you\u0026rsquo;ll well. How are you? Opening Formal:\nI\u0026rsquo;m writing regarding \u0026hellip; I wanted to follow up on \u0026hellip; I would like to ask about \u0026hellip; Informal:\nDo you know \u0026hellip; Let\u0026rsquo;s \u0026hellip; How will \u0026hellip; Adding detail Main idea, and talk more about the thing,\nChange topic Some Examples:\nThere\u0026rsquo;s one more thing I\u0026rsquo;d like to discuss with you. Regarding \u0026hellip; I\u0026rsquo;d like to ask you about \u0026hellip;. Adding a call to action Some Examples:\nPlease \u0026hellip; by tomorrow at the latest. As a matter of urgency, you need to \u0026hellip;. Could you please \u0026hellip; I would like you to \u0026hellip; Other Examples:\nI suggest that you \u0026hellip; Can I ask you to \u0026hellip; Please let me \u0026hellip; If don\u0026rsquo;t need replay:\nThis is just to keep you updated. This doesn\u0026rsquo;t require and immediate response, but please keep on eye on the situation. An Email Example Dear Lina,\nI need to bring something to your attention: many staff are using very weak passwords on their laptops and for database access.\nOur work depends on keeping our client\u0026rsquo;s personal financial information safe. If we lose our client\u0026rsquo;s trust on this issue, it will not be easy to recover. I trust that you can see that it is better to take action now, rather than after something goes wrong.\nI suggest we make a rule that passwords must be a specific length, and that staff must change their passwords at least once a month. Please let me know what you think about this.\nRegards,\nVijay.\nHow to use Commas Listing Comma Some Examples:\nWe need two cucumbers, four tomatoes, some onions and a lettuce. We spent our time relaxing on the beach, swimming in the sea and drinking coffee in the seaside cafes. Joining Comma Some Examples:\nWe were tired, and we really didn\u0026rsquo;t feel like going anywhere. He seemed nice, but he just wasn\u0026rsquo;t my type. You\u0026rsquo;ll either have to start again, or find someone to help you. Bracketing Comma Some Examples:\nThis book, first published in 1956, is still useful for students today.\nOne of my colleagues, who used to be a semi-professional footballer, invited me to play in their 5-a-side team this weekend.\nSimilar to most people his age, he isn\u0026rsquo;t really thinking about his future.\nHe told me that he wanted to quit and become a painter, which surprised me.\nTips to improve Your Sentence Structure subject + verb Some Examples:\nThey have a nice house. Everybody agreed. (Everybody who was at the meeting agreed to change the office dress code to something more informal.) My math teacher from high school was really good at explaining complicated things. Empty subjects: \u0026lsquo;it\u0026rsquo; and \u0026rsquo;there\u0026rsquo;:\nIt won\u0026rsquo;t take long to get there. It\u0026rsquo;s worth going. There\u0026rsquo;s a mosquito on your nose. There have been several developments since the last time we spoke. It + distance:\nIt\u0026rsquo;s not far to the metro.\nHow long will it take you to finish everything?\nIt\u0026rsquo;s six thirty.\nIt + weather:\nIt\u0026rsquo;s sunny.\nIt\u0026rsquo;ll be cold tomorrow.\nIt was really wet last month.\nIt \u0026raquo; describing situations:\nIt\u0026rsquo;s safe to walk around at night here. It\u0026rsquo;s good that you could join us. It\u0026rsquo;s really cozy in here. There == something exists\t(mention firstly)\nThere\u0026rsquo;s some salad in the fridge.\nThere\u0026rsquo;s are several reasons why I have to say \u0026rsquo;no\u0026rsquo; to this idea.\nThere didn\u0026rsquo;t use to be so many homeless people here.\nsubject + aux verb + main verb Some Examples:\nThey have bought a nice house.\nMy sister Mandy will call tonight.\nmain verb + subject Some Examples:\t(questions with \u0026lsquo;be\u0026rsquo;)\nAre you ready? Were there many people there? aux verb + subject Some Examples:\t(questions + formal structures)\nCan you help me?\nWhat time does she arrive?\nHow many pieces of cake have you had already?\nAt no time did I suspect that he was the thief.\n5 Ways to Compare and Contrast in English Talking about big differences Some Examples:\nThey\u0026rsquo;re totally different. It\u0026rsquo;s hard to compare them. They\u0026rsquo;re almost nothing alike. Other Examples:\nEverything moves so much faster. Laos is way more relaxed. Lisbon is much cheaper than most European cites. The museum was so much more interesting than I expected. Shanghai is way bigger than anywhere I\u0026rsquo;ve been before. Talking about close similarities Some Examples:\nThey\u0026rsquo;re so alike. I can hardly tell them apart. They look so similar. They\u0026rsquo;re equally chatty. He\u0026rsquo;s just as sarcastic as his brother. Other Examples:\nI can hardly tell these two wines apart. I hated both cities; they\u0026rsquo;re equally terrible. Playing golf is just as boring as watching it. Talking about small differences Some Examples:\nThey played a bit better.\nThey were just a little sharper.\nThe keeper did slightly better.\nHe wasn\u0026rsquo;t quite as hesitant as he was last week.\nOther Examples:\nTaking the train will be a bit faster. She\u0026rsquo;s a little older than her husband. This isn\u0026rsquo;t quite as spicy as the last time you made it. Food topic Some Examples:\nThe dishes didn\u0026rsquo;t vary much. Everything tasted much the same. The main dishes were all pretty similar. It was more or less like tonight. It was nearly as expensive as that Japanese place we went to for my birthday. Other Example:\nApartments here don\u0026rsquo;t vary much.\nYou can do it today or tomorrow - it\u0026rsquo;s much the same to me.\nA lot of small towns in the UK are pretty similar.\nThere are different versions of rugby, but the basic idea is more or less the same.\nMy nephew is almost as tall as me now!\nOther topics Comparing two cities:\nIf you visit Russia, you should definitely visit both Moscow and St Petersburg. They\u0026rsquo;re completely different cities. St Petersburg feels much more European than Moscow, while Moscow is a bit gritter , but very interesting. Things like accommodation, food, transport and so on are much the same in both places. It\u0026rsquo;s slightly easier to find a cheaper place to stay in St Petersburg, but Moscow has a bit more variety when it comes to eating out. To get around, take the metro, which is just as efficient in both cities.\nComparing working at home and working in an office:\nIt\u0026rsquo;s hard to compare working at home and working in an office. People think that working at home would be much more relaxing, but that\u0026rsquo;s not always true. You still have to do just as much work, so it can be equally stressful. Of course, you have slightly more freedom to plan your own day, but you also have to be a bit more responsible, because otherwise you end up wasting a lot of time. In the end, you save time commuting, but most people waste a little more time, so you spend nearly as much time working as if you just went to work.\n","date":"2024-05-20T13:17:41+08:00","image":"https://yikuanzz.github.io/2024/oxford-online-english/cover_hu55090c9be9d13acbbac92b95f4d8e731_1448762_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/oxford-online-english/","title":"Oxford Online English"},{"content":"数据结构 栈 【模板】栈 描述：请你实现一个栈。\npush x : 将 x 入栈，保证 x 为 int 整数。 pop ：输出栈顶，并让栈顶出栈。 top ：输出栈顶，栈顶不出栈。 输入描述：第一行为一个正整数 n 代表操作次数。（1 \u0026lt;= n \u0026lt;= 100000），接下来的 n，每行为一个字符串，代表一个操作。\n输出描述：如果操作为 push，则不输出任何东西。如果为另外两种，若栈为空，则输出 “error”。否则按对应操作输出。\n示例：\n输入： 6 push 1 pop top push 2 push 3 pop 输出： 1 error 3 class Stack: def __init__(self, size=100000) -\u0026gt; None: self.stack = [] self.size = size self.index = -1 def is_empty(self): if self.index == -1: print(\u0026#34;error\u0026#34;) return True else: return False def push(self, num): self.stack.append(num) self.index += 1 def pop(self): if self.is_empty(): return else: res = self.stack.pop() self.index -= 1 print(res) def top(self): if self.is_empty(): return else: res = self.stack[self.index] print(res) n = int(input()) s = Stack() for line in range(n): str = input() if str == \u0026#39;pop\u0026#39;: s.pop() elif str == \u0026#39;top\u0026#39;: s.top() else: s1 = str.split(\u0026#39; \u0026#39;) s.push(int(s1[1])) 栈的压入、弹出序列 描述：输入练个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈道所有数字均不相等。例如序列 1，2，3，4，5 是某栈道压入顺序，序列 4，5，3，2，1 是该压栈序列对应的一个弹出序列，但 4，3，5，1，2 就不可能是该压栈序列的弹出序列。\n1、0 \u0026lt;= pushV.length == popV.length \u0026lt;= 1000。 2、-1000 \u0026lt;= pushV[i] \u0026lt;= 1000。 3、pushV 的所有数字均不同。 示例1：\n输入： [1,2,3,4,5],[4,5,3,2,1] 返回值： true 说明： 可以通过push(1)=\u0026gt;push(2)=\u0026gt;push(3)=\u0026gt;push(4)=\u0026gt;pop()=\u0026gt;push(5)=\u0026gt;pop()=\u0026gt;pop()=\u0026gt;pop()=\u0026gt;pop() 这样的顺序得到[4,5,3,2,1]这个序列，返回true。 示例2：\n输入： [1,2,3,4,5],[4,3,5,1,2] 返回值： false 说明： 由于是[1,2,3,4,5]的压入顺序，[4,3,5,1,2]的弹出顺序，要求4，3，5必须在1，2前压入，且1，2不能弹出，但是这样压入的顺序，1又不能在2之前弹出，所以无法形成的，返回false。 栈的操作主要有：出栈、入栈两个操作。\n有效括号序列 描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s。\n要求：判断字符串 s 是否有效（即括号是否匹配）。\n说明：\n有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例：\n输入：s = \u0026#34;()\u0026#34; 输出：True 输入：s = \u0026#34;()[]{}\u0026#34; 输出：True 队列 链表 图论 二叉树 堆 搜索 广度优先 深度优先 基础算法 查找 枚举 递归 分治 排序 贪心 双指针 动态规划 线性dp 背包 ","date":"2024-05-15T20:12:01+08:00","image":"https://yikuanzz.github.io/2024/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/cover_huc9ab3d7ed019926a9f9f465aed9d9abd_1177387_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","title":"简单算法问题"},{"content":"Shell 简介 Bash（Bourne Again SHell） 是 Unix 系统和 Linux 系统的一种命令环境。\nShell 是一个程序，它提供了用户与计算机交互的环境。其次，Shell 也是命令解释器，能够写一些简单的脚本。最后，Shell 也是一个工具箱，方便用户操作系统。\n我们可以查看在 Linux 系统下的 Shell。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $SHELL /bin/bash [root@iZ7xvfomazz4187zib4aurZ ~]# cat /etc/shells /bin/sh /bin/bash /usr/bin/sh /usr/bin/bash 命令行环境 进入命令行环境以后，用户会看到 Shell 的提示符。\n# 用户名@主机名 [user@hostname] $ 当然，如果用户是 root 那么会以 # 结尾，而不是以美元符号 $ 结尾。\n一般来说，进入命令行环境后就已经打开 Bash 了，如果不是则可以用 bash 来启动，然后退出就是 exit 命令。\nBash 基本语法 echo 命令 echo 命令就相当于 print 命令的用法。\n# 单行文本输出 [root@iZ7xvfomazz4187zib4aurZ ~]# echo Hello Yikuanzz Hello Yikuanzz # 多行文本输出 [root@iZ7xvfomazz4187zib4aurZ ~]# echo \u0026#34;\u0026lt;HTML\u0026gt; \u0026gt; \u0026lt;HEAD\u0026gt; \u0026gt; \u0026lt;TITLE\u0026gt;Page Title\u0026lt;/TITLE\u0026gt; \u0026gt; \u0026lt;/HEAD\u0026gt; \u0026gt; \u0026lt;BODY\u0026gt; \u0026gt; Page body. \u0026gt; \u0026lt;/BODY\u0026gt; \u0026gt; \u0026lt;/HTML\u0026gt;\u0026#34; \u0026lt;HTML\u0026gt; \u0026lt;HEAD\u0026gt; \u0026lt;TITLE\u0026gt;Page Title\u0026lt;/TITLE\u0026gt; \u0026lt;/HEAD\u0026gt; \u0026lt;BODY\u0026gt; Page body. \u0026lt;/BODY\u0026gt; \u0026lt;/HTML\u0026gt; -n 参数 默认情况下，echo 输出的文本末尾会有一个回车符号，-n 参数可以取消末尾的回车符。分号作为命令的结束符号。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo -n Hello Yikuanzz Hello Yikuanzz[root@iZ7xvfomazz4187zib4aurZ ~]# [root@iZ7xvfomazz4187zib4aurZ ~]# echo hello;echo yikuanzz hello yikuanzz -e 参数 -e 参数会解释引号里面的特殊字符。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo \u0026#34;Hello\\nYikuanzz\u0026#34; Hello\\nYikuanzz [root@iZ7xvfomazz4187zib4aurZ ~]# echo -e \u0026#34;Hello\\nYikuanzz\u0026#34; Hello Yikuanzz shopt 命令 shopt 命令用来调整 Bash 的行为：\nshopt -s [optionname] 打开某个参数。 shopt -u [optionname] 打开某个参数。 shopt [optionname] 查询某个参数是关闭还是打开 dotglob 参数 dotglob参数可以让拓展结果包括隐藏文件（即 . 开头的文件）。\n[root@iZ7xvfomazz4187zib4aurZ ~]# shopt dotglob dotglob off [root@iZ7xvfomazz4187zib4aurZ ~]# ls * file.txt [root@iZ7xvfomazz4187zib4aurZ ~]# shopt -s dotglob [root@iZ7xvfomazz4187zib4aurZ ~]# shopt dotglob dotglob on [root@iZ7xvfomazz4187zib4aurZ ~]# ls * .bash_history .bashrc .lesshst\tfile.txt nullglob 参数 nullglob 参数可以让通配符不匹配任何文件名时，返回空字符。\n[root@iZ7xvfomazz4187zib4aurZ ~]# shopt nullglob nullglob off [root@iZ7xvfomazz4187zib4aurZ ~]# rm b* rm: cannot remove ‘b*’: No such file or directory [root@iZ7xvfomazz4187zib4aurZ ~]# shopt -s nullglob [root@iZ7xvfomazz4187zib4aurZ ~]# shopt nullglob nullglob on [root@iZ7xvfomazz4187zib4aurZ ~]# rm b* rm: missing operand Try \u0026#39;rm --help\u0026#39; for more information. failglob 参数 failglob 参数让通配符不匹配任何文件名时，Bash 会直接报错，而不是让命令去处理。\n[root@iZ7xvfomazz4187zib4aurZ ~]# shopt -s failglob [root@iZ7xvfomazz4187zib4aurZ ~]# rm b* -bash: no match: b* extglob 参数 extglob 参数让 Bash 支持 Korn SHell 的拓展语法，主要是量词语法。\n量词语法有下面几个：\n?(pattern-list)：匹配零个或一个模式；例如 ?(def) 表示匹配零个或一个 def。 *(pattern-list)：匹配零个或多个模式. +(pattern-list)：匹配一个或多个模式；例如 +(.txt|.php) 表示匹配 .txt 或 .php。 @(pattern-list)：只匹配一个模式。 !(pattern-list)：匹配零个或一个以上的模式，但不匹配单独一个的模式。 nocaseglob 参数 nocaseglob 参数可以让通配符拓展不区分大小写。\n比如，打开后 program* 就不区分大小写了，可以匹配 ProgramData 等等。\nglobstar 参数 globstar 参数可以让 ** 匹配零个或多个子目录。\n比如，我们用 ls **/*.txt 就可以匹配当前目录和多个子目录的 txt 文件。\nread 命令 read 命令，它将用户的输入存入一个变量，它的语法格式为 read [-options][variable]。其中，options 是参数选项，variable 是用来保存输入数值的一个或多个变量名，如果没有提供变量名，环境变量 REPLY 会包含用户输入的一整行数据。\n#!/usr/bin/env bash echo -n \u0026#34;输入文本 \u0026gt;\u0026#34; read text echo \u0026#34;你的输入为: $text\u0026#34; read 命令除了读取键盘输入，可以用来读取文件。\n#!/usr/bin/env bash while read myline do echo \u0026#34;$myline\u0026#34; done \u0026lt; $filename -t 参数 read命令的 -t参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。或者我们也可以设置环境变量 TMOUT。\n#!/usr/bin/env bash echo -n \u0026#34;输入文本 \u0026gt; \u0026#34; if read -t 3 response; then echo \u0026#34;用户已输入\u0026#34; else echo \u0026#34;用户未输入\u0026#34; fi -p 参数 read命令的 -p参数，指定用户输入的提示信息。\n#!/usr/bin/env bash read -p \u0026#34;Enter one or more values \u0026gt; \u0026#34; echo \u0026#34;REPLY = \u0026#39;$REPLY\u0026#39;\u0026#34; -a 参数 read命令的 -a参数把用户的输入赋值给一个数组，索引是从 0 开始的。\n[root@iZ7xvfomazz4187zib4aurZ bin]# read -a response Hello Yikuanzz [root@iZ7xvfomazz4187zib4aurZ bin]# echo ${response[1]} Yikuanzz -n 参数 read命令的 -n 参数指定只读取若干字符作为变量值，而不是整行读取。\n[root@iZ7xvfomazz4187zib4aurZ ~]# read -n 3 var aklhgalg [root@iZ7xvfomazz4187zib4aurZ ~]# echo $var akl -e 参数 read命令的 -n 参数允许用户输入的时候，使用 readline 库提供的快捷键。\n#!/usr/bin/env bash echo \u0026#34;请输入文件地址:\u0026#34; read -e fileName echo $fileName IFS 变量 read 命令读取的值，默认是以空格分隔，可以通过自定义环境变量 IFS （内部字段分隔符，Internal Field Separator ），修改分隔标志。\n[root@iZ7xvfomazz4187zib4aurZ ~]# IFS=\u0026#39;|\u0026#39; [root@iZ7xvfomazz4187zib4aurZ ~]# text=\u0026#39;aa|bbb|cccc\u0026#39; [root@iZ7xvfomazz4187zib4aurZ ~]# for i in $text;do echo \u0026#34;i=$i\u0026#34;; done i=aa i=bbb i=cccc 如果 IFS 设为空字符串，整行读入一个边量。\n#!/usr/bin/env bash input=\u0026#34;/path/to/txt/file\u0026#34; while IFS= read -r line do echo \u0026#34;$line\u0026#34; done \u0026lt; \u0026#34;$input\u0026#34; 条件判断 if 和 case if、elif 和 else 关键字。\nif commands; then commands [elif commands; then commands...] [else commands] fi\t一个小例子：\n#!/usr/bin/env bash echo -n \u0026#34;输入一个1到3之间的数字（包含两端）\u0026gt;\u0026#34; read character if [ \u0026#34;$character\u0026#34; = \u0026#34;1\u0026#34; ]; then echo 1 elif [ \u0026#34;$character\u0026#34; = \u0026#34;2\u0026#34; ]; then echo 2 elif [ \u0026#34;$character\u0026#34; = \u0026#34;3\u0026#34; ]; then echo 3 else echo \u0026#34;输入不符合要求\u0026#34; fi 在 if 结构的判断条件中，一般使用 test 命令，有三种形式：test expression、[ expression ]、[[ expression ]]。\n另一个常见的条件判断就是 case 结构了。\ncase expression in pattern ) commands ;; pattern ) commands ;; ... esac 一个小例子：\n#!/usr/bin/env bash echo -n \u0026#34;输入一个1到3之间的数字（包含两端）\u0026gt; \u0026#34; read character case $character in 1 ) echo 1 ;; 2 ) echo 2 ;; 3 ) echo 3 ;; * ) echo \u0026#34;输入不符合要求\u0026#34; esac 文件判断 以下表达式用来判断文件状态。\n[ -a file ]：如果 file 存在，则为true。 [ -b file ]：如果 file 存在并且是一个块（设备）文件，则为true。 [ -c file ]：如果 file 存在并且是一个字符（设备）文件，则为true。 [ -d file ]：如果 file 存在并且是一个目录，则为true。 [ -e file ]：如果 file 存在，则为true。 [ -f file ]：如果 file 存在并且是一个普通文件，则为true。 [ -g file ]：如果 file 存在并且设置了组 ID，则为true。 [ -G file ]：如果 file 存在并且属于有效的组 ID，则为true。 [ -h file ]：如果 file 存在并且是符号链接，则为true。 [ -k file ]：如果 file 存在并且设置了它的“sticky bit”，则为true。 [ -L file ]：如果 file 存在并且是一个符号链接，则为true。 [ -N file ]：如果 file 存在并且自上次读取后已被修改，则为true。 [ -O file ]：如果 file 存在并且属于有效的用户 ID，则为true。 [ -p file ]：如果 file 存在并且是一个命名管道，则为true。 [ -r file ]：如果 file 存在并且可读（当前用户有可读权限），则为true。 [ -s file ]：如果 file 存在且其长度大于零，则为true。 [ -S file ]：如果 file 存在且是一个网络 socket，则为true。 [ -t fd ]：如果 fd 是一个文件描述符，并且重定向到终端，则为true。 这可以用来判断是否重定向了标准输入／输出错误。 [ -u file ]：如果 file 存在并且设置了 setuid 位，则为true。 [ -w file ]：如果 file 存在并且可写（当前用户拥有可写权限），则为true。 [ -x file ]：如果 file 存在并且可执行（有效用户有执行／搜索权限），则为true。 [ file1 -nt file2 ]：如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为true。 [ file1 -ot file2 ]：如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为true。 [ FILE1 -ef FILE2 ]：如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为true。 字符串判断 以下表达式用来判断字符串。\n[ string ]：如果string不为空（长度大于0），则判断为真。 [ -n string ]：如果字符串string的长度大于零，则判断为真。 [ -z string ]：如果字符串string的长度为零，则判断为真。 [ string1 = string2 ]：如果string1和string2相同，则判断为真。 [ string1 == string2 ] 等同于[ string1 = string2 ]。 [ string1 != string2 ]：如果string1和string2不相同，则判断为真。 [ string1 '\u0026gt;' string2 ]：如果按照字典顺序string1排列在string2之后，则判断为真。 [ string1 '\u0026lt;' string2 ]：如果按照字典顺序string1排列在string2之前，则判断为真。 整数判断 下面的表达式用于判断整数。\n[ integer1 -eq integer2 ]：如果integer1等于integer2，则为true。 [ integer1 -ne integer2 ]：如果integer1不等于integer2，则为true。 [ integer1 -le integer2 ]：如果integer1小于或等于integer2，则为true。 [ integer1 -lt integer2 ]：如果integer1小于integer2，则为true。 [ integer1 -ge integer2 ]：如果integer1大于或等于integer2，则为true。 [ integer1 -gt integer2 ]：如果integer1大于integer2，则为true。 正则判断 [[ expression ]] 支持正则表达式。\n一般来说，它的语法格式是 [[ string1 =~ regex ]]，其中 regex 是一个正则表达式，=~ 是正则比较运算符号。\n#!/usr/bin/env bash INT=-5 if [[ \u0026#34;$INT\u0026#34; =~ ^-?[0-9]+$ ]]; then echo \u0026#34;INT is an integer.\u0026#34; exit 0 else echo \u0026#34;INT is not an integer.\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi 循环 while、until 和for 首先要介绍的是每个语言中，几乎都会有的关键字 break 和 continue。\nbreak 命令立即终止循环，程序继续执行循环块之后的语句。\ncontinue 命令立即终止本轮循环，开始执行下一轮循环。\nwhile 循环 while condition; do commands done 一个小例子：\n#!/bin/bash number=0 while [ \u0026#34;$number\u0026#34; -lt 10 ]; do echo \u0026#34;Number = $number\u0026#34; number=$((number + 1)) done until 循环 until condition; do commands done 因为 until 循环与 while 循环恰好相反，只要不符合判断条件，就不断循环执行指定的语句。\n#!/usr/bin/env bash number=0 until [ \u0026#34;$number\u0026#34; -ge 10 ]; do echo \u0026#34;Number = $number\u0026#34; number=$((number + 1)) done until 的条件部分也可以是一个命令，表示命令执行成功之前，不断重复尝试。\nuntil cp $1 $2; do echo \u0026#39;Attempt to copy failed. waiting ...\u0026#39; sleep 5 done 如果我们写成 while 循环的形式，把条件设为否定。\nwhile ! cp $1 $2; do echo \u0026#39;Attempt to copy failed. waiting ...\u0026#39; sleep 5 done\tfor ... in 循环 for ... in 循环主要用于遍历列表的每一项。\nfor variable in list do commands done 列表可以有字符串组成的列表、通配符产生的列表或者子命令执行产生的列表，我们可以看看下面的例子。\n#!/usr/bin/env bash # 字符串形式 for i in word1 word2 word3; do echo $i done # 通配符形式 for i in *.png; do ls -l $i done # 子命令形式 count=0 for i in $(car ~/.bash_profile); do count=$((count+1)) echo \u0026#34;Word $count ($i) contains $(echo -n $i | wc -c) characters\u0026#34; done in list 部分可以省略，当省略后它相当于将脚本的所有参数 $@ 并入循环，但是为了可读性我们不会希望将它省略。\n#!/usr/bin/env bash for filename in \u0026#34;$@\u0026#34;; do echo \u0026#34;$filename\u0026#34; done for 循环 for (( expression1; expression2; expression3 )); do commands done 其中，expression1 用来初始化循环条件，expression2 用来决定循环结束的条件，expression3 在每次循环迭代的末尾执行，用于更新值。\n#!/usr/bin/env bash for (( i=0; i\u0026lt;5; i+=1 )); do echo $i done select 结构 select 结构主要用来生成简单的菜单，它的语法与 for ... in 循环基本一致。\nselect name [in list] do commands done Bash 会对select依次进行下面的处理。\nselect生成一个菜单，内容是列表 list 的每一项，并且每一项前面还有一个数字编号。 Bash 提示用户选择一项，输入它的编号。 用户输入以后，Bash 会将该项的内容存在变量 name，该项的编号存入环境变量 REPLY。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。 执行命令体 commands。 执行结束后，回到第一步，重复这个过程。 当然，select 可以与 case 结合，针对不同项，执行不同的命令。\n#!/usr/bin/env bash echo \u0026#34;Which Operating System do you like?\u0026#34; select os in Ubuntu LinuxMint Windows8 Windows7 WindowsXP do case $os in \u0026#34;Ubuntu\u0026#34;|\u0026#34;LinuxMint\u0026#34;) echo \u0026#34;I also use $os.\u0026#34; ;; \u0026#34;Windows8\u0026#34; | \u0026#34;Windows10\u0026#34; | \u0026#34;WindowsXP\u0026#34;) echo \u0026#34;Why don\u0026#39;t you try Linux?\u0026#34; ;; *) echo \u0026#34;Invalid entry.\u0026#34; break ;; esac done 命令组合符号 \u0026amp;\u0026amp; 和 || Command1 \u0026amp;\u0026amp; Command2 表示 Command1 执行成功后，继续执行 Command2。\n[root@iZ7xvfomazz4187zib4aurZ ~]# cat file.txt \u0026amp;\u0026amp; ls -l file.txt hello -rw-r--r-- 1 root root 6 Apr 23 09:39 file.txt Command1 || Command2 表示 Command1 执行失败后，才执行 Command2。\n[root@iZ7xvfomazz4187zib4aurZ ~]# mkdir foo || mkdir bar 此外，我们通过 type 可以知道命令是内置命令还是外部命令。\n[root@iZ7xvfomazz4187zib4aurZ ~]# type echo echo is a shell builtin [root@iZ7xvfomazz4187zib4aurZ ~]# type mkdir mkdir is hashed (/usr/bin/mkdir) 如果，我们给 type 加上 -t 参数，就可以返回一个命令的类型：别名（alias）、关键词（keyword）、函数（function）、内置命令（builtin）和文件（file）。\n[root@iZ7xvfomazz4187zib4aurZ ~]# type -t type builtin Bash 模式扩展 Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。\n这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。\n我们可以通过 set -f 命令关闭拓展，set +f 命令打开拓展。\n~ 拓展 我们使用 ~ 会自动拓展为当前用户的主目录。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo ~ /root 用 ~/dir 表示拓展成主目录的某个子目录，注意该目录的实际地址并不一定在这个目录。\n[root@iZ7xvfomazz4187zib4aurZ home]# echo ~/test /root/test 用 ~user 表示拓展成用户 user 的主目录，如果该用户不存在则不会拓展。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo ~root /root 用 ~+ 则会拓展为当前所在的目录。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo ~+ /home/test ? 拓展 ? 代表文件路径里面的任意字符，这里是不包括空字符的。\n[root@iZ7xvfomazz4187zib4aurZ test]# ls ??.txt f1.txt f2.txt f3.txt [root@iZ7xvfomazz4187zib4aurZ test]# echo ?.txt a.txt b.txt * 拓展 * 代表文件路径里面的任意数量字符，包括数量为零的情况。\n[root@iZ7xvfomazz4187zib4aurZ test]# ll *.txt -rw-r--r-- 1 root root 0 Apr 23 14:36 a.txt -rw-r--r-- 1 root root 0 Apr 23 14:36 b.txt -rw-r--r-- 2 root root 0 Feb 27 08:19 f1.txt -rw-r--r-- 2 root root 0 Feb 27 08:19 f2.txt lrwxrwxrwx 1 root root 6 Feb 27 08:28 f3.txt -\u0026gt; f1.txt * 不会匹配隐藏文件，就是以 . 开头的文件。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo .* . .. .bash_history .bash_logout .bash_profile .bashrc .cache .cshrc .docker .dotnet .lesshst .mysql_history .pip .pki .pydistutils.cfg .rnd .ssh .tcshrc .viminfo .vscode-server [root@iZ7xvfomazz4187zib4aurZ ~]# echo .[!.]* .bash_history .bash_logout .bash_profile .bashrc .cache .cshrc .docker .dotnet .lesshst .mysql_history .pip .pki .pydistutils.cfg .rnd .ssh .tcshrc .viminfo .vscode-server [] 拓展 [] 表示选择 [...] 中的一个字符。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo [fab]*.txt a.txt b.txt f1.txt f2.txt f3.txt 当然，我们可以使用 [^...] 和 [!...] 来匹配不在括号中的字符。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo ?[!3].txt f1.txt f2.txt 注意，即使文件不存在也会进行拓展。与之相对，如果文件不存在，大部分的符号都不会拓展。\n[start-end] 拓展 [start-end] 表示匹配一个连续的范围，比如 [0-5] 匹配 [012345]。\n常用的有：\n[a-z]：所有小写字母。 [a-zA-Z]：所有小写字母与大写字母。 [a-zA-Z0-9]：所有小写字母、大写字母与数字。 [root@iZ7xvfomazz4187zib4aurZ test]# echo f[1-3].txt f1.txt f2.txt f3.txt {} 拓展 {} 表示分别拓展成大括号里面的所有值，各个值之间用逗号分隔，比如 {1,2,3} 拓展为 1 2 3。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo hello-yikuan{1,2,3,4,5} hello-yikuan1 hello-yikuan2 hello-yikuan3 hello-yikuan4 hello-yikuan5 [root@iZ7xvfomazz4187zib4aurZ test]# echo a{A{1,2},B{3,4}}b aA1b aA2b aB3b aB4b [root@iZ7xvfomazz4187zib4aurZ test]# echo {cat,f*} cat f1.txt f2.txt f3.txt {start..end} 拓展 {start..end} 表示拓展成一个连续的序列。比如，{a..z}可以扩展成26个小写英文字母。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo {a..z} a b c d e f g h i j k l m n o p q r s t u v w x y z [root@iZ7xvfomazz4187zib4aurZ test]# echo {001..11} 001 002 003 004 005 006 007 008 009 010 011 [root@iZ7xvfomazz4187zib4aurZ test]# echo {1..9..3} 1 4 7 常见的用途：\n新建一系列目录：mkdir {2007..2009}-{01..12}。 用于 for 循环：for i in {1..4}。 ### 拓展 Bash 将美元符号 $ 开头的词视为变量。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $SHELL /bin/bash [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${SHELL} /bin/bash ${!string*} 或 ${!string@} 返回所有给定字符串 string 的变量名。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo ${!S*} SECONDS SHELL SHELLOPTS SHLVL SSH_CLIENT SSH_CONNECTION SSH_TTY $(...) 拓展 $(...) 可以拓展为另外一个命令的运行结果。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $(ls $(pwd)) dockerPratic file.txt foo go minikube-1.31.0-bp156.1.10.x86_64.rpm mysql80-community-release-el7-5.noarch.rpm nginx snap testdir $((...)) 可以拓展成整数运算的结果。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $((1+2)) 3 [[:class:]] 拓展 [[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。\n[[:alnum:]]：匹配任意英文字母与数字 [[:alpha:]]：匹配任意英文字母 [[:blank:]]：空格和 Tab 键。 [[:cntrl:]]：ASCII 码 0-31 的不可打印字符。 [[:digit:]]：匹配任意数字 0-9。 [[:graph:]]：A-Z、a-z、0-9 和标点符号。 [[:lower:]]：匹配任意小写字母 a-z。 [[:print:]]：ASCII 码 32-127 的可打印字符。 [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。 [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。 [[:upper:]]：匹配任意大写字母 A-Z。 [[:xdigit:]]：16进制字符（A-F、a-f、0-9）。 Bash 引号和转义 Bash 的数据类型只有字符串，所以与字符串相关的引号和转义就很重要。\n转义 一般我们用 \\ 来进行转义，当然，如果一些命令过长可以用 \\ 来进行换行。\n\\b：退格。 \\n：换行。 \\r：回车。 \\t：制表符。 单引号与双引号 与单引号不同的是，在双引号中，美元符号（$）、反引号（`` ）和反斜杠（`）会被自动拓展。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo \u0026#34;$(date)\u0026#34; Wed Apr 24 23:50:35 CST 2024 因为双引号把换行符解释为普通字符，所以可以利用双引号在命令行输入多行文本。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo \u0026#34;hello \u0026gt; Yikuanzz\u0026#34; hello Yikuanzz 此外，双引号一般用于处理文件名包含空格的文件。\n当然，双引号还可以保存原始命令的输出格式。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo $(cal) April 2024 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 [root@iZ7xvfomazz4187zib4aurZ test]# echo \u0026#34;$(cal)\u0026#34; April 2024 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Here 文档 Here 文档（here document）是一种输入多行字符串的方法，它以 \u0026lt;\u0026lt; token 作为开始标记，以 token 作为结束标记。\n[root@iZ7xvfomazz4187zib4aurZ test]# \u0026lt;\u0026lt; _EOF_ \u0026gt; Hello \u0026gt; Yikuanzz \u0026gt; _EOF_ 注意，在 Here 文档内部会发生变量替换和通配符拓展，但是单引号和双引号都会失去语法作用。\n如果你不想发生变量替换和通配符拓展，那么就把 token 用单引号引起来：'token'。\nHere 文档的一种变体：Here 字符串（Here string），使用三个小于号（\u0026lt;\u0026lt;\u0026lt;）表示。\n[root@iZ7xvfomazz4187zib4aurZ test]# cat \u0026lt;\u0026lt;\u0026lt; \u0026#34;Hello Yikuanzz\u0026#34; Hello Yikuanzz Bash 变量 Bash 变量主要有环境变量和自定义变量两种。\n环境变量就是 Bash 环境自带的一些变量：\n[root@iZ7xvfomazz4187zib4aurZ test]# printenv XDG_SESSION_ID=17169 HOSTNAME=iZ7xvfomazz4187zib4aurZ TERM=xterm SHELL=/bin/bash HISTSIZE=1000 SSH_CLIENT=119.133.4.44 3586 22 SSH_TTY=/dev/pts/0 USER=root LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36: MAIL=/var/spool/mail/root PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/var/lib/snapd/snap/bin:/root/bin PWD=/home/test LANG=en_US.UTF-8 HISTCONTROL=ignoredups SHLVL=1 HOME=/root LOGNAME=root XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop SSH_CONNECTION=119.133.4.44 3586 172.16.195.53 22 LESSOPEN=||/usr/bin/lesspipe.sh %s XDG_RUNTIME_DIR=/run/user/0 _=/usr/bin/printenv OLDPWD=/home 创建变量 用户创建变量语法为 variable=value，变量名必须遵守下面的规则：\n字母、数字和下划线字符组成。 第一个字符必须是一个字母或一个下划线，不能是数字。 不允许出现空格和标点符号。 [root@iZ7xvfomazz4187zib4aurZ test]# b=$(pwd) 读取变量 在变量名前使用 $ 就能够读取变量名的值。\n[root@iZ7xvfomazz4187zib4aurZ test]# echo $b /home/test 这里要注意的是如果变量的值也是变量，可以用 ${!varname} 的语法将其展开获得最终的值。\n删除变量 unset 命令用来删除一个变量。\n[root@iZ7xvfomazz4187zib4aurZ test]# unset b [root@iZ7xvfomazz4187zib4aurZ test]# echo $b [root@iZ7xvfomazz4187zib4aurZ test]# 输出变量 export 用来向子 Shell 输出变量。\n[root@iZ7xvfomazz4187zib4aurZ ~]# NAME_=Yikuanzz [root@iZ7xvfomazz4187zib4aurZ ~]# export NAME_ 特殊变量 $? 为上一个命令的退出码，用来判断上个命令是否执行成功。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $? 127 $$ 为当前 Shell 的进程ID，当然它一般用来命名临时文件比如 LOGFILE=/tmp/output_log.$$。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $$ 30290 [root@iZ7xvfomazz4187zib4aurZ ~]# bash [root@iZ7xvfomazz4187zib4aurZ ~]# echo $$ 30855 $_ 为上一个命令的最后一个参数。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $_ /etc/bashrc $! 为最近一个后台执行的异步命令的进程 ID。\n[root@iZ7xvfomazz4187zib4aurZ ~]# bash \u0026amp; [1] 31071 [root@iZ7xvfomazz4187zib4aurZ ~]# echo $! 31071 [1]+ Stopped bash $0 为当前 Shell 的名称。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $0 bash $- 为当前 Shell 的启动参数。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo $- himBH $@ 和 $# 表示脚本的参数数量。\n变量默认值 Bash 提供了特殊的语法来保证变量不为空：\n${varname:-word} 表示如果变量 varname 存在且不为空，则返回它的值，否则返回word。 ${varname:=word} 表示如果变量 varname存在且不为空，则返回它的值，否则将它设为word。 ${varname:+word} 如果变量名存在且不为空，则返回word，否则返回空值。 ${varname:?message} 如果变量 varname存在且不为空，则返回它的值，否则打印出 varname: message，并中断脚本的执行。如果省略了 message，则输出默认的信息“parameter null or not set.”。 上面四种语法如果用在脚本中，变量名的部分可以用到数字 1到 9，表示脚本的参数。\n比如：filename=${1:?\u0026quot;filename missing.\u0026quot;}。\n上面代码出现在脚本中，1表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。\ndeclare 命令 declare 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。\n它的语法就是：declare OPTION VARIABLE=value。\ndeclare命令的主要参数（OPTION）如下。\n-a：声明数组变量。 -f：输出所有函数定义。 -F：输出所有函数名。 -i：声明整数变量。 -l：声明变量为小写字母。 -p：查看变量信息。 -r：声明只读变量，不能 unset。 -u：声明变量为大写字母。 -x：该变量输出为环境变量，等同于 export 命令。 declare命令如果用在函数中，声明的变量只在函数内部有效，等同于 local命令。\n下面是一些例子：\n-i 声明变量为整数。\n[root@iZ7xvfomazz4187zib4aurZ ~]# declare -i v1=12 v2=3 [root@iZ7xvfomazz4187zib4aurZ ~]# declare -i res [root@iZ7xvfomazz4187zib4aurZ ~]# res=v1*v2 [root@iZ7xvfomazz4187zib4aurZ ~]# echo $res 36 -u 可以自动将变量转成大写字母。\n[root@iZ7xvfomazz4187zib4aurZ ~]# declare -u v3 [root@iZ7xvfomazz4187zib4aurZ ~]# v3=upper [root@iZ7xvfomazz4187zib4aurZ ~]# echo $v3 UPPER readonly 命令 readonly命令等同于 declare -r，用来声明只读变量，不能改变变量值，也不能 unset变量。\n[root@iZ7xvfomazz4187zib4aurZ ~]# readonly v4=1 [root@iZ7xvfomazz4187zib4aurZ ~]# v4=2 bash: v4: readonly variable readonly命令有三个参数。\n-f：声明的变量为函数名。 -p：打印出所有的只读变量。 -a：声明的变量为数组。 let 命令 let命令声明变量时，可以直接执行算术表达式。\n[root@iZ7xvfomazz4187zib4aurZ ~]# let v5=1+2+3 [root@iZ7xvfomazz4187zib4aurZ ~]# echo $v5 6 let 命令还可以对多个变量进行赋值。\n[root@iZ7xvfomazz4187zib4aurZ ~]# let \u0026#34;r1=2\u0026#34; \u0026#34;r2 = r1++\u0026#34; [root@iZ7xvfomazz4187zib4aurZ ~]# echo $r1,$r2 3,2 Bash 函数 函数（function）是可以重复使用的代码片段，有利于代码的复用。\n函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。\n如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。\n简单定义 函数定义的语法有两种：\n# 第一种 fn() { # codes } # 第二种 function fn(){ # codes } 比如，我们在 Shell 中写下这样一个函数 hello() { echo \u0026quot;Hello $1\u0026quot;}。\n那么我们在命令行中调用它，就会是这样的。\n[root@iZ7xvfomazz4187zib4aurZ bin]# hello(){ \u0026gt; echo \u0026#34;Hellp $1\u0026#34; \u0026gt; } [root@iZ7xvfomazz4187zib4aurZ bin]# hello world Hellp world 如果我们想删除一个函数，可以用 unset 命令，它的语法是这样的 unset -f functionName。\n我们还可以用 declare -f 查看已经定义好的所有函数。\n参数变量 函数的参数变脸，与脚本参数变量是一致的。\n$1 ~ $9：函数的第一个到第9个的参数。 $0：函数所在的脚本名。 $#：函数的参数总数。 $@：函数的全部参数，参数之间使用空格分隔。 $*：函数的全部参数，参数之间使用变量 $IFS值的第一个字符分隔，默认为空格，但是可以自定义。 如果函数的参数多于9个，那么第10个参数可以用 ${10}的形式引用，以此类推。\n#!/usr/bin/env bash function log_msg{ echo \u0026#34;[ `date \u0026#39;+ %F %T\u0026#39;` ]: $@\u0026#34; } return 命令 return 命令用于从函数返回一个值，函数执行到这条命令后，就不再继续执行，直接返回。\n假设我们有这个函数 function func_return_value { return 10 }，调用之后我们可以用 $? 拿到返回值 func_return_value; echo \u0026quot;Value returned by function is: $?\u0026quot;。\n全局变量和局部变量 与其他语言有区别的是，Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。\n#!/usr/bin/env bash fn () { foo=1 echo \u0026#34;fn: foo = $foo\u0026#34; } fn echo \u0026#34;global: foo = $foo\u0026#34; 我们可以在函数里面使用 local 命令来声明局部变量。\n#!/usr/bin/env bash fn () { local foo foo=1 echo \u0026#34;fn: foo = $foo\u0026#34; } fn echo \u0026#34;global: foo = $foo\u0026#34; Bash 数组 数组（array）就是我们所熟悉的那个数组，当然它更像一个列表，元素的下标也是从 0 开始的。\n创建数组 我们通过赋值的方法创建数组。\n# 逐个赋值 array[0]=val array[1]=val array[2]=val # 一次性赋值 ARRAY=(value1 value2 ... valueN) 此外，我们创建数组的时候可以在每个值前面指定位置。\ndays=(Sun Mon Tue Wed Thu Fri Sat) days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat) 或者为某些值指定位置，也是可以的。\nnames=(hatter [5]=duchess alice) hatter 是数组的 0 号位置，duchess 是 5 号位置，alice 是 6 号位置。\n定义数组的时候，可以使用通配符。\nmp3s=( *.mp3 ) 另外的方式有 declare -a ARRARYNAME 和 read -a ARRARYNAME。\n读取数组 读取数组指定位置的成员，使用 ${array[i]}。\n如果我们想读取所有成员的话，需要用到 @ 和 * 的特殊索引，比如 ${array[@]}。\n当我们配合 for 循环语句执行的时候，@ 和 * 是有差别的，差别就在于双引号。\n#!/usr/bin/env bash names=( Mike \u0026#34;Glibe robot\u0026#34; Tim \u0026#34;Jame Hardon\u0026#34; susan) for name in ${names[@]}; do echo \u0026#34;Name: $name\u0026#34; done 如果使用 @ 并且不使用 \u0026quot;\u0026quot; 的话，它的输出会是这样的。当然，使用 * 的话是一样的。\n[root@iZ7xvfomazz4187zib4aurZ bin]# source name.sh Name: Mike Name: Glibe Name: robot Name: Tim Name: Jame Name: Hardon Name: susan 如果使用 @ 并且使用 \u0026quot;\u0026quot; 的话，它的输出会是这样的。\n[root@iZ7xvfomazz4187zib4aurZ bin]# source name.sh Name: Mike Name: Glibe robot Name: Tim Name: Jame Hardon Name: susan 如果用 * 并且用 \u0026quot;\u0026quot; 的话，它的输出就会是这样的，将所有元素变成一个字符串输出。\n[root@iZ7xvfomazz4187zib4aurZ bin]# source name.sh Name: Mike Glibe robot Tim Jame Hardon susan 数组拷贝 如果我们想拷贝一个数组，我们可以这样写：copyArrary=( \u0026quot;${names[$@]}\u0026quot; )。\n数组长度 我们可以用这两种语法：${#array[*]} 和 ${#array[@]}。\n如果我们用这种语法读取成员的话，就会得到成员字符串的长度，比如我们用 ${#a[100]}。\n成员下标 ${!array[@]}或 ${!array[*]}，可以返回数组的成员序号，即哪些位置是有值的。\n[root@iZ7xvfomazz4187zib4aurZ ~]# arr=([5]=a [9]=b [23]=c) [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${!arr[@]} 5 9 23 [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${!arr[*]} 5 9 23 当然，我们也可以通过 for 循环语句来遍历数组。\n此外，我们可以通过切片的方式来去提取数组成员，它的语法是 ${array[@]:position:length}。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]} a b c d [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]:1:3} b c d 追加成员 数组末尾追加成员，可以使用 +=赋值运算符。它能够自动地把值追加到数组末尾。\n[root@iZ7xvfomazz4187zib4aurZ ~]# arr+=(e f g) [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]} a b c d e f g 删除数组 用 unset 命令删除一个数组成员，当然删除成员也可以将这个成员设为空值。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]} a b c d e f g [root@iZ7xvfomazz4187zib4aurZ ~]# unset arr[0] [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]} b c d e f g [root@iZ7xvfomazz4187zib4aurZ ~]# arr[1]=\u0026#39;\u0026#39; [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]} c d e f g 如果我们用 unset ArrayName 命令可以清空整个数组。\n[root@iZ7xvfomazz4187zib4aurZ ~]# unset arr [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${arr[@]} 关联数组 关联数组使用字符串而不是整数作为数组索引。\n[root@iZ7xvfomazz4187zib4aurZ ~]# declare -A colors [root@iZ7xvfomazz4187zib4aurZ ~]# colors[\u0026#34;red\u0026#34;]=\u0026#34;#ff0000\u0026#34; [root@iZ7xvfomazz4187zib4aurZ ~]# colors[\u0026#34;green\u0026#34;]=\u0026#34;#00ff00\u0026#34; [root@iZ7xvfomazz4187zib4aurZ ~]# colors[\u0026#34;blue\u0026#34;]=\u0026#34;#0000ff\u0026#34; Bash 字符串操作 字符串长度 通过 ${#varname} 查看字符串的长度。\n[root@iZ7xvfomazz4187zib4aurZ ~]# echo ${#v3} 5 子字符串 通过 ${varname:offset:length} 来提取子串，这个方法只能对变量进行操作。\n[root@iZ7xvfomazz4187zib4aurZ ~]# NAME=Yikuanzz [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${NAME:0:6} Yikuan [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${NAME: -4:4} anzz 搜索和替换 字符串头部的模式匹配 ${variable#pattern}\t如果 pattern 匹配变量 variable 的开头，则会删除最短匹配的部分，将剩余部分返回。\n${variable##pattern}\t如果 pattern 匹配变量 variable 的开头，则会删除最长匹配的部分，将剩余部分返回。\n[root@iZ7xvfomazz4187zib4aurZ ~]# myPath=/home/cam/book/long.file.name [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${myPath#/*/} cam/book/long.file.name [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${myPath##/*/} long.file.name 我们注意到 ${variable#pattern} 模式下 /*/ 匹配到的是 /home/；而 ${variable##pattern} 模式下 /*/ 匹配到的是 /home/cam/book/ 。\n此外，如果要将头部匹配的部分替换成其他内容，可以用 ${variable/#pattern/string} 的语法。\n[root@iZ7xvfomazz4187zib4aurZ ~]# FF=JPG.JPG [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${FF/#JPG/jpg} jpg.JPG 字符串尾部的模式匹配 ${variable%pattern}\t如果 pattern 匹配变量 variable 的结尾，则会删除最短匹配的部分，将剩余部分返回。\n${variable%%pattern}\t如果 pattern 匹配变量 variable 的结尾，则会删除最长匹配的部分，将剩余部分返回。\n[root@iZ7xvfomazz4187zib4aurZ ~]# path=/home/cam/book/long.file.name [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${path%.*} /home/cam/book/long.file [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${path%%.*} /home/cam/book/long 此外，如果要将尾部匹配的部分替换成其他内容，可以用 ${variable/%pattern/string} 的语法。\n[root@iZ7xvfomazz4187zib4aurZ ~]# FF=JPG.JPG [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${FF/%JPG/jpg} JPG.jpg 任意位置的模式匹配 ${variable/pattern/string}\t如果 pattern 匹配变量 variable 的一部分，最长匹配的那部分会被 string 替换，但仅替换第一个匹配的。\n${variable//pattern/string}\t如果 pattern 匹配变量 variable 的一部分，最长匹配的那部分会被 string 替换，并且所有匹配的部分都会替换。\n[root@iZ7xvfomazz4187zib4aurZ ~]# path=/home/cam/foo/foo.name [root@iZ7xvfomazz4187zib4aurZ ~]# echo $path /home/cam/foo/foo.name [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${path/foo/bar} /home/cam/bar/foo.name [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${path//foo/bar} /home/cam/bar/bar.name 改变大小写 通过 ${varname^^} 语法可以将变量值转为大写。\n通过 ${varname,,} 语法可以将变量值转为小写。\n[root@iZ7xvfomazz4187zib4aurZ ~]# NAME=YikuanZz [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${NAME^^} YIKUANZZ [root@iZ7xvfomazz4187zib4aurZ ~]# echo ${NAME,,} yikuanzz Bash 算术运算 算术表达式 在之前我们有提到使用 ((...)) 语法可以进行整数运算，这意味着我们可以使用加、减、乘、除、取余、指数等等运算。\n此外使用 $((...)) 的语法可以在内部用圆括号改变运算顺序，并且可以使用变量，如果变量不存在会被视为零。\n[root@iZ7xvfomazz4187zib4aurZ ~]# num=123 [root@iZ7xvfomazz4187zib4aurZ ~]# echo $(((num-23)*10)) 1000 数值的进制 Bash 数值默认是十进制，但是在算术表达式中，也可以使用其他进制。\nnumber：没有任何特殊表示法的数字是十进制数（以10为底）。 0number：八进制数。 0xnumber：十六进制数。 base#number：base进制的数。 位运算 $((...))支持以下的二进制位运算符。\n\u0026lt;\u0026lt;：位左移运算，把一个数字的所有位向左移动指定的位。 \u0026gt;\u0026gt;：位右移运算，把一个数字的所有位向右移动指定的位。 \u0026amp;：位的“与”运算，对两个数字的所有位执行一个AND操作。 |：位的“或”运算，对两个数字的所有位执行一个OR操作。 ~：位的“否”运算，对一个数字的所有位取反。 !：逻辑“否”运算 ^：位的异或运算（exclusive or），对两个数字的所有位执行一个异或操作。 逻辑运算 $((...))支持以下的逻辑运算符。\n\u0026lt;：小于 \u0026gt;：大于 \u0026lt;=：小于或相等 \u0026gt;=：大于或相等 ==：相等 !=：不相等 \u0026amp;\u0026amp;：逻辑与 ||：逻辑或 expr1?expr2:expr3：三元条件运算符。若表达式expr1的计算结果为非零值（算术真），则执行表达式expr2，否则执行表达式expr3。 expr 命令 expr 命令支持算术运算和变量替换，但是不支持非整数运算。\nBash 脚本入门 脚本（script）就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。\nShebang 行 脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以#!字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。\n#!后面就是脚本解释器的位置，Bash 脚本的解释器一般是/bin/sh或/bin/bash。\n如果 Bash 解释器不放在目录/bin，脚本就无法执行了。为了保险，可以写成这样：#!/usr/bin/env bash。\n如果没有 Shebang 行，就可能要手动将脚本传给解释器来执行。\nenv 命令 总是指向 /usr/bin/env 文件，或者说这个二进制文件总是在目录 /usr/bin 中。\n#!/usr/bin/env NAME这个语法的意思是，让 Shell 查找$PATH环境变量里面第一个匹配的NAME。如果你不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。\n脚本路径 我们除了要给脚本权限外，还要指定脚本的路径。\n如果我们将脚本放在环境变量 $PATH 指定的目录中，就不需要指定路径了。\n建议在主目录新建一个~/bin子目录，专门存放可执行脚本，然后把~/bin加入到$PATH 的末尾，\n[root@iZ7xvfomazz4187zib4aurZ ~]# export PATH=$PATH:~/bin [root@iZ7xvfomazz4187zib4aurZ ~]# source ~/.bashrc [root@iZ7xvfomazz4187zib4aurZ ~]# echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/var/lib/snapd/snap/bin:/root/bin:/root/bin 脚本参数 在调用脚本的时候，文件名后可以带有参数，比如 script.sh word1 word2 word3。\n脚本文件内部，可以用特殊变量引用这些参数：\n$0：脚本文件名，即 script.sh。 $1~$9：对应脚本的第一个参数到第九个参数。 $#：参数的总数。 $@：全部的参数，参数之间使用空格分隔。 $*：全部的参数，参数之间使用变量 $IFS值的第一个字符分隔，默认为空格，但是可以自定义。 如果脚本的参数多于9个，那么第10个参数可以用 ${10}的形式引用，以此类推。\nshift 命令 可以改变脚本参数，每次执行都会移除脚本当前的第一个参数，让后面的参数向前，以此类推。此外也可以移除多个参数，比如 shift 3 就可以移除前三个参数。\n#!/usr/bin/env bash echo \u0026#34;一共输入了 \u0026amp;# 个参数\u0026#34; while [\u0026#34;$1\u0026#34; != \u0026#34;\u0026#34;]; do echo \u0026#34;剩下 $# 个参数\u0026#34; echo \u0026#34;参数：$1\u0026#34; shift done getopts 命令 用在脚本内部，可以解析复杂的脚本命令行参数，取出脚本所有带有前置连词线 - 的参数。\n语法为 getopts optstring name 其中第一参数为所有连词线参数，第二个参数为变量名用于储存当前取到的配置项参数。\n假设，某个脚本参数有 -l、-h、-a ，其中 -a 是可以带参数的，那么optstring 可以写为 lha:。\nwhile getopts \u0026#39;lha:\u0026#39; OPTION; do case \u0026#34;$OPTION\u0026#34; in l) echo \u0026#34;linuxconfig\u0026#34; ;; h) echo \u0026#34;h stands for h\u0026#34; ;; a) avalue=\u0026#34;$OPTARG\u0026#34; echo \u0026#34;The value provided is $OPTARG\u0026#34; ;; ?) echo \u0026#34;script usage: $(basement $0)[-l][-h][-a somevalue]\u0026#34; \u0026gt;\u0026amp; 2 # 退出值为 0 表示正常；1 表示错误；2 表示用法不对 exit 1 ;; esac done # $OPTIND 在 getopts 前为 1 每次执行都会加 1 shift \u0026#34;$(($OPTIND - 1))\u0026#34; -- 参数终止符 可以让指定变量作为实体参数，而不是配置项参数。\n比如，myPath=\u0026quot;~/docs\u0026quot; ls --$myPath 就会将其作为实体参数解释。\n命令执行结果 命令执行结束后，会有一个返回值。0表示执行成功，非 0（通常是 1）表示执行失败。环境变量 $? 可以读取前一个命令的返回值。\n#!/usr/bin/env bash cd $some_directory if [\u0026#34;$?\u0026#34; = \u0026#34;0\u0026#34;]; then rm * else echo \u0026#34;无法切换目录！\u0026#34; 1\u0026gt;\u0026amp;2 exit 1 fi 更简洁的写法是：\ncd $some_directory \u0026amp;\u0026amp; rm * cd $some_directory || exit 1 source 命令 source 命令用于执行一个脚本，通常用于重新加载一个配置文件。\n比如，source .bashrc。\n它会在当前 Shell 中执行脚本，如果用 bash 则会新建一个 子Shell 来执行。\n因此，用 source执行脚本的话，就可以用当前 Shell 的变量；如果用 bash 的话，就需要将变量 export 到 子Shell 才能使用。\n此外，source 命令的另一个用途是在脚本内部加载外部库。\n比如，source ./lib.sh 或者 ..bashrc。\nalias 命令 alias 命令用来为一个命令指定别名，它的语法是 alias NAME=DEFINITION。\n比如，alias search=grep。\n我们可以通过 alias 命令查看所有别名。\n通过 unalias 命令解除别名。\n","date":"2024-04-22T21:18:58+08:00","image":"https://yikuanzz.github.io/2024/shell%E5%AD%A6%E4%B9%A0/cover_hu87cba6621d1cba6cf29db5a9878ced61_565035_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/shell%E5%AD%A6%E4%B9%A0/","title":"Shell学习"},{"content":"消息队列介绍 消息总线（Message Queue） ，是一种跨进程的通信机制，就是用于在应用程序之间传递消息的中间件。它把消息存储在一个队列中，发送方将消息添加到队列中，而接收方从队列中获取消息。\n在互联网架构中，消息队列是一种常见的上下游”逻辑结构+物理解藕“的消息通信服务。\n[消息发送上游]--\u0026gt;[消息队列]--\u0026gt;[消息接收下游] 优点：\n1、解藕：降低系统各部分之间的依赖，使得系统更易于扩展和维护。 2、异步处理：提高系统性能，减少相应时间。 3、削峰：在高并发情况下，消息队列可以暂存大量的请求。 缺点：\n1、系统复杂性提高：需要考虑消息的重复消费、消息丢失、消息传递的顺序性等等问题。 2、系统可用性降低：需要额外去保证消息队列的高可用。 3、一致性问题：如果消息的真正消费者并没有正确消费消息，可能导致数据不一致的情况。 消息队列场景 【场景一：数据驱动的任务依赖】\n比如，互联网公司需要进行一些数据统计任务，这些任务有一些依赖关系：\n（1）task3 需要使用 task2 的输出作为输入。\n（2）task2 需要使用 task1 的输出作为输入。\n传统方法：根据经验给每个任务预留执行时间，依次执行。但是这样做的话，如果有个任务超过了预留的时间就会很麻烦。\n消息队列方法：在任务一执行完后发送消息，让任务二订阅这个消息，当收到任务一执行完的消息后执行任务二，以此类推。\n【场景二：上游不关心执行结果】\n比如，58同城的很多下游需要关注“用户发布帖子”这个事件，比如招聘用户发布帖子后，招聘业务要奖励58豆，房产用户发布帖子后，房产业务要送2个置顶，二手用户发布帖子后，二手业务要修改用户统计数据。\n传统方法：帖子发布服务执行完成之后，调用下游招聘业务、房产业务、二手业务，来完成消息的通知，但事实上，这个通知是否正常正确的执行，帖子发布服务根本不关注。这样不仅帖子发布流程的执行时间增加了，并且上下游依赖严重。\n消息队列方法：帖子发布成功后，给消息队列发送一个消息，然后下游关注”帖子发送成功“的消息，主动去消息队列订阅。\n【场景三：上游关注执行结果，但执行时间很长】\n比如：微信支付，跨公网调用微信的接口，执行时间会比较长，但调用方又非常关注执行结果。\n传统方法：上游调用微信接口就进入阻塞，等待响应结果的返回。 消息队列方法：上游发送请求给微信接口，当请求收到后立马返回调用成功信息。在请求中写入回调网关，让微信接口将结果返回给网关，然后将消息给到消息队列，然后上游再去订阅。 常用消息队列 RabbitMQ、ActiveMQ、RocketMQ 和 Kafka 的主要特性、优点和缺点的总结：\nRabbitMQ： 主要特性：异步通信，解耦，削峰，支持多种消息广播类型。 优点：性能较好，高并发；吞吐量到万级，MQ 功能比较完备；健壮、稳定、易用、跨平台、支持多种语言、文档齐全；开源提供的管理界面非常棒，用起来很好用；社区活跃度高。 缺点：erlang 开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复 bug，不利于做二次开发和维护；吞吐量会低一些，这是因为他做的实现机制比较重；需要学习比较复杂的接口和协议，学习和维护成本较高。 ActiveMQ： 主要特性：支持任何消息传递用例的能力和灵活性。 优点：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性有较低的概率丢失数据。 缺点：官方社区现在对ActiveMQ 5.x维护越来越少，高吞吐量场景较少使用。 RocketMQ： 主要特性：高吞吐量、低延迟，适用于大规模分布式系统的消息通信。 优点：性能好，高吞吐量，稳定可靠，有活跃的中文社区。 缺点：兼容性上不是太好，社区相对较小，MQ功能简单，消息可能会重复消费影响数据精确度。 Kafka： 主要特性：高吞吐量、低延迟，适用于大规模分布式系统的消息通信。 优点：高吞吐量和低延迟，适用于对性能要求较高的场景；支持分布式部署和扩展，具备较好的可扩展性；提供了丰富的消息模式和功能，如事务消息、顺序消息等。 缺点：复杂性高，需要配置和管理多个节点；由于 Kafka 持久化消息到磁盘，因此它需要占用较多的存储空间，可能导致存储成本的增加；为了确保 Kafka 集群的正常运行，需要进行适当的配置和监控。 ","date":"2024-04-19T10:10:04+08:00","image":"https://yikuanzz.github.io/2024/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/cover_hue62a8c150cedb6b5c53d1c7275165f83_1610847_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0/","title":"消息队列学习"},{"content":"基础技术 问题：\n1、电脑浏览器是如何打开百度的？\n2、游戏客户端是如何连接服务器的？\n3、购物节，电商服务器是如何顶住压力的？\n网络设备 交换机：电脑之间相互通信，移动终端与电脑之间通信。\n网络AP，全称为无线接入点（Wireless Access Point），是无线网络中的核心设备。它的主要作用是将各个无线网络客户端连接到一起，然后将无线网络接入以太网，从而达到网络无线覆盖的目的。\nAP可以分为胖AP和瘦AP：\n胖AP：也称为无线路由器，除无线接入功能外，一般具备WAN、LAN两个接口，支持地址转换（NAT）功能，多支持DHCP服务器、DNS，以及VPN接入、防火墙等安全功能。 瘦AP：也称无线网桥、无线网关，此无线设备的传输机制相当于有线网络中的集线器，在无线局域网中不停地接收和传送数据；任何一台装有无线网卡的PC或者移动终端均可通过AP来使用有线局域网络甚至广域网络的资源。 路由器：连接不同网络。\nIP 地址 IP地址：用于 IP 报文在网络中的寻址，也用于标识一个节点。\nIP 地址 = 网络位 + 主机位。例如：192.168.1.1，该 IP 地址的网络位是 192.168.1 也就是它的网段。\n子网掩码 决定了 网络位 的长度。例如：192.168.1.1 的子网掩码为 255.255.255.0 就代表前面的三段为网络位。\nDHCP：自动给设备配置 IP 地址。\nTCP 和 UDP TCP（传输控制协议）和 UDP（用户数据报协议）的区别：\n1、连接：\nTCP 面向连接的传输层协议，传输数据前要建立连接。 UDP 无连接，可以传输数据。 2、服务对象：\nTCP 一对一的两点服务。 UDP 支持一对一、一对多、多对多的交互通信。 3、可靠性：\nTCP 可靠交付数据，数据可以误差错、不丢失、不重复、按需到达。 UDP 尽最大努力交付，不保证可靠交付数据。 4、拥塞控制和流量控制：\nTCP 有拥塞控制和流量控制，保证数据传输的安全性。 UDP 网络拥堵也不会影响其发送速率。 5、首部开销：\nTCP 首部长，开销大。 UDP 首部为 8 字节，固定不变，开销小。 6、传输方式：\nTCP 流式传输，没有边界，但保证顺序和可靠。 UDP 一个包和一个包的发送，有边界，但可能丢包和乱序。 7、分片不同：\nTCP 数据大于 MSS 大小，就会在传输层切片，目标主机收到后再组装。 UDP 数据大于 MTU 就会在 IP 层切片，目标主机收到后再组装。 MSS(最大分段大小)：TCP 报文段中 TCP 数据字段的最大大小，它的值为 MSS 值减去 IPv4 Header(20 Btye) 和 TCP header(20 Btye) 得到。能被装入 MTU 中。\nMTU(最大传输单元)：数据链路层传输的帧大小，也就是网络链路中能够传输的最大数据包大小。\nCDN CDN（Content Delivery Network，内容分发网络） 是一个分布在不同地理位置的服务器群，用于缓存靠近最终用户的内容。CDN 可以快速传输加载互联网内容所需的资产，包括 HTML网页、JavaScript文件、样式表、图像和视频。\nCDN 的工作步骤是这样的：\n1、缓存内容：CDN 将源站的资源缓存到位于全国各地的 CDN 节点上。\n2、用户请求资源：当用户请求某个网站或服务的资源时，请求会被路由到最近的 CDN 节点。\n3、返回缓存资源：如果 CDN 节点有用户请求的资源缓存，就会返回缓存的资源给用户。\n4、负载均衡：CDN 会将用户的请求分发到不同的服务器。\n5、安全保护：CDN 提供 DDos 防护、改善安全证书及其他优化。\n案例：配置 IP 地址 配置两台路由器的 IP 地址，让其可以进行通信。\n我们在 eNSP 中选择路由器 AR2220 和 电线，让两个路由器的 GE 0/0/0 端口相连。\n输入系统视图命令后，才能对设备进行配置：\nsystem-view 然后我们进入端口：\ninterface GigabitEthernet 0/0/0 之后就可以配置地址了：\nip address 192.168.1.1 255.255.255.0 这样我们就把 RTA 路由 0/0/0 端口的 IP 地址配置完成了。\nRTB 路由的配置就是镜像操作了。\n接下来我们测试一下它们是否连接上：\nping 192.168.1.2 DHCP 我们可以用 DHCP 来进行网络 IP 地址的自动配置。\nDHCP 是动态主机配置协议（Dynamic Host Configuration Protocol）的缩写。它是一种网络协议，用于自动为计算机或设备分配 IP 地址、子网掩码、默认网关以及其他网络配置。开启 DHCP 意味着网络中的设备可以自动获取 IP 地址和其他网络配置，而不需要手动配置。这样，网络管理变得更加简化和自动化，减少了出错的可能性，并且减轻了网络管理员的工作负担。\n我们给路由器配上地址：192.168.1.1。\n然后我们点开 PC 机设置 DHCP 自动配置地址，但是因为我们没有开启 DHCP 的功能，所以事实上主机并没有分配有地址。\n我们要做的是，将路由器视为服务器让它为主机们分配 IP 地址。\n我们在路由器中输入命令，打开 DHCP 的功能：\ndhcp enable 然后我们需要指定路由器的哪些接口要实现 DHCP 功能。\nDNS 这里，如果我们想要 ping 通网络域名的话，就需要 DNS 服务器来实现域名解析，将网址变成 IP 地址。\nDNS (Domain Name System，域名系统）将域名解析为 IP 地址的系统。\n我们在 eNSP 中使用 Server 让它实现 DNS 服务，当它接入网络的时候也要给它配置地址，我们配置它的地址为 192.168.1.100。\n这时候，我们还要给路由器指定 DNS 服务器:\ndhcp server dns-list 192.168.100 现在我们的 PC 机就有 DNS 服务器地址了\nGateway 顺着这个案例，我们看一下网关。\n网关（Gateway）用于连接不同网络或协议之间进行数据转发和处理。\n首先，我们让路由器连接一个主机，并配置主机 IP 为：100.100.100.100，网关为：100.100.100.1。\n因为 PC 之间所在的网段不同，所以需要路由器作为网关连接这两个网段。\n接下来，我们给路由器配置 100.100.100.1 的地址，这样我们不同网段之间的电脑就能 ping 通了。\n而路由器能实现不同网段之间的相连，主要依赖路由器中的路由表，它记录去往不同地址的接口。\n# 查看 ip 路由表 display ip routing-table # 查看目标 ip display ip routing-table 100.100.100.100 案例：配置静态路由 当我们配置好 IP 地址后，发现无法从 PC1 连通到 Server 1。\n因为，我们发现 AR1 的路由表上没有去往 192.168.3.10 的接口位置。\n为了让数据能够成功转发，所以我们手动添加路由的接口位置。\n# 通过 192.168.2.10 去往 192.168.3.0 这个网段的路由 ip route-static 192.168.3.0\t255.255.255.0 192.168.2.10 # 通过 192.168.2.1 去往 192.168.1.0 这个网段的路由 ip route-static 192.168.1.0\t255.255.255.0 192.168.2.1 网安技术 VLAN 虚拟局域网 VLAN（Virtual Local Area Network） 就是虚拟局域网，它将一个物理的局域网在逻辑上划分成多个广播域。它的目的是为了提高安全性、控制流量和简化网络架构，。\n我们让这两台电脑放入不同的 VLAN 中，实现隔离，就需要配置交换机。\n步骤就是创建 VLAN，然后再将这两台电脑放入不同的 VLAN 之中。\n# 创建 VLAN 10 VLAN 10 # 创建 VALN 20 VLAN 20 # 查看交换机上的 VLAN display vlan 所有机器开机时，都默认存在于 VLAN1 中，VLAN10 和 VLAN20 都是我们后来创建的。\n接下来，我们就要将对应的接口放入 VLAN 中就好了。\n交换机的接口模式：\n1、Access模式：只能属于一个 VLAN，当交换机收到来自某个端口的数据帧时，他会自动地添加一个 VLAN 标签，然后转发。\n2、Trunk模式：允许多个 VLAN 通过，用于交换机与交换机之间连接。当交换机收到某个端口的数据帧时，不会添加 VLAN标签，而是检查数据帧是否包含 VLAN，没有就要手动配置。\n3、Hybrid模式：允许多个 VLAN 通过，既可用于交换机连接和用户计算机之间的连接。允许多个 VLAN 的报文不打标签，只允许省却 VLAN 报文不打标签。\n# 将 0/0/1 接口放入 VLAN10 port link-type access port default vlan 10 # 将 0/0/2 接口放入 VLAN20 port link-type access port default vlan 20 接下来，我们再看一下 Trunk 模式下的案例。\n我们给第一个交换机的 0/0/3 接口配置 Trunk 模式。\nport link-type trunk port trunk allow-pass vlan all 然后再给第二个交换机的 0/0/1 接口配置 Trunk 模式。\n最后，再给其他端口配置虚拟局域网就可以了。\n三层交换技术 接下来，我们需要了解的技术是三层交换技术，它能让 VLAN 之间相互通信。\n它的原理是，在二层交换机上配置网关，让机器通过网关转发信息到另外一个机器上。\n首先就是在 LSW1 交换机中，配置 VLAN10 和 VLAN 20，并且更改接口的 VLAN。\n当然，每个 VLAN 要配置好网关，VLAN10 配置网关为 1.1.1.254 而 VLAN 20 配置网关为 2.2.2.254。\n# 配置 VLAN10 网关 interface Vlanif 10 ip address 1.1.1.254 255.255.255.0 # 配置 VLAN20 网关 interface Vlanif 20 ip address 2.2.2.254 255.255.255.0 单臂路由技术 除了，三层交换技术以外，单臂路由技术也能实现 VLAN 之间的相互通信。\n单臂路由就是用一台路由器实现两个 VLAN 之间的通信。其原理就是将路由器的一个接口分为多个子接口作为 VLAN 的网关。\n# 将路由器物理接口变成子接口 int g 0/0/0.10 # 让 VLAN 跟子接口相关联 dot1q termination vid 10 # 并允许 ARP 的广播 arp broadcast enable # 配置网关地址 ip address 1.1.1.254 # 查看当前接口下的命令 dis this ACL 访问控制列表 访问控制列表（Access Control List，ACL）是网络安全机制，用于定义和实施对网络资源或系统对象的访问权限。ACL 可以精确控制哪些主题能够对待客体执行何种操作。\n我们做一个小例子，就是有三个 VLAN ，分别是 VLAN10、VLAN20 和 VLAN 30。我们通过 ACL 让 VLAN20 能访问 VLAN 30，而 VLAN 10 不能访问 VLAN 30。\n步骤一：创建访问控制规则；\n步骤二：调用这个规则。\n# 创建规则并使用高级 ACL acl name test advance # 基于IP地址拒绝访问 # 注意：ACL 的掩码要反着写 rule deny ip source 192.168.10.0 0.0.0.255 destination 192.168.30.0 0.0.0.255 # 允许其他数据包的发送 rule permit ip source any destination any # 在数据包必经过的接口调用规则 int g 0/0/1 traffic-filter inbound acl name test # 查看规则 display acl all 进阶技术 NAT 转换 如何连接互联网？\n1、写省却路由。 2、NAT 网络地址转换。 省却路由：被称为默认路由，是路由表中一种特殊的静态路由。它的网络地址和掩码都是 0，可以匹配任意目标网络前缀。\nNAT 网络地址转换：它是一种 IP 数据报文头中的 IP 地址转换为另一个 IP 地址的过程，用于实现内部网络（私有IP）访问外部网络（公有IP）的功能。\n我们常见的私网地址有：192.168.x.x、10.x.x.x、172.16.x.x ~ 172.31.x.x。\n我们的做个小例子，就是让私网的电脑通过 NAT 地址转换能访问公网的路由器。\n# 查看路由表 display ip routing-table # 选择数据包做地址转换 acl name neiwang basic rule permit source 192.168.1.0\t0.0.0.255 # 查看 ACL 编号 dis acl all # 建立 NAT 地址 # 用 64.1.1.2 ~ 64.1.1.6 公网 IP 进行访问 nat address-group 1 64.1.1.2 64.1.1.6 # 在出口调用 NAT 规则 int g 0/0/1 nat outbound 2999 address-group 1 上述的例子，是 NAT 动态分配地址。接下来，我们看一下静态 NAT 分配地址。\n如果有一台电脑想从外网访问内网中的一台服务器，就需要给这台服务器配置静态的地址。\n# 配置路由 # AR1 ip route-static 200.200.200.0 255.255.255.0 119.1.1.2 # AR2 ip route-static 172.16.0.0 255.255.255.0 119.1.1.1 # 配置静态 NAT int g 0/0/1 nat server global 119.1.1.123 inside 172.16.0.1 Telnet 协议 如何远程管理远程设备？\n通过 Telnet 远程管理设备。 Telnel 是一种应用层协议，用于互联网和局域网汇中，使用虚拟终端的形式提供双向、以文本字符串为主的命令行界面交互。\n其中，Cloud1 为我们的本地主机，而 AR1 为远程路由器。\n我们需要配置一下 Cloud1 的信息和我们的网卡地址。\n可以看到我们为选择了 VMnet8 作为主机的网卡，接下来我们给 VMnet8 配置一个地址为 100.1.1.1，掩码为 255.0.0.0。\n然后，给路由器接口配置地址为 100.100.100.100，掩码为 255.0.0.0。\n这样，我们的主机就已经可以 ping 通路由器了。\n接着，我们要在路由器中启动 telnet 服务。\n# 开启 5 个虚拟连接 意味着有 5 个用户可以同时连接 user-interface vty 0 4 # 添加验证模式 # aaa: 用户名 + 密码\tpassword: 密码 authentication-mode aaa # 设置用户名和密码 aaa local-user testuser password cipher 123456 # 给用户设置权限 local-user testuser privilege level 15 # 给用户设置用途 local-user testuser service-type telnet # 允许启动 telnet telnet server enable 综合实践 项目简述 1、网络中有三个不同部分，可以自动获取地址。 2、各个部分可以相互访问，也可以访问服务器。 3、PC1 不能访问互联网，PC2 和 PC3 可以。 4、内网服务器对外地址是 www.yikuanzz.com ，所有电脑可以访问。\n项目实践 1、对于 PC2 和 PC3 分别为它们创建 VLAN 10 和 VLAN 20，并将接口放入对应的 VLAN 中，然后也要将另外一个接口设置为 trunk 模式。\n2、在三层交换机上，配置 VLAN 的网关，让 VLAN 之间能够相互进行访问，同时我们打开 DHCP 功能。\n3、我们给内网的 DNS 服务器配置好地址和网关，并加入网址的域名解析。\n4、给三层交换机与路由器的接口配置地址，让它们可以进行通信，但注意要新建一个 VLAN ，将地址配置到这个 VLAN 上去。\n5、给三层交换机配置到外网的静态路由，当然也要给路由器写下一跳的静态路由。\n6、在路由器上配置 NAT 地址转换，这样内网主机就能 ping 通外网了。\n7、这里最后配置一些 ACL 规则，拒绝 PC1 所在的 VLAN1 请求就可以了。\n","date":"2024-04-18T20:05:05+08:00","image":"https://yikuanzz.github.io/2024/%E7%BD%91%E7%BB%9C%E6%95%B0%E9%80%9A%E5%85%A5%E9%97%A8/cover_hud6534069964b1be15513fb0788602e96_1276815_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E7%BD%91%E7%BB%9C%E6%95%B0%E9%80%9A%E5%85%A5%E9%97%A8/","title":"网络数通入门"},{"content":"RPC 简单介绍 RPC（Remote Procedure Call） 是远程过程调用协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。它的主要目标是让构建分布式计算（应用）更加容易。\nRPC 采用 客户机/服务器 模式。\n请求程序就是一个客户机，而服务提供程序就是一个服务器。\n它的过程是这样的：\n1、客户机调用进程发送一个有进程参数的调用信息给服务进程。 2、调用信息到达服务机后，服务机计算结果，发送答复信息。 3、客户端调用进程接收答复信息，获取进程结果。 我们应该有一些认知：\n1、如果我们开发简单的应用，用户不多、流量也不大，就用不着 RPC。 2、如果系统访问量变大、业务增多，可以将业务拆分为几个互不关联的应用，分别部署在不同的机器上，我们也用不着 RPC。 3、如果业务越来越多，发现有些功能无法单独划分，于是就将公共逻辑抽取出来，组成独立的 Service 应用。这时，RPC 就能够让 New Service 与 Public Service 进行程序间的高效通信。 RPC 框架原理 一个 RPC 的程序应该有这几个部分：User、User-stub、RPCRuntime、Server-stub、Server。\n粗粒度的过程是：\n1、客户端（User）通过本地调用服务。 2、客户端存根（User Stub）接收请求负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体。 3、客户端 RPCRuntime 实例找到远程服务地址，并将消息通过网络发送给服务端。 4、服务端存根（Server Stub）收到信息后进行反序列化操作（解码）。 5、服务器（Server）根据消息调用服务进行处理，并将处理后的消息返回。 接着，我们再详细看一看 RPC 依赖哪些组件。\nRPC 服务通过 RpcServer 暴露（Export）远程接口方法。\nRPC 客户通过 RpcClient 引入（Import）远程接口方法。\n其中，RPC 框架提供接口的代理实现，实际调用委托给代理 RpcProxy，将封装好的信息交给 RpcInvoker 去实际执行。客户端的 RpcConnector 维持与服务端的通道，并用 RpcProtocal 编码后的信息发送给服务端。\nPRC 服务端通过 RpcAcceptor 接收客户端的请求，用 RpcProtocal 进行解码，然后传给 RpcProcessor 去控制处理调用过程，最后委托 RpcInvoker 执行并返回调用结果。\n1. RpcServer 负责导出（export）远程接口 2. RpcClient 负责导入（import）远程接口的代理实现 3. RpcProxy 远程接口的代理实现 4. RpcInvoker 客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回 服务方实现：负责调用服务端接口的具体实现并返回调用结果 5. RpcProtocol 负责协议编/解码 6. RpcConnector 负责维持客户方和服务方的连接通道和发送数据到服务方 7. RpcAcceptor 负责接收客户方请求并返回请求结果 8. RpcProcessor 负责在服务方控制调用过程，包括管理调用线程池、超时时间等 9. RpcChannel 数据传输通道 RPC 框架核心 服务暴露：远程提供者需要以某种形式提供服务调用相关的信息，包括但不限于服务接口定义、数据结构或者中间态度服务定义文件。\n远程代理对象：服务调用者用的服务实际是远程服务的本地代理。\n通信：RPC 框架可基于 HTTP 或 TCP 协议，Web Service 是基于 HTTP 协议的 RPC，跨平台性很好但不如基于 TCP 协议的 RPC。\nTCP/HTTP：TCP 为传输层协议，HTTP 为应用层协议，越底层越快。 消息 ID：RPC 实际是请求应答模型，长连接方式 TCP 会更加高效，并且定义了消息 ID，可以更容易复用连接。 IO 方式：支持高并发，因此使用异步 IO，就是 NIO。 多连接：因为连接会有发送和接收的缓冲区，如果单连接缓冲不饱和，那么创建多连接，反而增加连接开销。 心跳：连接是由客户端发起建立并维持的。为了保持连接，有必要在 RPC 框架的协议头标记心跳位。 长连接（Long Connector），也称为持久连接，指一个 TCP 连接上可以连续发送多个数据包。如果没有数据包发送，需要发送链路测试包维持连接。\n优点：\n减少 TCP 连接的建立和关闭的消耗：多个 HTTP 请求可以复用同一个 TCP 连接。 减少网络阻塞：省去较多 TCP 建立和关闭操作，就减少了网络阻塞的影响。 减少 CPU 及内存使用：因为不需要经常建立和关闭连接。 缺点：\n系统复杂性提高：需要考虑连接的管理和维护，例如连接的创建、重用和销毁。 资源占用问题：连接数过多，可能会占用过多的系统资源，影响服务端性能和并发数量。 单连接：\n单连接模式下，客户端一次只能连接到一个服务器。 在 RPC 框架中，对外可以暴露异步非阻塞 API。 在 Socket 层面，实现多路复用。 多连接：\n多连接模式下，客户端可以同时连接到多个服务器。 在 RPC 框架中，对外暴露阻塞式 API。 同一个 RPC 连接不能同时被多个线程使用。 心跳：\n心跳是一种定时操作，其中一方（客户端或服务端）会每隔一段固定时间向另一方发送数据包（心跳包或心跳帧）。 心跳就是确认长时间未通信时，互联双方是否在线。 序列化：RPC 的性能受传输方式和序列化的影响。一方面，使用优秀的序列化框架能够提高性能；另一方面，编码内容的信息越少越好，编码规则越简单越好。\n-- 调用编码 -- 1. 接口方法 包括接口名、方法名 2. 方法参数 包括参数类型、参数值 3. 调用属性 包括调用属性信息，例如调用附件隐式参数、调用超时时间等 -- 返回编码 -- 1. 返回结果 接口方法中定义的返回值 2. 返回码 异常返回码 3. 返回异常信息 调用异常信息 除此之外，还需要一些元信息以方便程序编解码以及扩展。\n-- 消息头 -- magic : 协议魔数，为解码设计 header size: 协议头长度，为扩展设计 version : 协议版本，为兼容设计 st : 消息体序列化类型 hb : 心跳消息标记，为长连接传输层心跳设计 ow : 单向消息标记， rp : 响应消息标记，不置位默认是请求消息 status code: 响应消息状态码 reserved : 为字节对齐保留 message id : 消息 id body size : 消息体长度 -- 消息体 -- 采用序列化编码，常见有以下格式 xml : 如 webservie soap json : 如 JSON-RPC binary: 如 thrift; hession; kryo 等 下面是一个 Python 实现的简单 RPC 调用例子：\n# 服务端 Server.py from SimpleXMLRPCServer import SimpleXMLRPCServer def fun_add(a, b): total = a + b return total if __name__ == \u0026#39;__main__\u0026#39;: s = SimpleXMLRPCServer((\u0026#39;0.0.0.0\u0026#39;, 8080)) # 开启xmlrpcserver s.register_function(fun_add) # 注册函数fun_add print \u0026#34;server is online...\u0026#34; s.serve_forever() # 开启循环等待 # 客户端 Client.py from xmlrpclib import ServerProxy # 导入xmlrpclib的包 s = ServerProxy(\u0026#34;http://172.171.5.205:8080\u0026#34;) # 定义xmlrpc客户端 print s.fun_add(2,3) # 调用服务器端的函数 RPC 框架实例 我们实现一个简单的 RPC 框架，这个框架包括一个服务器和一个客户端。\n服务器使用一个字典存储远程调用的函数，客户端通过网络发送函数名和参数来调用函数。\n# 服务器端 import socket import json import threading class Server: def __init__(self, host=\u0026#39;localhost\u0026#39;, port=5000): self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.server.bind((host, port)) self.server.listen(5) self.functions = {} def register_function(self, function): self.functions[function.__name__] = function def handle_client(self, client): while True: data = json.loads(client.recv(1024).decode()) function_name = data[\u0026#39;function_name\u0026#39;] args = data[\u0026#39;args\u0026#39;] result = self.functionsfunction_name client.send(json.dumps(result).encode()) def run(self): while True: client, _ = self.server.accept() threading.Thread(target=self.handle_client, args=(client,)).start() # 客户端 class Client: def __init__(self, host=\u0026#39;localhost\u0026#39;, port=5000): self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.client.connect((host, port)) def call(self, function_name, *args): self.client.send(json.dumps({\u0026#39;function_name\u0026#39;: function_name, \u0026#39;args\u0026#39;: args}).encode()) result = json.loads(self.client.recv(1024).decode()) return result 当然 RPC 还是有很多优化方向的：\n长连接/短连接：如果每次调用 RPC 接口都要开启一个 Socket 建立连接损耗就很多了。 服务端线程池：服务端是单线程的时候，每次都要等一个请求处理完才能 accept 下一个 Socket 连接，如果能用线程池进行处理，就可以同时处理多个 RPC 请求。 服务注册中心：调用服务，就需要先注册一个服务中心，告诉对方服务都有哪些实例。 负载均衡：负责选择多个实例中的其中一个进行调用。 结果缓存：每次查询接口时都一定去服务端查询吗，是否能将一些内容进行缓存。 多版本控制：如果服务端接口修改了，旧的接口可以通过版本号来区分。 异步调用：客户端调用完接口后，不想等待服务端返回，就需要支持异步调用。 停机优化：服务端要停机了，但是还没处理完请求，可以先停止接收新请求，将所有请求处理完毕。 ","date":"2024-04-16T19:31:08+08:00","image":"https://yikuanzz.github.io/2024/rpc-%E5%AD%A6%E4%B9%A0/cover_hu6b9a47690eec077c155fc2fdb333230e_963914_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/rpc-%E5%AD%A6%E4%B9%A0/","title":"RPC 学习"},{"content":"跨域 跨域问题是前端开发常见的一个问题，就是当一个网页或脚本试图请求另一个来源（域名、协议或端口）的资源时会产生的问题。\n原因是：浏览的同源策略。\n同源策略规定了浏览器可进行的操作，如果不同源的网页或脚本没有授权，则无法读取或写入资源。\n一般来说，当以下三个条件同时满足的时候，才会发生跨域问题：\n1、浏览器限制，而不是服务端限制。 2、请求地址的域名或端口和当前访问的域名或端口不一样。 3、发送的是 XHR （XMLHttpRequest）请求。 JSONP JSONP（JSON with Padding）的思想是通过页面上动态创建 \u0026lt;script\u0026gt; 标签，从另一个域加载包含 JSON 数据的外部脚本文件，然后将数据包裹在一个函数调用中返回给客户端。\n具体工作流程是：\n1、客户端定义一个回调函数，将其名称作为参数传递给服务端。 2、服务端收到请求后，将数据包装在回调函数中。 3、服务端将回调函数返回给客户端。 4、客户端执行回调函数，从而获取服务端的回调函数。 // 定义回调函数 function handleResponse(response) { console.log(\u0026#34;Received data: \u0026#34;, response); } // 创建一个新的\u0026lt;script\u0026gt;元素 var script = document.createElement(\u0026#39;script\u0026#39;); // 设置src属性，其中myCallback是服务端期望的回调函数名 script.src = \u0026#39;https://example.com/data?callback=handleResponse\u0026#39;; // 将\u0026lt;script\u0026gt;元素插入到页面中，这将导致浏览器发送请求 document.head.appendChild(script); CORS **CORS（Cross-Origin Resource Sharing，跨资源共享）**允许服务器标识除自己以外的其他源，使得浏览器允许这些资源访问加载自己的资源。\n它的一个核心机制是预检。预检请求是浏览器正式发送跨域请求之前，向服务器发起的一个预先询问的请求，就是询问服务器是否允许它进行跨域请求。\n预检请求报文中 ：\nAccess-Control-Request-Method 告诉服务器所请求的的 HTTP 方法。 Access-Control-Request-Headers 告诉服务器实际请求携带的自定义首部字段。 Access-COntrol-Allow-Methods 告诉服务器所有允许的请求方法。 // JavaScript代码，使用Fetch API发起跨域请求 fetch(\u0026#39;https://example.com/data\u0026#39;, { method: \u0026#39;GET\u0026#39;, // 或者 \u0026#39;POST\u0026#39; headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch((error) =\u0026gt; { console.error(\u0026#39;Error:\u0026#39;, error); }); // Java代码，使用Spring框架设置响应头 import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { @CrossOrigin(origins = \u0026#34;http://localhost:3000\u0026#34;) @GetMapping(\u0026#34;/data\u0026#34;) public String getData() { // 返回一些数据 return \u0026#34;Hello, CORS!\u0026#34;; } } ","date":"2024-04-15T01:49:05+08:00","image":"https://yikuanzz.github.io/2024/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/cover_hu894dda1344dfe8f4bf15f793c519770f_1399068_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","title":"跨域问题"},{"content":"在 C语言中，程序运行时会存在 栈 和 堆 两种不同的内存分配方式。\n接下来，我们从 内存分配方式 、内存地址增长 和 碎片 三个方面来对比 栈 和 堆。\n内存分配方式 栈：系统自动分配和释放，主要存放程序中的实际参数和局部变量。\n堆：程序员自己分配和释放，可以动态拓展和搜索的内存空间，程序调用 malloc、new、free 之类的函数堆大小会变化。\n内存地址增长 栈：向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。\n堆：向着内存地址增长方向增长，从内存地址的低地址向高地址方向增长。\n碎片 栈：因为是连续分配的空间，所以没有碎片问题。\n堆：频繁的 malloc 或 free 会造成内存空间的不连续。\n示例 下面是一个 C++ 代码的例子：\n# include \u0026lt;iostream\u0026gt; using namespace std; void stack_example(){ int stack_var = 10;\t// 局部变量，在栈中分配内存 cout \u0026lt;\u0026lt; \u0026#34;Stack variable: \u0026#34; \u0026lt;\u0026lt; stack_var \u0026lt;\u0026lt; endl; } void heap_example(){ int * heap_var = new int(20);\t// new，在堆中分配内存 cout \u0026lt;\u0026lt; \u0026#34;Heap variable：\u0026#34; \u0026lt;\u0026lt; *heap_var \u0026lt;\u0026lt; endl; delete heap_var;\t// 释放堆内存 } int main(){ stack_example(); heap_example(); return 0; } 注意，当你在堆上分配内存时，需要使用完成后进行释放，否则可能会导致内存泄露的问题。\n内存泄露就是指，你向程序申请内存后没有归还给系统，那么这个对象就会一直占用这块内存。\n拓展：静态变量 全局静态变量和局部静态变量都是存储在静态存储区之中的。\n区别就是，局部静态变量会在函数销毁时依旧驻留在内存中，直到程序结束。\n但是，如果是动态分配的静态变量，它需要在多个内存之间共享并保存值，就会存放在堆区，这样它的生命周期会伴随程序的整个过程。\n比如，我们可以看一个 C++ 的例子：\n# include \u0026lt;iostream\u0026gt; using namespace std; void allocate_static(){ static int* heap_var = new int(20); cout \u0026lt;\u0026lt; \u0026#34;Heap variable：\u0026#34; \u0026lt;\u0026lt; *heap_var \u0026lt;\u0026lt; endl; } int main(){ allocate_static(); return 0; } ","date":"2024-04-12T18:57:08+08:00","image":"https://yikuanzz.github.io/2024/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E6%A0%88%E5%92%8C%E5%A0%86/cover_hu37587a8bd83b25334c034dc21edbfba1_1013347_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%97%B6%E7%9A%84%E6%A0%88%E5%92%8C%E5%A0%86/","title":"程序执行时的栈和堆"},{"content":"Android 介绍 Android 系统架构 Linux内核层，为 Android 设备各种硬件停供底层驱动。\n系统运行库层，通过一些 C/C++ 库为 Android 系统提供主要的特性支持。\n应用框架层，构建程序的各种 API。\n应用层，手机上的各种应用程序。\n四大组件：活动（Activity）、服务（Service）、广播接收器（Broadcast Reciver）和内容提供器（Content Provider）。\nAndroid 项目目录 构建 Android 项目后，会出现一下结构：\n.gradle 和 .idea ：自动生成文件。 app ：存放项目中的代码和资源。 build：主要包含了编译时自动生成的文件。 libs：第三方的 jar 包。 androidTest：编写 Android Test 测试用例。 java：放置 java 代码的地方。 res：项目的一些静态资源等等。 AndroidManifest.xml：整个 Android 项目的配置文件。 test：用来编写 Unit Test 测试用例。 .gitignore ：将指定目录或文件排除在版本控制之外。 app.iml：IDEA 项目自动生成文件。 build.gradle：app 模块的 gradle 构建脚本，指定一些项目构建的相关配置。 proguard-rules.pro：指定项目代码的混淆规则。 build：编译时自动生成的文件。 gradle：gradle wrapper 的配置文件。 .gitignore：将指定目录或文件排除在版本控制之外。 build.gradle：项目全局的 gradle 构建脚本，通常文件中的内容不需要修改。 gradle.properties：全局的 gradle 配置文件，这里配置的属性会影响到项目中所有的 gradle 编译脚本。 gradlew 和 gradlew.bat：CLI 执行 gradle 命令。 HelloWorld.iml：用于标识这是一个 IDEA 项目。 local.properties：用于指定 Android SDK 路径。 settings.gradle：指定项目中引用的模块。 \u0026lt;!-- AndroidMainfest.xml --\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; 其中，\u0026lt;intent-filter\u0026gt; 里面的代码意思是当我们手机点击应用图标的时候，首先启动的就是这个活动。\n而 MainActivity.java 中则是包含了应用中所有能看见的东西。Android 程序一般将逻辑和视图分开，在布局文件中写界面，然后在活动中引入。布局文件在 res/layout 目录下。\npublic class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 引入 activity_main 布局 setContentView(R.layout.activity_main); } } 归纳一下 res 目录下的内容：\n所有 drawabic 开头的文件夹是放图片的。 所有 mipmap 开头的文件是放应用图标的。 所有 values 开头的文件夹是放字符串、样式、颜色等配置的。 layout 文件夹是用来放置布局的。 \u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;Hello, Android!\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; 这里定义了一个应用程序名的字符串，可以通过一下方式进行引用：\n在代码中用 R.string.hello_world 来获取字符串的引用。 在 XML 中通过 @string/hello_world 获得字符串的引用。 详解 build.gradle Gradle 是一个先进的项目构建工具，使用了一种居于 Groovy 的领域特定语言来声明设置，摒弃了传统的 XML 的各种繁琐配置。\n接下来一起看看 app 内的 build.gradle 文件\nplugins { /* com.android.application 应用程序模块：可直接运行 com.android.library 库模块：作为代码依附于别的应用程序模块 */ id(\u0026#34;com.android.application\u0026#34;) } android { /* android 闭包内可以配置构建项目的各种属性 */ namespace = \u0026#34;com.example.myapplication4\u0026#34; compileSdk = 34 // 指定编译版本 defaultConfig { /* defaultCOnfig 闭包对项目更多细节进行配置 */ applicationId = \u0026#34;com.example.myapplication4\u0026#34; // 指定项目包名 minSdk = 24 // 最低兼容版本 targetSdk = 34 // 目标版本 versionCode = 1 // 指定项目的版本号 versionName = \u0026#34;1.0\u0026#34; // 指定项目版本名 testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; } buildTypes { /* buildTypes 闭包用于指定安装文件的相关配置 debug 指定测试版本安装文件的配置 release 指定生成正式版本安装文件的配置 */ release { isMinifyEnabled = false // 是否对项目代码进行混淆 proguardFiles( // 指定混淆使用的规则文件 getDefaultProguardFile(\u0026#34;proguard-android-optimize.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34; // 当前项目可编写的特别混淆规则 ) } } compileOptions { sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 } } dependencies { /* dependencies 指定当前项目所有依赖关系 - 本地依赖、库依赖、远程依赖 */ implementation(\u0026#34;androidx.appcompat:appcompat:1.6.1\u0026#34;) implementation(\u0026#34;com.google.android.material:material:1.9.0\u0026#34;) implementation(\u0026#34;androidx.constraintlayout:constraintlayout:2.1.4\u0026#34;) testImplementation(\u0026#34;junit:junit:4.13.2\u0026#34;) androidTestImplementation(\u0026#34;androidx.test.ext:junit:1.1.5\u0026#34;) androidTestImplementation(\u0026#34;androidx.test.espresso:espresso-core:3.5.1\u0026#34;) } Android 日志工具 Android 中的日志工具类是 Log（android.util.Log），这个类提供了几个方法来打印日志：\nLog.v()：打印最为琐碎的、意义最小的日志信息，对应级别是 verbose。 Log.d()：打印一些调试信息，对应级别为 dubug。 Log.i()：打印一些较为重要的数据，可以分析用户行为的数据，对应级别为 info。 Log.e()：打印错误信息，对应级别为 error。 protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /* 日志 - Log.d() 第一个参数是tag，一般传入类名，用于过滤。 第二个参数是msg，是想要打印的内容。 */ Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;onCreate execute\u0026#34;); } Android 活动 活动（Activity）是一种可以包含用户界面的组件，主要用于用户的交互。\n我们选择 no activity 选项后构建项目，在 ./app/java/com/example/activitytest 目录下新建一个活动。\npublic class FirstActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); } } 然后，我们为活动添加布局。在 ./app/src/main/res 目录下创建 layout 目录，然后新建布局资源。写完布局后，直接将布局引入活动中 setContentView(R.layout.first_layout)。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;!-- 添加一个 Button 如果在 XML 定义 id，使用 @+id/id_name 语法 如果在 XML 引用 id，使用 @id/id_name 语法 match_partent 表示让当前元素和父元素一样的长度 wrap_content 表示当前元素只要能包含里面的内容就行 text 指定元素内显示的内容 --\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Button1\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 注意，所以的活动要在 AndroidMainfest.xml 中进行注册才能生效。当然，我们还需要给程序配置主活动，才能启动应用。\n\u0026lt;!-- AndroidMainfest.xml --\u0026gt; \u0026lt;activity android:name=\u0026#34;.FirstActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; android:label=\u0026#34;This is FirstActivity\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; Toast Toast 可以将一些短小的信息通知个用户，这些信息会在一段时间后自动消失。\n// 获得 Button 实例 Button button1 = (Button) findViewById(R.id.button1); // 注册 Button 监听按钮点击 button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Toast.makeText(FirstActivity.this, \u0026#34;You clicked Button1\u0026#34;, Toast.LENGTH_SHORT).show(); // Activity 类提供了一个 finish() 方法，可以销毁当前活动 finish(); } }); Menu 在 ./app/src/main/res 目录下创建 menu 文件夹。\n\u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id = \u0026#34;@+id/add_item\u0026#34; android:title = \u0026#34;Add\u0026#34;/\u0026gt; \u0026lt;item android:id = \u0026#34;@+id/remove_item\u0026#34; android:title = \u0026#34;Remove\u0026#34;/\u0026gt; \u0026lt;/menu\u0026gt; 然后回到 FirstActivity.java 重写方法，让菜单显示出来。\npublic boolean onCreateOptionsMenu(Menu menu) { // 创建 MenuInflater 对象，调用 inflate() 方法创建菜单 // 第一个参数，指定资源文件创建菜单；第二个参数，指定菜单添加到menu中 getMenuInflater().inflate(R.menu.main, menu); return true; } 此外，出来让菜单显示外，还要让菜单进行响应。\npublic boolean onOptionsItemSelected(@NonNull MenuItem item) { int id = item.getItemId(); if (id == R.id.add_item){ Toast.makeText(this, \u0026#34;You clicked Add\u0026#34;, Toast.LENGTH_SHORT).show(); } else if (id == R.id.remove_item) { Toast.makeText(this, \u0026#34;You clicked Remove\u0026#34;, Toast.LENGTH_SHORT).show(); } return true; } Intent 在 ./app/java/com/example/activitytest 目录下新建第二个活动。\n\u0026lt;!-- second_layout.xml --\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button2\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Button2\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Intent 是 Android 程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。\nIntent 一般用于启动活动、启动服务以及发送广播等场景。\nIntent 有多个构造函数的重载，其中一个是 Intent(Context packageContex, Class\u0026lt;?\u0026gt;cls)，Context 要求提供一个启动活动的上下文，Class 指定想要启动的目标活动。\nActivity 类中提供了 startActivity() 方法专门用于启动活动，它接收一个 Intent 参数。\nButton button1 = (Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); } }); 上述方法为显示 Intent方法，隐式 Intent 则是通过标签指定。\n\u0026lt;action\u0026gt; 标签中指明当前活动可以响应。 \u0026lt;category\u0026gt; 标签包含附加信息，指明当前活动能够响应的 Intent 中还可能带有的 category。 \u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.activitytest.ACTION_START\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; 再对事件进行修改，当然每个 Intent 只能指定一个 action ，却能指定多个 category。\nButton button1 = (Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Intent intent = new Intent(\u0026#34;com.example.activitytest.ACTION_START\u0026#34;); startActivity(intent); } }); 使用隐式 Intent，不仅可以启动自己程序内的活动方法，还可以启动其他程序的活动。\n// 通过浏览器开启网页 Button button1 = (Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(\u0026#34;http://www.baidu.com\u0026#34;)); startActivity(intent); } }); 于此，我们还可以在 \u0026lt;intent-filter\u0026gt; 标签中配置 \u0026lt;data\u0026gt; 标签，用于更精确地指定当前活动能够响应什么类型的数据。\n\u0026lt;!-- AndroidManifest.xml --\u0026gt; \u0026lt;activity android:name=\u0026#34;.ThirdActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter tools:ignore=\u0026#34;AppLinkUrlError\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.VIEW\u0026#34;/\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34;/\u0026gt; \u0026lt;data android:scheme=\u0026#34;http\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; 我们指定了 Intent.ACTION_VIEW 用于展示 ，现在点击按钮后除了可以选择 Browser 外，还可以选择 ActivityTest 来启动活动。\n除此之外，还可以指定其他协议：geo 表示地理位置、tel 表示拨打电话。\n// 可以改为打开拨号 Button button1 = (Button) findViewById(R.id.button1); button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v) { Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(\u0026#34;tel:10086\u0026#34;)); startActivity(intent); } }); 除了进行活动的创建外，我们还要在活动启动的时候传递数据。\n我们在 FirstActivity 中传递数据给 SecondActivity ，然后再在 SecondaActivity 中接收。\n// FistActivity Button button1 = (Button) finViewByID(R.id.button1); button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(FirstActivity.this, SecondActivity.class); String data = \u0026#34;Hello SecondActivity\u0026#34;; intent.putExtra(\u0026#34;extar_data\u0026#34;, data); startActivity(intent); } }) // SecondActivity protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.second_layout); Intent intent = getIntent(); String data = intent.getStringExtra(\u0026#34;extra_data\u0026#34;); // int data = intent.getIntExtra(\u0026#34;extra_data\u0026#34;); assert data != null; Log.d(\u0026#34;SecondActivity\u0026#34;, data); } 当然，我们也可以接收下一个活动销毁时传递的数据。\n// FirstActivity Button button1 = (Button) finViewByID(R.id.button1); button1.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ Intent intent = new Intent(FirstActivity.this, SecondActivity.class); intentActivityResultLauncher.launch(intent); } }); // 处理回调数据 ActivityResultLauncher\u0026lt;Intent\u0026gt; intentActivityResultLauncher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback\u0026lt;ActivityResult\u0026gt;() { @Override public void onActivityResult(ActivityResult result) { if (result.getData() != null \u0026amp;\u0026amp; result.getResultCode() == RESULT_OK){ String returnedData = result.getData().getStringExtra(\u0026#34;data_return\u0026#34;); Log.d(\u0026#34;FirstActivity\u0026#34;, returnedData); } } }); // SecondActivty Button button2 = (Button) findViewById(R.id.button2); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(); intent.putExtra(\u0026#34;data_return\u0026#34;, \u0026#34;Hello FirstActivity\u0026#34;); // RESULT_OK 或 RESULT_CANCELED setResult(RESULT_OK, intent); finish(); } }); 生命周期 Android 中的活动是层叠的，每启动一个活动就会覆盖在原活动之上，我们通过 Back 键销毁最上层的活动，然后下面的一个活动就会重新显示出来。\n其实，Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动集合，这个栈也被称为返回栈（Back Stack）。当我们启动一个活动的时候，它就会进入到任务栈中。\n每个活动在其生命周期中最多可能会有四种状态：运行状态、暂停状态、停止状态和销毁状态。\nActivity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节。\nonCreate()：它会在活动第一次被创建的时候调用，完成初始化操作，比如加载布局、绑定事件等等。 onStart()：在活动由不可见变为可见的时候调用。 onResume()：在活动准备好和用户进行交互的时候调用，这时活动位于返回栈的栈顶，并且处于运行状态。 onPause()：这个方法在系统准备去启动或恢复另一个活动的时候调用，通常在这个方法内释放一些资源以及保存一些关键数据。 onStop()：在活动完全不可见的时候调用。 onDestroy()：在活动销毁前调用。 onRestart()：在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。 上面的方法除了 onRestra() 方法外，两两相对。\n完整生存周期。在 onCreate() 方法中完成初始化操作，在 onDestroy() 方法中释放内存。 可见生存期。在 onStrat() 方法中对资源进行加载，在 onStop() 方法中对资源进行释放。 前台生存期。onResume() 方法和 onPause() 方法就是用来与用户接触的。 开始实战，新建一个 ActivityLifeCycleTest 项目，然后新建两个活动，它们的布局如下：\n\u0026lt;!-- normal_layout --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;This is a normal activity\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- dialog_layout --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;This is a dialog activity\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后我们在 AndroidManifest.xml 中修改活动，指定其主题为对话框模式。\n\u0026lt;activity android:name=\u0026#34;.DialogLayoutActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; android:theme=\u0026#34;@style/Theme.AppCompat.Dialog\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt; 此外，我们再调整一下主活动的布局，添加按钮来去启动新的活动。这里的直接展示主活动修改后的代码：\npackage com.example.activitycycletest; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { public static final String TAG = \u0026#34;MainActivity\u0026#34;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button1 = (Button) findViewById(R.id.start_normal_activity); Button button2 = (Button) findViewById(R.id.start_dialog_activity); button1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, NormalLayoutActivity.class); startActivity(intent); } }); button2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, DialogLayoutActivity.class); startActivity(intent); } }); } @Override protected void onStart() { super.onStart(); Log.d(TAG, \u0026#34;onStart\u0026#34;); } @Override protected void onResume(){ super.onResume(); Log.d(TAG, \u0026#34;onResume\u0026#34;); } @Override protected void onPause(){ super.onPause(); Log.d(TAG, \u0026#34;onPause\u0026#34;); } @Override protected void onStop(){ super.onStop(); Log.d(TAG, \u0026#34;onStop\u0026#34;); } @Override protected void onDestroy(){ super.onDestroy(); Log.d(TAG, \u0026#34;onDestroy\u0026#34;); } @Override protected void onRestart(){ super.onRestart(); Log.d(TAG, \u0026#34;onRestart()\u0026#34;); } } 有时候活动停止太久可能因为内存不够而被系统回收了，这样会导致某些重要的数据会丢失，因为当我们回到该活动的时候系统是调用 onCreate() 方法重新创建了活动。\n所以，为了解决这个问题，可以使用 Activity 类提供的 onSaveInstanceState() 回调方法，它可以保证活动被回收前一定会被调用。该方法携带了一个 Bundle 类型的参数，它提供了一系列方法用于保护数据。\n@Override protected void onSaveInstanceState(Bundle outState){ super.onSaveInstanceState(outState); String tempData = \u0026#34;Something you just typed\u0026#34;; outState.putString(\u0026#34;data_key\u0026#34;, tempData); } 我们修改 onCreate() 方法来恢复保存的数据。\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null){ String tempData = savedInstanceState.getString(\u0026#34;data_key\u0026#34;); Log.d(TAG, tempData); } } Intent 还可以和 Bundle 结合来进行使用，比如把要传递的数据给到 Bundle 然后再把 Bundle 给到 Intent，等到了目标活动了之后再取出 Bundle 中的数据。\n活动的启动模式 在实际项目中，我们根据特定的需求为每个活动指定恰当的启动模式，分别有：standard、singleTop、singleTask 和 singleInstance。\n我们可以给 \u0026lt;activity\u0026gt; 标签指定 androod:launchMode 来选择启动模式。\nstandard：为默认的启动模式，在该模式下每启动一个新活动就会在返回栈中入栈，并处于栈顶的位置。然而系统并不在乎其是否独立存在返回栈中，每次启动系统都会创建该活动的一个新的实例。\nsingleTop：在启动活动时，系统如果发现返回栈的栈顶是该活动，则认为可以直接使用，就不会新建一个新的实例了。但如果该活动没有在栈顶，就还是会创建新的实例。\nsingleTask：每次启动该活动时，系统首先会在返回栈中检查是否存在该活动的实例，如果存在则直接使用该实例，并将该活动之上的所有活动全部出栈，否则就创建一个新的实例。\nsingleInstance：该模式下的活动会启用一个新的返回栈来管理活动，这样就可以实现活动的实例共享。\n活动的实践 知道当前是在哪一个活动：\n我们在 AcitivityTest 项目上直接 new 一个 BaseActivity 类，并不用注册，我们让它继承 AppcompatActivity，并重写 onCreate() 方法：\npublic class BaseActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); Log.d(\u0026#34;BaseActivity\u0026#34;, getClass().getSimpleName()); } } 修改 FirstActivity、SecondActivity 和 ThirdActivity 的继承结构，让它们继承 BaseActivity。\n这样我们就可以通过 Logcat 看到我们的活动输出了。\n随时随地退出程序：\n思路就是我们设置一个专门的集合类对所有活动进行管理。\n我们新建一个 ActivityCollector 类作为活动管理器：\npackage com.example.activitytest; import android.app.Activity; import java.util.ArrayList; import java.util.List; public class ActivityCollector { public static List\u0026lt;Activity\u0026gt; activityList = new ArrayList\u0026lt;\u0026gt;(); public static void addActivity(Activity activity){ activityList.add(activity); } public static void removeActivity(Activity activity){ activityList.remove(activity); } public static void finishAll(){ for (Activity activity : activityList){ if (!activity.isFinishing()){ activity.finish(); } } } } 接下来，我们来修改 BaseActivity 中的代码：\npublic class BaseActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); Log.d(\u0026#34;BaseActivity\u0026#34;, getClass().getSimpleName()); ActivityCollector.addActivity(this); } @Override protected void onDestroy(){ super.onDestroy(); ActivityCollector.removeActivity(this); } } 如果你想直接退出程序，就在那个地方调用 ActivityCollector.finishAll() 方法就可以了。\n当然，我们可以在销毁所有活动的代码后再加上杀掉当前进程的代码，以保证程序完全退出：\nandroid.os.Process.killProcess(android.os.Process.myPid()); 启动活动的最佳写法\n我们修改一下 SecondAcitvity 中的代码：\npublic void actionStart(Context context, String data1, String data2){ Intent intent = new Intent(context, SecondActivity.class); intent.putExtra(\u0026#34;param1\u0026#34;, data1); intent.putExtra(\u0026#34;param2\u0026#34;, data2); context.startActivity(intent); } 然后，我们在启动的时候调用该函数就好了：\nSecondActivity.actionStart(FirstActivity.this, \u0026#34;data1\u0026#34;, \u0026#34;data2\u0026#34;); Android 设计 常见控件用法 TextView\n\u0026lt;TextView android:id=\u0026#34;@+id/text_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;This is TextView\u0026#34;/\u0026gt; android:layout_width 和 android:layout_height 用来设置控件的宽和高，通常有三种设置：match_parent、fill_parent 和 wrap_content。 android:text、android:textSize 和 android:textColor 分别用来指定文本的内容、文本大小和文本颜色。字体用 sp 作为单位。 android:gravity 用来指定文字对齐方式，有 top、bottom、left、right、center等等，可以用 ”|“ 来指定多个值。 Button\n\u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;This is Button\u0026#34;/\u0026gt; Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 点击后的事务逻辑 } }); EditText\n\u0026lt;EditText android:id=\u0026#34;@+id/edit_text\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;Type something here\u0026#34; android:maxLines=\u0026#34;2\u0026#34;/\u0026gt; protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button)findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); button.setOnClickListener(this); } public void onClicke(View v){ if (v.getId() == R.id.button){ String inputText = editText.getText().toString(); Toast.makeText(MainActivity.this, inputText, Toast.LENGTH_SHORT).show(); } } android:hint 指定提示性文本。 android:maxlines 指定最大行数，如果内容超出限制，文本就会向上滚动。 ImageView\n\u0026lt;ImageView android:id=\u0026#34;@+id/image_view\u0026#34; android:layout_width=\u0026#34;warp_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:scr=\u0026#34;@drawable/img_1\u0026#34;/\u0026gt; protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button)findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); imageView = (ImageView) findViewById(R.id.image_view); button.setOnClickListener(this); } public void onClicke(View v){ if (v.getId() == R.id.button){ imageView.setImageResource(R.drawable.img_2); } } ProgressBar\n\u0026lt;ProgerssBar android:id=\u0026#34;@+id/progress_bar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; style=\u0026#34;?android:attr/progressBarStyleHorizontal\u0026#34; android:max=\u0026#34;100\u0026#34;/\u0026gt; protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button)findViewById(R.id.button); editText = (EditText) findViewById(R.id.edit_text); imageView = (ImageView) findViewById(R.id.image_view); progressBar = (ProgressBar) findViewById(R.id.progress_bar); button.setOnClickListener(this); } public void onClicke(View v){ if (v.getId() == R.id.button){ if (progressBar.getVisibility() == View.GONE){ progressBar.setVisibility(View.VISIBLE); } else{ progressBar.setVisibility(View.GONE); } } } public void onClicke(View v){ if (v.getId() == R.id.button){ int progress = progressBar.getProgress(); progerss = progress + 10; progressBar.setProgress(progress); } } android:visibility 可以控制控件的现实，它有三个选项：visible、invisible 和 gone。可以通过代码 setVisibility() 方法传入 View.VISIBLE、View.INVISIBLE 和 View.GONE。 style 可以将圆形进度条改为水平进度条。 android:max 给进度条设置最大值，然后在代码中动态地更改进度条的进度。 AlertDialog\npublic void onClicke(View v){ if (v.getId() == R.id.button){ AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this); dialog.setTitle(\u0026#34;This is Dialog\u0026#34;); dialog.setMessage(\u0026#34;Something important.\u0026#34;); dialog.setCancelable(false); dialog.setPositiveButton(\u0026#34;ok\u0026#34;, new DialogInterface.OnClickLisener(){ @Override public void onClick(DialogInterface dialog, int which){ } }); dialog.setNegativeButton(\u0026#34;Cancel\u0026#34;, new DialogInterface.onClickLisener(){ @Override public void onClick(DialogInterface dialog, int which){ } }); dialog.show(); } } ProgressDialog\npublic void onClicke(View v){ if (v.getId() == R.id.button){ ProgressDialog progressDialog = new ProgressDialog(MainActivity.this)； progressDialog.setTitle(\u0026#34;This is ProgressDialog\u0026#34;); progressDialog.setMessage(\u0026#34;Loading...\u0026#34;); progressDialog.setCancelable(true); progressDialog.show(); } } 常见布局 线性布局\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;top\u0026#34; android:text=\u0026#34;Button1\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button2\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:text=\u0026#34;Button2\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button3\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;Button3\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/input_message\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_width=\u0026#34;1\u0026#34; android:hint=\u0026#34;Type something\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; android:orientation 指定排列方向，水平就是参数 vertical，垂直就是参数 horizontal。 android:layout_gravity 指定控件在布局中的对齐方式。 android:layout_weight 属性值为 1，表示在水平方向宽度的占比，因为线性布局会将所有的 layout_weight 加起来然后再比上每个空间的宽度，最后划分控件位置。 相对布局\n\u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:layout_alignParentTop=\u0026#34;true\u0026#34; android:text=\u0026#34;Button1\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:layout_alignParentTop=\u0026#34;true\u0026#34; android:text=\u0026#34;Button2\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button3\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerParent=\u0026#34;true\u0026#34; android:text=\u0026#34;Button3\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button4\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:text=\u0026#34;Button4\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button5\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:text=\u0026#34;Button5\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button3\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerParent=\u0026#34;true\u0026#34; android:text=\u0026#34;Button3\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_above=\u0026#34;@id/button3\u0026#34; android:layout_toLeftOf=\u0026#34;@id/button3\u0026#34; android:text=\u0026#34;Button1\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_above=\u0026#34;@id/button3\u0026#34; android:layout_toRightOf=\u0026#34;@id/button3\u0026#34; android:text=\u0026#34;Button2\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button4\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_below=\u0026#34;@id/button3\u0026#34; android:layout_toLeftOf=\u0026#34;@id/button3\u0026#34; android:text=\u0026#34;Button4\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button5\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_below=\u0026#34;@id/button3\u0026#34; android:layout_toRightOf=\u0026#34;@id/button3\u0026#34; android:text=\u0026#34;Button5\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; android:layout_alignLeft 让一个控件的左边缘和另一个控件的左边缘对齐。 android:layout_alignRight 让一个控件的右边缘和另一个控件的右边缘对齐。 android:layout_alignTop 让一个控件的上边缘和另一个控件的上边缘对齐。 android:layout_alignBottom 让一个控件的下边缘和另一个控件的下边缘对齐。 帧布局\n\u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/text_view\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;right\u0026#34; android:text=\u0026#34;This is a TextView\u0026#34; /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/image_view\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layoit_gravity=\u0026#34;left\u0026#34; android:src=\u0026#34;@ipmap/ic_launcher\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 百分比布局\n在 build.gradle.kts 依赖中添加百分比布局：\nimplementation (\u0026#34;androidx.percentlayout:percentlayout:1.0.0\u0026#34;) 我们修改布局：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.percentlayout.widget.PercentFrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button1\u0026#34; android:text=\u0026#34;Button 1\u0026#34; android:layout_gravity=\u0026#34;left|top\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button2\u0026#34; android:text=\u0026#34;Button 2\u0026#34; android:layout_gravity=\u0026#34;right|top\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button3\u0026#34; android:text=\u0026#34;Button 3\u0026#34; android:layout_gravity=\u0026#34;left|bottom\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button4\u0026#34; android:text=\u0026#34;Button 4\u0026#34; android:layout_gravity=\u0026#34;right|bottom\u0026#34; app:layout_widthPercent=\u0026#34;50%\u0026#34; app:layout_heightPercent=\u0026#34;50%\u0026#34; /\u0026gt; \u0026lt;/androidx.percentlayout.widget.PercentFrameLayout\u0026gt; 自定义控件 我们所使用的控件都是直接或间接继承自 View 的，而所有布局呢又是直接或间接继承自 ViewGroup的。模仿苹果的 title 栏目：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/title_bg\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/title_back\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@drawable/back_bg\u0026#34; android:text=\u0026#34;Back\u0026#34; android:textColor=\u0026#34;#fff\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/title_view\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;Title Text\u0026#34; android:textColor=\u0026#34;#fff\u0026#34; adnroid:textSize=\u0026#34;24sp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/title_edit\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@drawable/edit_bg\u0026#34; android:text=\u0026#34;Edit\u0026#34; android:textColor=\u0026#34;#fff\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;include layout=\u0026#34;@layout/title\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 最后，我们需要将系统自带的标题栏隐藏掉，我们在 OnCreate() 中加入以下代码：\nActionBar actionbar = getSupportActionBar(); if (actionbar != null){ actionbar.hide(); } 上述内容里，我们引入了布局，但是如果要更高效地处理控件响应事件，我们需要通过自定义控件的方式来解决：\npublic TtitleLayout extends LinearLayout{ public TitleLayout(Context context, AttributeSet attrs){ super(context, attrs); // 可以动态地加载布局文件 LayoutInflater.from(context).inflate(R.layout.title, this); // 注册点击事件 Button titleBack = (Button) findViewById(R.id.title_back); Button titleEdit = (Button) findViewById(R.id.title_edit); titleBack.setOnClickListener(new OnClickListener(){ @Override public void onClick(View v){ ((Aticity)getContext).finish(); } }); titleEdit.setOnClickListener(new OnClickListener(){ @Override public void onClick(View v){ Toast.makeText(getContext(), \u0026#34;You clicked Edit button\u0026#34;, Toast.LENGTH_SHORT).show(); } }); } } \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;com.example.uicustomviews.TitleLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 最常用和最难用的控件 ListView 可以展示大量的数据，譬如QQ聊天记录这些长信息。\n\u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;ListView android:id=\u0026#34;@+id/list_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;/LinearLayout\u0026gt; 我们用一个 data 数组来测试，通过适配器来传输完成。\nprivate String[] data = {\u0026#34;Apple\u0026#34;, \u0026#34;Banna\u0026#34;,\u0026#34;Orange\u0026#34;, \u0026#34;Cherry\u0026#34;}; @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter\u0026lt;String\u0026gt; adapter = new ArrayAdapter\u0026lt;String\u0026gt;( MainActivity.this, android.R.layout.simple_list_item_1, data); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); } 当然，如果只是显示文本的 ListView 就太单调了，我们对 ListView 界面进行一些定制。\npublic class Fruit{ private String name; private int imageId; } public Fruit(String name, int imageId){ this.name = name; this.imageId = imageId; } public String getName(){ return name; } public String getImageId(){ return imageId; } 我们为 ListView 的子项指定一个我们定义的布局，在 layout 下新建 fruit_item.xml。\n\u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/fruit_image\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:layout_marginLeft=\u0026#34;10dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/fruit_name\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:layout_marginLeft=\u0026#34;10dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 创建一个自定义的适配器 FruitAdapater 来进行数据的展示：\npublic class FruitAdapter extends ArrayAdapter\u0026lt;Fruit\u0026gt;{ private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List\u0026lt;Fruit\u0026gt; objects){ super(context, textViewResourceId, objects); resourceId = textViewResourceId; } @Override public View getView(int position, View convertView, ViewGroup parent){ Fruit fruit = getItem(position); View view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); furitName.setText(fruit.getName()); return view; } } 接下来我们在 MainActivity 中修改一下我们的代码：\npublic class MainActivity extends AppCompatActivity{ private List\u0026lt;Fruit\u0026gt; fruitList = new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView)findViewById(R.id.list_view); listView.setAdapter(adapter); } private void initFruits(){ for (int i = 0; i \u0026lt; 50; i++){ Fruit apple = new Fruit(\u0026#34;Apple\u0026#34;, R.drawable.apple_pic); fruitList.add(apple); } } } ListView 有很多细节是可以优化的，其中运行效率就是很重要的一点。在 FruitAdapter 的 getView() 方法中，每次都讲布局重新加载了一遍，当 ListView 快速滚动的时候，就会成为性能的瓶颈。\n我们发现 getView() 方法中，有一个 convertView 参数，它用于将之前加载好的布局进行缓存。所以我们修改一下 FruitAdapter 中的代码：\n@Override public View getView(int position, View convertView, ViewGroup parent){ Fruit fruit = getItem(position); View view; if (convertView == null){ view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); } else{ view = convertView; } ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); furitName.setText(fruit.getName()); return view; } 接着，我们的代码还是可以优化的，因为每次 getView() 方法中还是会调用 View 的 findViewById() 方法来获取一次控件的实例。我们可以借助 ViewHolder 来对这部分性能进行优化：\n@Override public View getView(int position, View convertView, ViewGroup parent){ Fruit fruit = getItem(position); View view; ViewHolder viewHolder; if (convertView == null){ view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); viewHolder.fruitImage = (ImageView) view.findViewById(R.id.fruit_image); viewHolder.furitName = (TextView) view.findViewById(R.id.fruit_name); view.setTag(viewHolder); // 存储 ViewHolder } else{ view = convertView; viewHolder = (ViewHolder)view.getTag(); // 重新获取 ViewHolder } viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHodler.fruitName.setText(fruit.getName()); return view; } class ViewHolder{ ImageView fruitImage; TextView fruitName; } 除了数据的展示，ListView 的子项还得有点击的事件，让我们修改下代码：\nprotected void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initFruits(); FruitAdapter adapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(adapter); lsitView.setOnItemClickListener(new AdapterView.OnItemClickListener(){ @Override public void onItemClick(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id){ Fruit fruit = fruitList.get(position); Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); } }); } 更强大的滚动控件 Android 提供了一个更加强大的滚动控件 RecyclerView。\n首先我们需要添加依赖:\nimplementation (\u0026#34;androidx.recyclerview:recyclerview:1.1.0\u0026#34;) 然后我们修改 activity_main.xml 的代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/recycler_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 同样，我们也准备好 Fruit 类 和 fruit_item.xml 文件。\n写下来，我们为 RecyclerView 准备一个适配器：\npackage com.yikuanzz.recyclerviewtest; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; import java.util.List; public class FruitAdapter extends RecyclerView.Adapter\u0026lt;FruitAdapter.ViewHolder\u0026gt; { private List\u0026lt;Fruit\u0026gt; mFruitList; static class ViewHolder extends RecyclerView.ViewHolder{ ImageView fruitImage; TextView fruitName; public ViewHolder(View view){ super(view); fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); } } public FruitAdapter(List\u0026lt;Fruit\u0026gt; fruitList){ mFruitList = fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); ViewHolder holder = new ViewHolder(view); return holder; } @Override public void onBindViewHolder(ViewHolder holder, int position) { Fruit fruit = mFruitList.get(position); Log.d(\u0026#34;F_pos\u0026#34;, String.valueOf(position)); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); } @Override public int getItemCount() { return mFruitList.size(); } } 然后我们修改 MainActivity 的代码：\npackage com.yikuanzz.recyclerviewtest; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.os.Bundle; import android.util.Log; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private List\u0026lt;Fruit\u0026gt; fruitList = new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化数据 initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this); // 将 recyclerView 放入线性布局中 recyclerView.setLayoutManager(linearLayoutManager); FruitAdapter fruitAdapter = new FruitAdapter(fruitList); // 将适配器加载到 recyclerView 中 recyclerView.setAdapter(fruitAdapter); } private void initFruits(){ for (int i = 0; i \u0026lt; 30; i++){ Fruit apple = new Fruit(\u0026#34;Apple\u0026#34;, R.drawable.ff1); fruitList.add(apple); Fruit cherry = new Fruit(\u0026#34;Cherry \u0026#34;, R.drawable.aa1); fruitList.add(cherry); } } } 我们用 RecyclerView 做横向滚动的效果。\n我们将 fruit_item 的布局进行一些修改：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/fruit_image\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/fruit_name\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后我们对 MainActivity 进行一点小修改：\npackage com.yikuanzz.recyclerviewtest; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.os.Bundle; import android.util.Log; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private List\u0026lt;Fruit\u0026gt; fruitList = new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化数据 initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this); // 设置为水平 linearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); // 将 recyclerView 放入线性布局中 recyclerView.setLayoutManager(linearLayoutManager); FruitAdapter fruitAdapter = new FruitAdapter(fruitList); // 将适配器加载到 recyclerView 中 recyclerView.setAdapter(fruitAdapter); } private void initFruits(){ for (int i = 0; i \u0026lt; 30; i++){ Fruit apple = new Fruit(\u0026#34;Apple\u0026#34;, R.drawable.ff1); fruitList.add(apple); } } } 之所以 RecyclerView 能够轻易地完成这些任务，主要还是得益于 LayoutManager ，它提供了一套可拓展的布局排列接口。\n那么除了 LinearLayoutManager 之外，RecyclerView 还给我们提供了 GridLayoutManager 和 StaggeredGridLayoutManager 这两种内置的布局排列方式。GridLayoutManager 用于实现网格布局，StaggeredGridLayoutManager 用于实现瀑布流布局。\n我们这里看一下瀑布流布局是怎么做的。\n首先，我们还是修改一下 fruit_item.xml 中的代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_margin=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/fruit_image\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/fruit_name\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;left\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 接着修改 MainActivity 中的代码：\npackage com.yikuanzz.recyclerviewtest; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import androidx.recyclerview.widget.StaggeredGridLayoutManager; import android.os.Bundle; import android.util.Log; import java.util.ArrayList; import java.util.List; import java.util.Random; public class MainActivity extends AppCompatActivity { private List\u0026lt;Fruit\u0026gt; fruitList = new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化数据 initFruits(); RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view); StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); // 将 recyclerView 放入瀑布布局中 recyclerView.setLayoutManager(staggeredGridLayoutManager); FruitAdapter fruitAdapter = new FruitAdapter(fruitList); // 将适配器加载到 recyclerView 中 recyclerView.setAdapter(fruitAdapter); } private void initFruits(){ for (int i = 0; i \u0026lt; 30; i++){ Fruit apple = new Fruit(getRandomLengthName(\u0026#34;Apple\u0026#34;), R.drawable.ff1); fruitList.add(apple); } } private String getRandomLengthName(String name){ Random random = new Random(); int length = random.nextInt(20)+1; StringBuilder builder = new StringBuilder(); for (int i = 0; i \u0026lt; length; i++){ builder.append(name); } return builder.toString(); } } 除此之外，我们还要给 RecyclerView 设置点击事件。但是 RecyclerView 并没有提供类似于 setOnItemClickListener() 这样注册监听器方法，需要我们自己给子项具体的 View 去注册点击事件。\n接下来，我们修改一下 FruitAdapter 中的代码：\npackage com.yikuanzz.recyclerviewtest; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import android.widget.Toast; import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; import java.util.List; public class FruitAdapter extends RecyclerView.Adapter\u0026lt;FruitAdapter.ViewHolder\u0026gt; { private List\u0026lt;Fruit\u0026gt; mFruitList; static class ViewHolder extends RecyclerView.ViewHolder{ View fruitView; ImageView fruitImage; TextView fruitName; public ViewHolder(View view){ super(view); fruitView = view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); } } public FruitAdapter(List\u0026lt;Fruit\u0026gt; fruitList){ mFruitList = fruitList; } @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); final ViewHolder holder = new ViewHolder(view); holder.fruitView.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), \u0026#34;you clicked view\u0026#34; + fruit.getName(), Toast.LENGTH_SHORT).show(); } }); holder.fruitImage.setOnClickListener(new View.OnClickListener(){ @Override public void onClick(View v){ int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(v.getContext(), \u0026#34;you clicked image\u0026#34; + fruit.getName(), Toast.LENGTH_SHORT).show(); } }); return holder; } @Override public void onBindViewHolder(ViewHolder holder, int position) { Fruit fruit = mFruitList.get(position); Log.d(\u0026#34;F_pos\u0026#34;, String.valueOf(position)); holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); } @Override public int getItemCount() { return mFruitList.size(); } } 界面实战-简单聊天界面 我们创建 UIBaseProject 项目来开始我们的实践。\n开始之前，我们学习一下怎么制作 Nine-Patch 图片。它是一种被处理过的 png 图片，能够指定哪些区域可以被拉伸、哪些区域不可以。\n现在我们有一张图片是 message_left.png\n我们将图片放入 drawable 文件中，然后将图片后缀改为 .9.png，点击后进入图片制作视图。\n然后我们给图像四周画上小黑边来设置可以拖拽延伸到地方。\n我们将图片反转，用同样的方法得到 message_right.9.png。\n好了，我们可以开始编写了。\n首先还是导入 recyclerview 的依赖：\nimplementation (\u0026#34;androidx.recyclerview:recyclerview:1.1.0\u0026#34;) 接着我们修改主界面：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#d8e0e8\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/msg_recycler_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;LinearLayout android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/input_text\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:hint=\u0026#34;Type something here\u0026#34; android:maxLines=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/send\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Send\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 我们用一个 EditText 来给用户进行输入，Button 来发送信息，而 RecyclerView 就是用来显示聊天的信息内容。\n然后，我们定义一下 Msg 实体类：\npackage com.yikuanzz.uibasepratice; public class Msg { public static final int TYPE_RECEIVED = 0; public static final int TYPE_SENT = 1; private String content; private int type; public Msg(String content, int type){ this.content = content; this.type = type; } public String getContent(){ return content; } public int getType(){ return type; } } 其中，type 表示消息都类型，TYPE_RECEIVED 表示这是一条收到的信息，TYPE_SENT 表示这是一条发出的消息。\n接下来我们写一下 RecyclerView 子项的布局：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/left_layout\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;left\u0026#34; android:background=\u0026#34;@drawable/message_left\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/left_msg\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34; android:textColor=\u0026#34;#fff\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/right_layout\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;right\u0026#34; android:background=\u0026#34;@drawable/message_right\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/right_msg\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 接下来，我们创建 RecycleView 的适配器，新建类 MsgAdapter：\npackage com.yikuanzz.uibasepratice; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.LinearLayout; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; import java.util.List; public class MsgAdapter extends RecyclerView.Adapter\u0026lt;MsgAdapter.ViewHolder\u0026gt; { private List\u0026lt;Msg\u0026gt; mMsgList; static class ViewHolder extends RecyclerView.ViewHolder{ LinearLayout leftLayout; LinearLayout rightLayout; TextView leftMsg; TextView rightMsg; public ViewHolder(@NonNull View view) { super(view); leftLayout = (LinearLayout) view.findViewById(R.id.left_layout); rightLayout = (LinearLayout) view.findViewById(R.id.right_layout); leftMsg = (TextView) view.findViewById(R.id.left_msg); rightMsg = (TextView) view.findViewById(R.id.right_msg); } } public MsgAdapter(List\u0026lt;Msg\u0026gt; msgList){ mMsgList = msgList; } @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.msg_item, parent, false); return new ViewHolder(view); } @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) { Msg msg = mMsgList.get(position); if (msg.getType() == Msg.TYPE_RECEIVED){ // 如果是收到消息就显示左边布局的信息，将右边布局信息隐藏 holder.leftLayout.setVisibility(View.VISIBLE); holder.rightLayout.setVisibility(View.GONE); holder.leftMsg.setText(msg.getContent()); } else if (msg.getType() == Msg.TYPE_SENT){ // 如果是发出消息就显示右边布局的信息，将左边布局信息隐藏 holder.rightLayout.setVisibility(View.VISIBLE); holder.leftLayout.setVisibility(View.GONE); holder.rightMsg.setText(msg.getContent()); } } @Override public int getItemCount() { return mMsgList.size(); } } 最后我们在 MainAcitvity 将我们的代码写上：\npackage com.yikuanzz.uibasepratice; import androidx.appcompat.app.AppCompatActivity; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { private List\u0026lt;Msg\u0026gt; msgList = new ArrayList\u0026lt;\u0026gt;(); private EditText inputText; private Button send; private RecyclerView msgRecyclerView; private MsgAdapter adapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 初始化数据和控件绑定 initMsgs(); inputText = (EditText) findViewById(R.id.input_text); send = (Button) findViewById(R.id.send); msgRecyclerView = (RecyclerView) findViewById(R.id.msg_recycler_view); // 线性管理器和适配器 LinearLayoutManager layoutManager = new LinearLayoutManager(this); msgRecyclerView.setLayoutManager(layoutManager); adapter = new MsgAdapter(msgList); msgRecyclerView.setAdapter(adapter); // 设置点击事件 send.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { String content = inputText.getText().toString(); if (!\u0026#34;\u0026#34;.equals(content)){ Msg msg = new Msg(content, Msg.TYPE_SENT); msgList.add(msg); // 有新信息的时候刷新 adapter.notifyItemInserted(msgList.size() - 1); // 定位到最后一行 msgRecyclerView.scrollToPosition(msgList.size() - 1); // 清空输入狂内容 inputText.setText(\u0026#34;\u0026#34;); } } }); } private void initMsgs(){ Msg msg1 = new Msg(\u0026#34;Hello man.\u0026#34;, Msg.TYPE_RECEIVED); msgList.add(msg1); Msg msg2 = new Msg(\u0026#34;Hello.You Good?\u0026#34;, Msg.TYPE_SENT); msgList.add(msg2); Msg msg3 = new Msg(\u0026#34;This is Tom. Nice talking to you!\u0026#34;, Msg.TYPE_RECEIVED); msgList.add(msg3); } } Android 碎片 碎片（Fragment）是一种可以嵌入在活动当中的 UI 片段，它能让程序更加合理和充分地利用大屏幕的空间，因为在平板上应用得非常广泛。\n碎片的使用 我们使用平板模拟器，创建一个 FragmentTest 项目。\n然后新建一个左侧碎片布局 left_fragment.xml。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:text=\u0026#34;Button\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 再创建一个右侧碎片布局 right_fragment.xml 。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#00ff00\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; android:text=\u0026#34;This is right fragment\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 接着我们分别创建一个 LeftFragment 类 和 RightFragment类。\n// LeftFragment public class LeftFragment extends Fragment { @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.left_fragement, container, false); return view; } } // RightFragment public class RightFragment extends Fragment { @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.right_fragement, container, false); return view; } } 接下来，我们修改一下 activity_main.xml 中的代码。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/left_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.LeftFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/right_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.RightFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 当然碎片的强大之处在于它能够在程序运行时动态地添加到活动当中，我们新建 another_right_fragment.xml 。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:background=\u0026#34;#ffff00\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; android:text=\u0026#34;This is another right fragment\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后我们修改 activity_main.xml 中的右碎片为布局：\n\u0026lt;FrameLayout android:id=\u0026#34;@+id/right_fragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;/FrameLayout\u0026gt; 在代码中，我们用按钮来添加碎片：\npackage com.yikuanzz.fragementtest; import androidx.appcompat.app.AppCompatActivity; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentTransaction; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button) findViewById(R.id.button); replaceFragment(new RightFragment()); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { replaceFragment(new AnotherRightFragment()); } }); } private void replaceFragment(Fragment fragment){ FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.replace(R.id.right_layout, fragment); transaction.commit(); } } 其实我们发现，动态添加碎片的步骤就是：\n（1）创建待添加的碎片实例。 （2）获取 FragementManager，在活动中可以调用 getSupportFragmentManager() 方法。 （3）开启一个事务，调用 beginTransaction() 方法开启。 （4）向容器内添加或替换碎片，一般使用 replace() 方法实现，需要传入容器的 id 和待添加的碎片实例。 （5）提交事务，调用 commite() 方法来完成。 FragmentTransaction 提供了一个 addToBackStack() 方法，用于将一个事务添加到返回栈中：\nprivate void replaceFragment(Fragment fragment){ FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.replace(R.id.right_layout, fragment); transaction.addToBackStack(null); transaction.commit(); } FragmentManager 提供了一个类似于 findViewById() 的方法，专门用于从布局文件中获取碎片的实例：\nRightFragment rightFragment = (RightFragment) getFragmentManager().findFragmentById(R.id.right_fragment); 此外，碎片也可以调用活动：\nMainActivity activity = (MainActivity) getActivity(); 碎片的生命周期 运行状态：当一个碎片是可见的，并且它所关联的活动正处于运行状态时，该碎片也处于运行状态。\n暂停状态：当活动进入暂停状态，与它关联的可见碎片就会进入到暂停状态。\n停止状态：当活动进入停止状态时，与他关联的碎片会进入到停止状态或者是从活动中移除。\n销毁状态：活动被销毁时，与它关联的碎片也就进入到销毁状态。\nonAttach()。当前碎片和活动建立关联的时候调用。 onCreateView()。为碎片创建视图时调用。 onActivityCreated()。确保与碎片相关联的活动一定已经创建完毕的时候调用。 onDestoryView()。当与碎片关联的视图被移除的时候调用。 onDetach()。当碎片和活动解除关联的时候调用。 注意，在新版本中 onActivityCreated() 方法被弃用，应该使用 onViewCreated() 方法替代。\n动态加载布局的技巧 使用限定符（Qualifiers） 来判断程序是使用双页模式还是单页模式。\n我们修改 activity_main.xml ：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/left_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.LeftFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 接着我们新建 layout-large 文件夹，在里面新建一个布局，也叫 activity_main.xml 。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/left_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.LeftFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/right_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.RightFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 这样，如果我们在手机启动这个应用就只会显示左边的碎片，而在使用平板的时候就会显示右边的碎片。\n当然我们可以用最小宽度限定符来指定屏幕宽度的临界点，如果屏幕大于这个值，那么设备就加载较大的布局。\n我们新建一个 layout-sw600dp 文件夹，然后在这个文件夹下新建 activity_main.xml 布局：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/left_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.LeftFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/right_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementtest.RightFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;3\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 碎片实战-简易的新闻应用 新建一个项目叫 FragmentBestPratice ，我们在这个项目上完成我们的实践。\n我们的项目步骤大概是这样的：\n1.准备新闻内容的碎片和碎片渲染； 2.准备新闻列表的碎片和渲染； 3.准备低分辨率主界面和高分辨率主界面。 这里我们要用到 RecyclerView，所以我们先引入依赖：\nimplementation (\u0026#34;androidx.recyclerview:recyclerview:1.1.0\u0026#34;) 接着我们准备一个 New 实体类来存放新闻：\npackage com.yikuanzz.fragementbestpratice; public class News { private String title; private String content; public void setTitle(String title){ this.title = title; } public String getContent(){ return content; } public void setContent(String content){ this.content = content; } } 准备新闻内容的布局\n为了处理这个内容，我们需要把新闻内容放入 Fragment 中，所以我们这里写一个 new_content_frag.xml 用来展示新闻的内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;LinearLayout android:id=\u0026#34;@+id/visibility_layout\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:visibility=\u0026#34;invisible\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/news_title\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;1dp\u0026#34; android:background=\u0026#34;#000\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/news_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:padding=\u0026#34;15dp\u0026#34; android:textSize=\u0026#34;18sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;View android:layout_width=\u0026#34;1dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:background=\u0026#34;#000\u0026#34;/\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 然后，我们再新建一个 NewsContentFragment 来渲染我们的新闻内容碎片：\npackage com.yikuanzz.fragementbestpratice; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; public class NewsContentFragment extends Fragment { private View view; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { view = inflater.inflate(R.layout.news_content_frag, container, false); return view; } public void refresh(String newsTitle, String newsContent){ View visibilityLayout = view.findViewById(R.id.visibility_layout); visibilityLayout.setVisibility(View.VISIBLE); TextView newsTitleText = (TextView) view.findViewById(R.id.news_title); TextView newsContentText = (TextView) view.findViewById(R.id.news_content); newsTitleText.setText(newsTitle); // 刷新新闻标题 newsContentText.setText(newsContent); // 刷新新闻内容 } } 接着我们再写一个 news_content.xml 用来引入我们写的 news_content_frag.xml 内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.NewsContentActivity\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/news_content_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementbestpratice.NewsContentFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 之后，我们写一个 Fragment 的启动就好了，我们写在 NewsContentActivity.java 中：\npackage com.yikuanzz.fragementbestpratice; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.content.Intent; import android.os.Bundle; public class NewsContentActivity extends AppCompatActivity { public static void actionStart(Context context, String newsTitle, String newsContent{ Intent intent = new Intent(context, NewsContentActivity.class); intent.putExtra(\u0026#34;news_title\u0026#34;, newsTitle); intent.putExtra(\u0026#34;news_content\u0026#34;, newsContent); context.startActivity(intent); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.news_content); String newsTitle = getIntent().getStringExtra(\u0026#34;news_title\u0026#34;); String newsContent = getIntent().getStringExtra(\u0026#34;news_content\u0026#34;); NewsContentFragment newsContentFragment =(NewsContentFragment) getSupportFragmentManager().findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(newsTitle, newsContent); } } 准备新闻列表\n这里我们要用到 RecyclerView 所以我们一定写的是 news_title_frag.xml 和 news_title_item.xml：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;androidx.recyclerview.widget.RecyclerView android:id=\u0026#34;@+id/news_title_recycler_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;TextView xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/news_title\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:singleLine=\u0026#34;true\u0026#34; android:ellipsize=\u0026#34;end\u0026#34; android:paddingLeft=\u0026#34;10dp\u0026#34; android:paddingRight=\u0026#34;10dp\u0026#34; android:paddingTop=\u0026#34;15dp\u0026#34; android:paddingBottom=\u0026#34;15dp\u0026#34;/\u0026gt; 好了，我们接下来就要准备 NewsTitleFragment 了，因为要启动 RecyclerView 所以我们还要写的就是 Adapter 但是我们可以写入 NewsTitleFragment 中，这样我们还可以判断是双页显示还是单页显示，然后将数据刷新进去：\npackage com.yikuanzz.fragementbestpratice; import android.os.Bundle; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import java.util.ArrayList; import java.util.List; import java.util.Random; public class NewsTitleFragment extends Fragment { private boolean isTwoPane; class NewsAdapter extends RecyclerView.Adapter\u0026lt;NewsAdapter.ViewHolder\u0026gt;{ private List\u0026lt;News\u0026gt; mNewsList; class ViewHolder extends RecyclerView.ViewHolder{ TextView newsTitleText; public ViewHolder(View view){ super(view); newsTitleText = (TextView) view.findViewById(R.id.news_title); } } public NewsAdapter (List\u0026lt;News\u0026gt; newsList){ mNewsList = newsList; } @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_title_item, parent, false); final ViewHolder holder = new ViewHolder(view); view.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { News news = mNewsList.get(holder.getAdapterPosition()); if (isTwoPane){ // 如果是双页模式就刷新 NewsContentFragment 中的内容 NewsContentFragment newsContentFragment = (NewsContentFragment) getChildFragmentManager(). findFragmentById(R.id.news_content_fragment); newsContentFragment.refresh(news.getTitle(), news.getContent()); } else{ // 如果是双页模式就启动 NewsContentActivity NewsContentActivity.actionStart(getActivity(), news.getTitle(), news.getContent()); } } }); return holder; } @Override public void onBindViewHolder(@NonNull ViewHolder holder, int position) { News news = mNewsList.get(position); holder.newsTitleText.setText(news.getTitle()); } @Override public int getItemCount() { return mNewsList.size(); } } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.news_title_frag, container, false); // 绑定 RecyclerView RecyclerView recyclerView = (RecyclerView) view.findViewById(R.id.news_title_recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity()); recyclerView.setLayoutManager(layoutManager); NewsAdapter newsAdapter = new NewsAdapter(getNews()); recyclerView.setAdapter(newsAdapter); return view; } private List\u0026lt;News\u0026gt; getNews(){ List\u0026lt;News\u0026gt; newsList = new ArrayList\u0026lt;\u0026gt;(); for (int i = 1; i \u0026lt;= 50; i++){ News news = new News(); news.setTitle(\u0026#34;This is news title\u0026#34; + i); news.setContent(getRandomLengthContent(\u0026#34;This is news content\u0026#34; + i + \u0026#34;.\u0026#34;)); newsList.add(news); } return newsList; } private String getRandomLengthContent(String content){ Random random = new Random(); int length = random.nextInt(20) + 1; StringBuilder builder = new StringBuilder(); for (int i = 0; i \u0026lt; length; i++){ builder.append(content); } return builder.toString(); } @Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) { if (getActivity().findViewById(R.id.news_content_layout) != null){ isTwoPane = true; } else{ isTwoPane = false; } } } 准备单页和双页的布局\n我们要修改 activity_main.xml 中的内容，此外我们还新建一个 layput-sw600p 文件夹中，在里面写 activity_main.xml 文件，该文件在分辨率大于值的时候应用：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/news_title_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementbestpratice.NewsTitleFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/news_title_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementbestpratice.NewsTitleFragment\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;FrameLayout android:id=\u0026#34;@+id/news_content_layout\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;3\u0026#34; \u0026gt; \u0026lt;fragment android:id=\u0026#34;@+id/news_content_fragment\u0026#34; android:name=\u0026#34;com.yikuanzz.fragementbestpratice.NewsContentFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 所以，最后我们回顾一下整个项目的启动：\n1.项目判断设备的分辨率启动不同的 activity_main.xml； 2.对应 acivity_main.xml 中的 Fragment 启动； 3.NewsTitleFragment 启动并判断单双模式； 4.Adapter 根据单双页模式渲染点击事件的布局。 Android 广播 Android 广播主要分为两种类型：\n标准广播（Normal broadcast）：完全异步执行的广播，在广播发出后，所有的广播接收器几乎会在同一时间内接收到这条广播消息。 有序广播（Ordered broadcast）：同步执行的广播，在广播发出后同一时间只会有一个广播接收器能够收到这条广播消息，只有当这个广播接收器处理完毕后才会传给下一个广播接收器。 动态注册监听网络变化 我们新建一个 BroadCastTest 项目，修改 MainActivity 中的代码：\npackage com.yikuanzz.broadcasttest; import androidx.appcompat.app.AppCompatActivity; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.os.Bundle; import android.widget.Toast; public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetworkChangeReceiver networkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); // 设置监听的广播类型 intentFilter.addAction(\u0026#34;android.net.conn.CONNECTIVITY_CHANGE\u0026#34;); networkChangeReceiver = new NetworkChangeReceiver(); registerReceiver(networkChangeReceiver, intentFilter); } @Override protected void onDestroy() { super.onDestroy(); // 取消动态注册 unregisterReceiver(networkChangeReceiver); } class NetworkChangeReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { // 获取系统网络连接服务 ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo(); if (networkInfo != null \u0026amp;\u0026amp; networkInfo.isAvailable()){ Toast.makeText(context, \u0026#34;network is availabel\u0026#34;, Toast.LENGTH_SHORT).show(); } else{ Toast.makeText(context, \u0026#34;network is unavailable\u0026#34;, Toast.LENGTH_SHORT).show(); } } } } 需要额外说明的是，Android 为了保护用户设备的安全和隐私，如果我们要进行一些操作需要在 AndroidManifest.xml 文件中声明权限：\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; 静态注册实现开机启动 静态注册可以在程序为启动之前接收广播。\n我们新建一个 Broadcast Receiver 叫 BootCompleteReceiver：\npackage com.yikuanzz.broadcasttest; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class BootCompleteReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. // throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); Toast.makeText(context, \u0026#34;Boot Complete\u0026#34;, Toast.LENGTH_SHORT).show(); } } 然后我们修改 AndroidManifest.xml 文件：\n\u0026lt;receiver android:name=\u0026#34;.BootCompleteReceiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; 这样我们开机的时候就可以收到广播了。\n自定义广播 标准广播\n我们静态注册一个 MyBroadcastReceiver：\npackage com.yikuanzz.broadcasttest; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. // throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); Toast.makeText(context., \u0026#34;received in MyBroadcastReceiver\u0026#34;, Toast.LENGTH_SHORT).show(); } } 我们让它接收一条 com.example.broadcasttest.MY_BROADCAST 广播：\n\u0026lt;receiver android:name=\u0026#34;.MyBroadcastReceiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.broadcasttest.MY_BROADCAST\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; 我们在主活动的布局中添加一个按钮：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后在主活动中设置监听器通过按钮发送广播：\nButton button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(\u0026#34;com.example.broadcasttest.MY_BROADCAST\u0026#34;); sendBroadcast(intent); } }); 有序广播\n我们验证一下其它应用程序也是能接收到广播。\n我们新建一个项目，然后定义 AnotherBroadcastReceiver：\npackage com.yikuanzz.broadcasttest2; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.widget.Toast; public class AnotherBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // TODO: This method is called when the BroadcastReceiver is receiving // an Intent broadcast. // throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;) Toast.makeText(context, \u0026#34;received in AnotherBroadcastReceiver\u0026#34;, Toast.LENGTH_SHORT).show(); } } 我们让它接收一条 com.example.broadcasttest.MY_BROADCAST 广播：\n\u0026lt;receiver android:name=\u0026#34;.AnotherBroadcastReceiver\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.broadcasttest.MY_BROADCAST\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; 现在我们启动这个项目后，点击上个项目的广播发送按钮，会发现两个程序都能收到广播。当然，如果要发送有序广播，我们还要修改一下 MainActivity 的代码：\nButton button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(\u0026#34;com.example.broadcasttest.MY_BROADCAST\u0026#34;); sendOrderedBroadcast(intent, null); } }); 我们可以在 AndroiManifest.xml 中设置广播接收优先级：\n\u0026lt;intent-filter android:priority=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.broadcasttest.MY_BROADCAST\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; 然后可以在广播接收器中截断广播，不让广播继续传播：\n@Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, \u0026#34;received in MyBroadcastReceiver\u0026#34;, Toast.LENGTH_SHORT).show(); abortBroadcast(); } 本地广播 本地广播就是只在程序中传播的广播机制。\n主要就是用 LocalBroadcastManager 来对广播进行管理。\n我们修改 MainAcitvity.java 中的代码：\npackage com.yikuanzz.broadcasttest; import androidx.appcompat.app.AppCompatActivity; import androidx.localbroadcastmanager.content.LocalBroadcastManager; import android.content.BroadcastReceiver; import android.content.Context; import android.content.Intent; import android.content.IntentFilter; import android.net.ConnectivityManager; import android.net.NetworkInfo; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(\u0026#34;com.example.brocasttest.LOCAL_BROADCAST\u0026#34;); localBroadcastManager.sendBroadcast(intent); // 发送本地广播 } }); intentFilter = new IntentFilter(); intentFilter.addAction(\u0026#34;com.example.brocasttest.LOCAL_BROADCAST\u0026#34;); localReceiver = new LocalReceiver(); localBroadcastManager.registerReceiver(localReceiver, intentFilter); // 注册监听器 } @Override protected void onDestroy() { super.onDestroy(); // 取消动态注册 localBroadcastManager.unregisterReceiver(localReceiver); } class LocalReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, \u0026#34;received local broadcast\u0026#34;, Toast.LENGTH_SHORT).show(); } } } 广播实战-强制下线 我们新建一个 BroadcastBestPractice 项目。\n我们新建一个 ActivityCollector 类用于管理所有的活动：\npackage com.yikuanzz.broadcastbestpratice; import android.app.Activity; import java.util.ArrayList; import java.util.List; public class ActivityCollector { public static List\u0026lt;Activity\u0026gt; activityList = new ArrayList\u0026lt;\u0026gt;(); public static void addActivity(Activity activity){ activityList.add(activity); } public static void removeActivity(Activity activity){ activityList.remove(activity); } public static void finishAll(){ for (Activity activity : activityList){ if (!activity.isFinishing()){ activity.finish(); } } } } 然后创建 BaseActivity 类作为所有活动的父类：\npackage com.yikuanzz.broadcastbestpratice; import android.os.Bundle; import android.os.PersistableBundle; import androidx.annotation.Nullable; import androidx.appcompat.app.AppCompatActivity; public class BaseActivity extends AppCompatActivity { @Override public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); ActivityCollector.addActivity(this); } @Override protected void onDestroy() { super.onDestroy(); ActivityCollector.removeActivity(this); } } 接下来，我们新建一个登录界面的活动 LoginActivity 我们编辑它的布局文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.LoginActivity\u0026#34;\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Account: \u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/account\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:orientation=\u0026#34;horizontal\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34; android:textSize=\u0026#34;18sp\u0026#34; android:text=\u0026#34;Password: \u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/password\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_gravity=\u0026#34;center_vertical\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/login\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:text=\u0026#34;Login\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 然后我们修改 LoginActivity 中代码：\npackage com.yikuanzz.broadcastbestpratice; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.EditText; import android.widget.Toast; public class LoginActivity extends BaseActivity { private EditText accountText; private EditText passwordText; private Button login; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); // 绑定组件 accountText = (EditText) findViewById(R.id.account); passwordText = (EditText) findViewById(R.id.password); login = (Button) findViewById(R.id.login); login.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 实现登录 String account = accountText.getText().toString(); String password = passwordText.getText().toString(); if (account.equals(\u0026#34;admin\u0026#34;) \u0026amp;\u0026amp; password.equals(\u0026#34;123456\u0026#34;)){ Intent intent = new Intent(LoginActivity.this, MainActivity.class); startActivity(intent); } else { Toast.makeText(LoginActivity.this, \u0026#34;account or passsword is invalid\u0026#34;, Toast.LENGTH_SHORT).show(); } } }); } } 然后我们在主活动的布局中添加一个按钮用来触发下线功能：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/force_offline\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 接着我们修改主活动的代码：\npackage com.yikuanzz.broadcastbestpratice; import androidx.appcompat.app.AppCompatActivity; import android.content.Intent; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends BaseActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button forceOffline = (Button) findViewById(R.id.force_offline); forceOffline.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(\u0026#34;com.example.broadcastbestpratice.FORCE_OFFLINE\u0026#34;); sendBroadcast(intent); } }); } } 接下来，我们只要在 BaseActivity 中添加一个广播接收器就可以了：\npackage com.yikuanzz.broadcastbestpratice; import android.content.BroadcastReceiver; import android.content.Context; import android.content.DialogInterface; import android.content.Intent; import android.content.IntentFilter; import android.os.Bundle; import android.os.PersistableBundle; import androidx.annotation.Nullable; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; public class BaseActivity extends AppCompatActivity { private ForceOffLineReceiver receiver; @Override public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) { super.onCreate(savedInstanceState, persistentState); ActivityCollector.addActivity(this); } @Override protected void onResume() { super.onResume(); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(\u0026#34;com.example.broadcastbestpratice.FORCE_OFFLINE\u0026#34;); receiver = new ForceOffLineReceiver(); registerReceiver(receiver, intentFilter); } @Override protected void onPause() { super.onPause(); if (receiver != null){ unregisterReceiver(receiver); receiver = null; } } @Override protected void onDestroy() { super.onDestroy(); ActivityCollector.removeActivity(this); } class ForceOffLineReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setTitle(\u0026#34;Warning\u0026#34;); builder.setMessage(\u0026#34;You are forced to be offline. Please try to login again.\u0026#34;); builder.setCancelable(false); builder.setPositiveButton(\u0026#34;OK\u0026#34;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { ActivityCollector.finishAll(); Intent intent = new Intent(context, LoginActivity.class); context.startActivity(intent); } }); builder.show(); } } } 之后我们再修改一下 AndroidManifest.xml 让登录界面作为启动活动：\n\u0026lt;activity android:name=\u0026#34;.LoginActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt; Android 存储 文件存储 文件存储就是不对存储内容做任何个格式化处理。\nContext 类提供了 openFileOutput() 方法，可以用于将数据存储到指定文件中：\n参数一：文件名，所有文件默认放在 /data/data/\u0026lt;packagename\u0026gt;/files/ 目录下。 参数二：文件操作模式，MODE_PRIVATE 和 MODE_APPEND。 MODE_PRIVATE 写入时覆盖。 MODE_APPEND 追加内容。 该方法返回的是一个 FileOutputStream 对象。\n我们看一下实例：\npublic void save(){ String data = \u0026#34;Data to save\u0026#34;; FileOutputStream out = null; BufferedWriter writer = null; try{ out = openFileOutput(\u0026#34;data\u0026#34;, Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); } catch (IOException e){ e.printStackTrace(); } finally{ try { if (writer != null){ writer.close(); } } catch (IOException e){ e.printStackTrace(); } } } 接下来做个例子，创建 FilePerisistenceTest 项目，修改主活动布局的代码，添加一个输入框，我们想让输入框的数据保存下来。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/edit\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;Type something here.\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; package com.yikuanzz.filepersistencetest; import androidx.appcompat.app.AppCompatActivity; import android.content.Context; import android.os.Bundle; import android.widget.EditText; import java.io.BufferedWriter; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; public class MainActivity extends AppCompatActivity { private EditText edit; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); edit = (EditText) findViewById(R.id.edit); } @Override protected void onDestroy() { super.onDestroy(); String inputText = edit.getText().toString(); save(inputText); } public void save(String inputText){ FileOutputStream out = null; BufferedWriter writer = null; try{ out = openFileOutput(\u0026#34;data\u0026#34;, Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); } catch (IOException e){ e.printStackTrace(); } finally{ try{ if (writer != null){ writer.close(); } } catch (IOException e){ e.printStackTrace(); } } } } 那么，我们上面的例子就完成了数据的写入，现在我们再做一个读取的例子。\n我们会用到 openFileInput() 方法。\npublic String load(){ FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try{ int = openFileInput(\u0026#34;data\u0026#34;); reader = new BufferedReader(new InputStreamReader(in)); String line = \u0026#34;\u0026#34;; while ((line = reader.readLine()) != null){ content.append(line); } } catch (IOException e){ e.printStackTrace(); } finally { if (reader != null){ try{ reader.close(); } catch (IOException e){ e.printStackTrace(); } } } } String inputText = load(); if (!TextUtils.isEmpty(inputText)){ edit.setText(inputText); edit.setSelection(inputText.length()); Toast.makeText(this, \u0026#34;Restoring succeeded\u0026#34;, Toast.LENGTH_SHORT).show(); } SharedPreference 存储 SharedPreference 是使用键值对的方式来存储数据的。\nContext 类中的 getSharedPreferences() 方法\n参数一：文件名，放在 /data/data/\u0026lt;package name\u0026gt;/shared_prefs/ 目录下。 参数二：指定操作模式，只有 MODE_PRIVATE。 Activity 类中 gerPreferences() 方法\n只接收操作模式参数，它自动将当前活动类名作为文件名。 PreferenceManager 类中的 getDefaultSharedPreferences() 方法\n接收一个 Context 参数，并自动使用当前应用程序包名作为前缀命名，得到一个 SharedPreferences 对象。 通过调用 SharedPreferences 对象 edit() 方法获取 SharedPreferences.Editor 对象。 向 SharedPreferences.Editor 对象中添加数据。 调用 apply() 方法将添加到数据提交。 新建一个项目，开始实践。首先修改 activity_main.xml 中的代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/save_data\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Save data\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/restore_data\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Resotre data\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 我们用按钮响应将一些数据存在 SharedPreferences 文件中：\npackage com.yikuanzz.sharedpreferencestest; import androidx.appcompat.app.AppCompatActivity; import android.content.SharedPreferences; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button save_data = (Button) findViewById(R.id.save_data); save_data.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { SharedPreferences.Editor editor = getSharedPreferences(\u0026#34;data\u0026#34;, MODE_PRIVATE).edit(); editor.putString(\u0026#34;name\u0026#34;, \u0026#34;Tom\u0026#34;); editor.putInt(\u0026#34;age\u0026#34;, 18); editor.putBoolean(\u0026#34;married\u0026#34;, false); editor.apply(); } }); Button restore_data = (Button) findViewById(R.id.restore_data); restore_data.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { SharedPreferences pref = getSharedPreferences(\u0026#34;data\u0026#34;, MODE_PRIVATE); String name = pref.getString(\u0026#34;name\u0026#34;, \u0026#34;\u0026#34;); int age = pref.getInt(\u0026#34;age\u0026#34;, 0); boolean married = pref.getBoolean(\u0026#34;married\u0026#34;, false); Log.d(\u0026#34;DataInSP\u0026#34;, \u0026#34;name is \u0026#34; + name); Log.d(\u0026#34;DataInSP\u0026#34;, \u0026#34;age is \u0026#34; + age); Log.d(\u0026#34;DataInSP\u0026#34;, \u0026#34;married is \u0026#34; + married); } }); } } SQListe 数据库存储 Android 提供了 SQLiteOpenHelper 帮助我们使用数据库。\ngetReadableDatebase() 和 getWritableDatabase() 用于创建或打开一个现有数据库。 构造方法有四个参数： Context 上下文。 数据库名。 Cursor 游标。 数据库版本号。 数据库文件一般放在 /data/data/\u0026lt;package name\u0026gt;/databases/ 目录。 我们创建一个项目来实践一下：\npackage com.yikuanzz.databasetest; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.widget.Toast; public class MyDatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = \u0026#34;create table Book(\u0026#34; + \u0026#34;id integer primary key autoincrement,\u0026#34; + \u0026#34;author text,\u0026#34; + \u0026#34;price real,\u0026#34; + \u0026#34;pages integer,\u0026#34; + \u0026#34;name text)\u0026#34;; public static final String CREATE_CATEGORY = \u0026#34;create table Category(\u0026#34; + \u0026#34;id integer primary key autoincrement,\u0026#34; + \u0026#34;category_name text,\u0026#34; + \u0026#34;category_code integer)\u0026#34;; private Context mContext; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version){ super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, \u0026#34;Create succeeded\u0026#34;, Toast.LENGTH_SHORT).show(); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { db.execSQL(\u0026#34;drop table if exists Book\u0026#34;); db.execSQL(\u0026#34;drop table if exists Category\u0026#34;); onCreate(db); } } package com.yikuanzz.databasetest; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, \u0026#34;BookStore.db\u0026#34;, null, 2); Button createDatabase = (Button) findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { dbHelper.getWritableDatabase(); } }); } } SQLiteDatabase db = dbHepler.getWritableDatabase(); ContentValues values = new ContentValues(); // 添加数据 values.put(\u0026#34;name\u0026#34;, \u0026#34;MyCode1\u0026#34;); values.put(\u0026#34;author\u0026#34;, \u0026#34;Yikuanzz\u0026#34;); values.put(\u0026#34;pages\u0026#34;, 345); values.put(\u0026#34;price\u0026#34;, 9.99); db.insert(\u0026#34;Book\u0026#34;, null, values); values.put(\u0026#34;name\u0026#34;, \u0026#34;MyCode2\u0026#34;); values.put(\u0026#34;author\u0026#34;, \u0026#34;Yikuanzz\u0026#34;); values.put(\u0026#34;pages\u0026#34;, 243); values.put(\u0026#34;price\u0026#34;, 19.99); db.insert(\u0026#34;Book\u0026#34;, null, values); // 修改数据 values.put(\u0026#34;price\u0026#34;, 10.99); db.update(\u0026#34;Book\u0026#34;, values, \u0026#34;name = ?\u0026#34;, new String[] {\u0026#34;MyCode1\u0026#34;}); // 删除数据 db.delte(\u0026#34;Book\u0026#34;, \u0026#34;pages \u0026gt; ?\u0026#34;, new String[] {\u0026#34;300\u0026#34;}); // 查询数据 Cursor cursor = db.query(\u0026#34;Book\u0026#34;, null, null, null, null, null, null); if (cursor.moveToFirst()){ do{ String name = cursor.getString(cursor.getColumnIndex(\u0026#34;name\u0026#34;)); String author = cursor.getString(cursor.getColumnIndex(\u0026#34;author\u0026#34;)); int pages = cursor.getInt(cursor.getColumnIndex(\u0026#34;pages\u0026#34;)); double price = cursor.getDouble(cursor.getColumnIndex(\u0026#34;price\u0026#34;)); } while(cursor.moveToNext()); } cursor.close(); LitePal 操作数据库 LitePal 是一个开源的 Android 数据库框架，它采用对象关系映射（ORM）的模式，将常用的数据库功能进行了封装。\n首先我们要添加依赖：\nimplementation(\u0026#34;org.litepal.guolindev:core:3.2.3\u0026#34;) 在 settings.gradle.kts 中引入镜像：\n// Top-level build file where you can add configuration options common to all sub-projects/modules. plugins { id(\u0026#34;com.android.application\u0026#34;) version \u0026#34;8.2.2\u0026#34; apply false } buildscript { repositories { maven{ url = uri(\u0026#34;https://maven.aliyun.com/repository/google\u0026#34;)} maven{ url = uri(\u0026#34;https://maven.aliyun.com/repository/gradle-plugin\u0026#34;)} maven{ url = uri(\u0026#34;https://maven.aliyun.com/repository/public\u0026#34;)} maven{ url = uri(\u0026#34;https://maven.aliyun.com/repository/jcenter\u0026#34;)} google() jcenter() } dependencies { classpath(\u0026#34;com.android.tools.build:gradle:7.4.2\u0026#34;) // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } 然后我们配置 litepal.xml 文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;litepal\u0026gt; \u0026lt;!-- Define the database name of your application. By default each database name should be end with .db. If you didn\u0026#39;t name your database end with .db, LitePal would plus the suffix automatically for you. For example: \u0026lt;dbname value=\u0026#34;demo\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;dbname value=\u0026#34;BookStore\u0026#34; /\u0026gt; \u0026lt;!-- Define the version of your database. Each time you want to upgrade your database, the version tag would helps. Modify the models you defined in the mapping tag, and just make the version value plus one, the upgrade of database will be processed automatically without concern. For example: \u0026lt;version value=\u0026#34;1\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;version value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;!-- Define your models in the list with mapping tag, LitePal will create tables for each mapping class. The supported fields defined in models will be mapped into columns. For example: \u0026lt;list\u0026gt; \u0026lt;mapping class=\u0026#34;com.test.model.Reader\u0026#34; /\u0026gt; \u0026lt;mapping class=\u0026#34;com.test.model.Magazine\u0026#34; /\u0026gt; \u0026lt;/list\u0026gt; --\u0026gt; \u0026lt;list\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;!-- Define where the .db file should be. \u0026#34;internal\u0026#34; means the .db file will be stored in the database folder of internal storage which no one can access. \u0026#34;external\u0026#34; means the .db file will be stored in the path to the directory on the primary external storage device where the application can place persistent files it owns which everyone can access. \u0026#34;internal\u0026#34; will act as default. For example: \u0026lt;storage value=\u0026#34;external\u0026#34; /\u0026gt; --\u0026gt; \u0026lt;/litepal\u0026gt; 最后再配置一下 LitePalApplication 修改 AndroidManifest.xml：\n\u0026lt;manifest\u0026gt; \u0026lt;application android:name=\u0026#34;org.litepal.LitePalApplication\u0026#34; ... \u0026gt; ... \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt; 我们定义一个 Java Bean ：\npackage com.yikuanzz.litepaltest; public class Book { private int id; private String author; private double price; private int pages; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public int getPages() { return pages; } public void setPages(int pages) { this.pages = pages; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 然后设置映射关系：\n\u0026lt;list\u0026gt; \u0026lt;mapping class=\u0026#34;com.yikuanzz.litepaltest.Book\u0026#34;/\u0026gt; \u0026lt;/list\u0026gt; 这样我们已经可以完成了数据表的创建了，但是我们要进行 CRUD 操作的话，就必须让我们的模型对象继承 LitePalSupport：\npublic class Book extends LitePalSupport{ ... } 添加数据：\nBook book = new Book(); book.setName(\u0026#34;The old sea\u0026#34;); book.setAuthor(\u0026#34;Adam\u0026#34;); book.setPages(666); book.setPrice(65.34); book.save(); Toast.makeText(MainActivity.this, \u0026#34;add data\u0026#34;, Toast.LENGTH_SHORT).show(); 更新数据：\nBook book = new Book(); book.setPrice(9.99); book.updateAll(\u0026#34;name = ? and author = ?\u0026#34;, \u0026#34;The old sea\u0026#34;, \u0026#34;Adam\u0026#34;); 删除数据：\nLitePal.deleteAll(Book.class, \u0026#34;price \u0026lt; ?\u0026#34;, \u0026#34;15\u0026#34;); 查询数据：\nList\u0026lt;Book\u0026gt; books = LitePal.findAll(Book.class); List\u0026lt;Book\u0026gt; books = LitePal.select(\u0026#34;name\u0026#34;, \u0026#34;author\u0026#34;).order(\u0026#34;price desc\u0026#34;).find(Book.class); Android 共享 内容提供器（Content Provider）主要用于不同应用程序之间实现数据共享功能，提供了完整的机制，允许一个程序访问另一个程序中的数据，同时保证被访问数据的安全性。\n运行时程序 Android 权限有两类，包括普通权限和危险权限。\n普通权限不会直接威胁用户的安全和隐私，系统会自动授权。\n危险权限可能会触及用户隐私，需要用户手动授权。\n我们新建一个项目来学习运行时权限的使用方法。\npackage com.yikuanzz.runtimepermissiontest; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.Toast; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button make_call = (Button) findViewById(R.id.make_call); make_call.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 判断用户是否授权 if (ContextCompat.checkSelfPermission(MainActivity.this, android.Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(MainActivity.this, new String[]{android.Manifest.permission.CALL_PHONE}, 1); } else{ call(); } } }); } private void call(){ try{ Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\u0026#34;tel:10086\u0026#34;)); startActivity(intent); } catch (SecurityException e){ e.printStackTrace(); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1){ if (grantResults.length \u0026gt; 0 \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED){ call(); } else{ Toast.makeText(this, \u0026#34;You denied the permission\u0026#34;, Toast.LENGTH_SHORT).show(); } } } } 然后我们需要声明权限：\nuses-permission 则像是一个权限助手，帮助app去向用户请求app需要使用的权限。\nuses-feature 的作用更像是一个过滤器，google play 商店会根据该标签来过滤设备。\n\u0026lt;uses-feature android:name=\u0026#34;android.hardware.telephony\u0026#34; android:required=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;uses-permission android:name=\u0026#34;android.permission.CALL_PHONE\u0026#34;/\u0026gt; 访问其他程序中的数据 内容提供器的用法一般有两种，一种是使用现有的内容提供器来读取和操作相应程序中的数据，另一种是创建自己的内容提供器给我们程序的数据提供外部访问接口。\nContentResolver 用法：\n通过 Context 的 getContetnResolver() 方法获取类的实例，不同于 SQLiteDatabasse，它的 CRUD 方法不接收表名参数，使用 Uri 参数替代。\n内容 URI 给内容提供器中的数据建立了唯一标识符，authority 和 path，大概长这样子：content://com.example.app.provider/table1。\n然后我们将其进行解析：Uri uri = Uri.parse(\u0026quot;content://com.example.app.provider/table1\u0026quot;)。\n然后我们就可以用 Uri 来查询数据：\nCurosr cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder ); 查询操作：\nif (cursor != null){ while (cursor.moveToNext()){ String column1 = cursor.getString(cursor.getColumnIndex(\u0026#34;column1\u0026#34;)); int column2 = cursor.getInt(cursor.getColumnIndex(\u0026#34;column2\u0026#34;)); } cursor.close(); } 接下来我们做一个读取联系人的项目：\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CONTACTS\u0026#34;/\u0026gt; package com.yikuanzz.contacttest; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.ActivityCompat; import androidx.core.content.ContextCompat; import android.Manifest; import android.annotation.SuppressLint; import android.content.pm.PackageManager; import android.database.Cursor; import android.os.Bundle; import android.os.strictmode.ExplicitGcViolation; import android.provider.ContactsContract; import android.widget.ArrayAdapter; import android.widget.ListView; import android.widget.Toast; import java.util.ArrayList; import java.util.List; public class MainActivity extends AppCompatActivity { ArrayAdapter\u0026lt;String\u0026gt; adapter; List\u0026lt;String\u0026gt; contactsList = new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView contactsView = (ListView) findViewById(R.id.contacts_view); adapter = new ArrayAdapter\u0026lt;String\u0026gt;(this, android.R.layout.simple_list_item_1, contactsList); contactsView.setAdapter(adapter); if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, 1); } else{ readContacts(); } } private void readContacts(){ try (Cursor cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null)) { if (cursor != null) { while (cursor.moveToNext()) { @SuppressLint(\u0026#34;Range\u0026#34;) String displayName = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); @SuppressLint(\u0026#34;Range\u0026#34;) String number = cursor.getString(cursor.getColumnIndex(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); contactsList.add(displayName + \u0026#34;\\n\u0026#34; + number); } adapter.notifyDataSetChanged(); } } catch (Exception e) { e.printStackTrace(); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1){ if (grantResults.length \u0026gt; 0 \u0026amp;\u0026amp; grantResults[0] == PackageManager.PERMISSION_GRANTED){ readContacts(); } else{ Toast.makeText(this, \u0026#34;You denied the permission\u0026#34;, Toast.LENGTH_SHORT).show(); } } } } 自定义内容提供器 public class MyProvider extends ContentPovider{ ... } Android 媒体 通知 通知一般是在程序进入到后台的时候才会要使用，可以在活动、广播接收器、服务里面创建。\nNotificationManager manager = (NotificationManager)getSystemManager(Context.NOTIFICATION_SERVICE); 通过类构造器创建 Notification 对象：\nNotification notification = new NotificationCompt.Builder(context) .setContentTitle(\u0026#34;Content Title\u0026#34;) .setContentText(\u0026#34;Content Text\u0026#34;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.drawable.small_icon) .setLargetIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)) .build(); 然后我们调用方法让通知显示：\nmanager.notify(1, notification); 接下来我们做一下实例：\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.POST_NOTIFICATIONS\u0026#34; /\u0026gt; package com.yikuanzz.notificationtest; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.NotificationCompat; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.graphics.BitmapFactory; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendNotice = (Button) findViewById(R.id.send_notice); sendNotice.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { NotificationChannel notificationChannel = null; NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); if (android.os.Build.VERSION.SDK_INT \u0026gt;= android.os.Build.VERSION_CODES.O) { notificationChannel = new NotificationChannel(\u0026#34;001\u0026#34;, \u0026#34;channel_name\u0026#34;, NotificationManager.IMPORTANCE_HIGH); manager.createNotificationChannel(notificationChannel); } Notification notification = new NotificationCompat.Builder(MainActivity.this, \u0026#34;001\u0026#34;) .setContentTitle(\u0026#34;Content Title\u0026#34;) .setContentText(\u0026#34;Content Text\u0026#34;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .build(); manager.notify(1, notification); } }); } } 这个时候，我们点击通知的时候还没有响应，我们可以加上点击功能。\n这里新建 NotifcationActivity 和 notification_layout：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.NotificationLayoutActivity\u0026#34;\u0026gt; \u0026lt;TextView android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;This is notification\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/RelativeLayout\u0026gt; package com.yikuanzz.notificationtest; import androidx.appcompat.app.AppCompatActivity; import androidx.core.app.NotificationCompat; import android.app.Notification; import android.app.NotificationChannel; import android.app.NotificationManager; import android.app.PendingIntent; import android.content.Intent; import android.graphics.BitmapFactory; import android.os.Bundle; import android.view.View; import android.widget.Button; public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button sendNotice = (Button) findViewById(R.id.send_notice); sendNotice.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, NotificationLayoutActivity.class); PendingIntent pi = PendingIntent.getActivity(MainActivity.this, 0, intent, PendingIntent.FLAG_IMMUTABLE); NotificationChannel notificationChannel = null; NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); if (android.os.Build.VERSION.SDK_INT \u0026gt;= android.os.Build.VERSION_CODES.O) { notificationChannel = new NotificationChannel(\u0026#34;001\u0026#34;, \u0026#34;channel_name\u0026#34;, NotificationManager.IMPORTANCE_HIGH); manager.createNotificationChannel(notificationChannel); } Notification notification = new NotificationCompat.Builder(MainActivity.this, \u0026#34;001\u0026#34;) .setContentTitle(\u0026#34;Content Title\u0026#34;) .setContentText(\u0026#34;Content Text\u0026#34;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher)) .setContentIntent(pi) .setAutoCancel(true) .build(); manager.notify(1, notification); } }); } } 摄像头和相册 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/take_photo\u0026#34; android:text=\u0026#34;Take Photo\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/picture\u0026#34; android:layout_gravity=\u0026#34;center_horizontal\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 我们接下就写调用摄像头的逻辑：\nAndroid 网络 WebView 控件 如果我们需要在应用程序中展示页面，就要用到 WebView 来嵌入网页。\n注意，我们加入权限声明。\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34;/\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;WebView android:id=\u0026#34;@+id/web_view\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Android 服务 服务（Service）是 Android 实现程序后台服务运行的解决方案，适合不需要和用户交互而且是要求长期运行的任务。\n服务是依赖于创建该服务的进程的，我们要求在服务内部创建子线程来执行任务。\n多线程 class MyThread extends Thread{ @Override public void run(){ // 处理的逻辑 } } 线程的启动也很简单，就是：new MyThread().start();。\n一般来说，我们会选择实现 Runnable 接口的方式来定义线程：\nclass MyThread implements Runnable { @Override public void run(){ // 处理的逻辑 } } 那我们的启动了方式就变成：\nMyThread myThread = new MyThread(); new Thread(myThread).start(); 当然我们还有匿名函数的启动方式：\nnew Thread(new Runnable(){ @Override public void run(){ // 处理的逻辑 } }).start(); 异步消息处理 Android 中的异步消息主要由 4 个部分组成：Message、Handler、MessageQueue 和 Looper。\nMessage 是在线程之间传递消息，可以在内部携带少量的信息，在不同线程之间交换数据。\nHandler 用于发送和处理消息，使用 sendMessage() 将数据传送到 handleMessage() 方法中。\nMessageQueue 用于存放所有通过 Handler 发送的消息，每个线程中都只会有一个消息队列的对象。\nLooper 是负责管理消息队列的，调用它的 loop() 方法后，就会进入无限的循环中，每当发现 MessageQueue 中存在一条消息，就会将它取出，并传递到 Handler 的 handleMessage() 方法中。\nAsyncTask 对异步消息处理有更好的封装，它一般有三个参数：\nParams 执行 AsyncTask 时传入的参数，用于在后台任务中使用。 Progress 后台任务执行时，如果要在界面上显示进度，就在这里指定泛型作为进度单位。 Result 对结果进行返回，用这里的泛型作为返回值的类型。 除此之外，我们还需要重写几个方法：\nonPreExecute：界面初始化操作。 doInBackground(Params) 这里的代码会在子线程中执行，所有耗时任务在这里处理。 onProgressUpdate(Progress) 后台任务调用 publishProgress(Progress) 方法后，该方法被调用，对 UI 进行操作。 onPostExecute(Result) 当后台任务执行完毕通过 return 语句进行返回时，这个方法很快就会被调用。 服务用法 我们新建项目后创建一个服务，它的代码是这样的：\npackage com.yikuanzz.servicetest; import android.app.Service; import android.content.Intent; import android.os.IBinder; public class MyService extends Service { public MyService() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); } } ","date":"2024-04-11T19:05:18+08:00","image":"https://yikuanzz.github.io/2024/android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/cover_hu1426f538bf3f3d274a2921f898c10f8c_1722201_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","title":"Android开发笔记"},{"content":"数组基础 数据简介 数组（Array）：一种线性表数据结构。它使用一组连续的内存空间，来存储一组具有相同类型的数据。\n内存地址： 1000 1004 1008 1012 1016 1020 1024 数据元素： 10 23 24 31 45 78 88 下标索引： 0 1 2 3 4 5 6 线性表：线性表就是所有数据元素排成像一条线一样的结构，线性表上的数据元素都是相同类型，且每个数据元素最多只有前、后两个方向。数组就是一种线性表结构，此外，栈、队列、链表都是线性表结构。 连续的内存空间：线性表有两种存储结构：「顺序存储结构」和「链式存储结构」。其中，「顺序存储结构」是指占用的内存空间是连续的，相邻数据元素之间，物理内存上的存储位置也相邻。数组也是采用了顺序存储结构，并且存储的数据都是相同类型的。 计算机给一个数组分配了一组连续的存储空间，其中第一个元素开始的地址被称为 「首地址」。每个数据元素都有对应的下标索引和内存地址，计算机通过地址来访问数据元素。当计算机需要访问数组的某个元素时，会通过 「寻址公式」 计算出对应元素的内存地址，然后访问地址对应的数据元素。\n// C++ 的数组实现 int arr[2][3] = { {1, 2, 3,}, {4, 5, 6} } // java 的数组实现 int [][]arr = new int[2][3]{ {1, 2, 3}, {4, 5, 6} } # python 的数组实现 arr = [ [1, 2, 3], [4, 5, 6] ] 数组基本操作 # 数组 arr = [1, 4, 7, 1, 3] # 访问元素 def value(nums, i)\t-\u0026gt; (int): if 0 \u0026lt;= i \u0026lt;= len(nums) - 1: return nums[i] print(value(arr, 4)) # 查找元素 def find(nums, val) -\u0026gt; (int): for i in range(len(nums)) if nums[i] == value: return i else return -1 print(find(arr, 2)) # 插入元素 value = 9 arr.append(value) arr.insert(2, value) print(arr) # 改变元素 def change(nums, i, val) -\u0026gt; (bool): if 0 \u0026lt;= i \u0026lt;= len(nums) - 1: nums[i] = val return true else return false print(change(arr, 1, 6)) # 删除元素 arr.pop() arr.remove(0) ​\n数组排序 冒泡排序 冒泡排序（Bubble Sort）基本思想：\n经过多次迭代，通过相邻元素之间的比较与交换，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面。\ndef bubbleSort(nums:[int]) -\u0026gt; None:\t# 时间复杂度：O(n^2) n = len(nums) if (n \u0026lt; 2): return for i in range(n-1, 0, -1): for j in range(0, i, 1): if nums[j] \u0026gt; nums[j+1]: nums[j+1], nums[j] = nums[j], nums[j+1] 选择排序 选择排序（Selection Sort）基本思想：\n将数组分为两个区间：左侧为已排序区间，右侧为未排序区间。每趟从未排序区间中选择一个值最小的元素，放到已排序区间的末尾，从而将该元素划分到已排序区间。\ndef selectionSort(nums:[int]) -\u0026gt; None:\t# 时间复杂度：O(n^2) n = len(nums) if (n \u0026lt; 2): return for i in range(0, n-1, 1): min = i for j in range(i+1, n, 1): min = j if nums[j] \u0026lt; nums[min] else min nums[min], nums[i] = nums[i], nums[min] 插入排序 插入排序（Insertion Sort）基本思想：\n将数组分为两个区间：左侧为有序区间，右侧为无序区间。每趟从无序区间取出一个元素，然后将其插入到有序区间的适当位置。\ndef insertionSort(nums:[int]) -\u0026gt; None:\t# 时间复杂度：O(n^2) n = len(nums) if n \u0026lt; 2: return for i in range(1, n, 1): base, j = nums[i], i - 1 while j \u0026gt;= 0 and nums[j] \u0026gt; base: nums[j+1] = nums[j] j -= 1 nums[j+1] = base 希尔排序 希尔排序（Shell Sort）基本思想：\n将整个数组切按照一定的间隔取值划分为若干个子数组，每个子数组分别进行插入排序。然后逐渐缩小间隔进行下一轮划分子数组和对子数组进行插入排序。直至最后一轮排序间隔为 111，对整个数组进行插入排序。\ndef shellSort(nums:[int]) -\u0026gt; None:\t# 时间复杂度：O(nxlogn) ~ O(n^2) size = len(nums) if size \u0026lt; 2: return gap = size // 2 while gap \u0026gt; 0: for i in range(gap, size, 1): base, j = nums[i], i - gap while j \u0026gt;= 0 and nums[j] \u0026gt; base: nums[j+gap] = nums[j] j -= gap nums[j+gap] = base gap = gap // 2 归并排序 归并排序（Merge Sort）基本思想：\n采用经典的分治策略，先递归地将当前数组平均分成两半，然后将有序数组两两合并，最终合并成一个有序数组。\ndef merge(nums:[int], left:int, mid:int, right:int) -\u0026gt; None: temp = [0 for _ in range(right-left+1)] i, j, k = left, mid + 1, 0 while i \u0026lt;= mid and j \u0026lt;= right: if nums[i] \u0026lt;= nums[j]: temp[k] = nums[i] k += 1 i += 1 elif nums[i] \u0026gt;= nums[j]: temp[k] = nums[j] k += 1 j += 1 while i \u0026lt;= mid: temp[k] = nums[i] k += 1 i += 1 while j \u0026lt;= right: temp[k] = nums[j] k += 1 j += 1 for k in range(0, right-left+1, 1): nums[left+k] = temp[k] def mergeSort(nums:[int], left:int, right:int) -\u0026gt; None:\t# 时间复杂度：O(nxlogn) if left \u0026gt;= right: return mid = left + ((right - left) \u0026gt;\u0026gt; 1) mergeSort(nums, left, mid) mergeSort(nums, mid+1, right) merge(nums, left, mid, right) 快速排序 快速排序（Quick Sort）基本思想：\n采用经典的分治策略，选择数组中某个元素作为基准数，通过一趟排序将数组分为独立的两个子数组，一个子数组中所有元素值都比基准数小，另一个子数组中所有元素值都比基准数大。然后再按照同样的方式递归的对两个子数组分别进行快速排序，以达到整个数组有序。\n# 快排 v1.0 时间复杂度：O(nxlogn) def partition(nums:[int], left: int, right: int) -\u0026gt; int: i, j = left,right while i \u0026lt; j: while i \u0026lt; j and nums[j] \u0026lt;= num[left]: j-- while i \u0026lt; j and nums[i] \u0026gt;= nums[left]: i++ nums[i], nums[j] = nums[j], nums[i] nums[left], nums[i] = nums[i], nums[left] return i def quickSort(nums:[int], left: int, right: int) -\u0026gt; None: n = len(nums) if n \u0026lt; 2: return pivot = partition(nums, left, right) quickSort(nums, left, pivot) quickSort(nums, pivot+1, right) # 快排 v2.0 时间复杂度：O(nxlogn) def partition(nums: [int], left: int, right: int) -\u0026gt; [int]: less, more = left - 1, right while left \u0026lt; more: if nums[left] \u0026lt; nums[right]: less += 1 nums[left], nums[less] = nums[less], nums[left] left += 1 elif nums[left] \u0026gt; nums[right]: more -= 1 nums[left], nums[more] = nums[more], nums[left] else: left += 1 nums[more], nums[right] = nums[right], nums[more] return [less+1, more] def quickSort(nums: [int], left: int, right: int) -\u0026gt; None: if left \u0026gt;= right: return random.seed(time.time()) base = random.randint(left, right) nums[left+base], nums[right] = nums[right], nums[left+base] arr = partition(nums, left, right) quickSort(nums, left, arr[0]-1) quickSort(nums, arr[1]+1, right) 堆排序 堆（Heap）：一种满足以下两个条件之一的完全二叉树：\n大顶堆（Max Heap）：任意节点值 ≥ 其子节点值。 小顶堆（Min Heap）：任意节点值 ≤ 其子节点值。 堆排序（Heap sort）基本思想：\n借用「堆结构」所设计的排序算法。将数组转化为大顶堆，重复从大顶堆中取出数值最大的节点，并让剩余的堆结构继续维持大顶堆性质。\ndef heapInsert(nums: [int], index: int) -\u0026gt; None: while index \u0026gt; 0 and nums[index] \u0026gt; nums[(index - 1) // 2]: nums[index], nums[(index - 1) // 2] = nums[(index - 1) // 2], nums[index] index = (index - 1) // 2 def heapify(nums: [int], index: int, heapSize: int) -\u0026gt; None: left = index * 2 + 1 while left \u0026lt; heapSize: largest = left + 1 if left + 1 \u0026lt; heapSize and nums[left+1] \u0026gt; nums[left] else left largest = largest if nums[largest] \u0026gt; nums[index] else index if largest == index: break nums[largest], nums[index] = nums[index], nums[largest] index = largest left = index*2 + 1 def heapSort(nums: [int]) -\u0026gt; None:\t# 时间复杂度： O(nxlogn) heapSize = len(nums) if heapSize \u0026lt; 2: return for i in range(heapSize): heapInsert(nums, i) heapSize -= 1 nums[0], nums[heapSize] = nums[heapSize], nums[0] while heapSize \u0026gt; 0: heapify(nums, 0, heapSize) heapSize -= 1 nums[0], nums[heapSize] = nums[heapSize], nums[0] 计数排序 计数排序（Counting Sort）基本思想：\n通过统计数组中每个元素在数组中出现的次数，根据这些统计信息将数组元素有序的放置到正确位置，从而达到排序的目的。\ndef countingSort(nums:[int]) -\u0026gt; [int]:\t# 时间复杂度: O(n+k) nums_min, nums_max = min(nums), max(nums) size = nums_max - nums_min + 1 counts = [0 for _ in range(size)] for num in nums: counts[num - nums_min] += 1 for i in range(1, size): counts[i] += counts[i-1] res = [0 for _ in range(len(nums))] for i in range(len(nums)-1, -1, -1): num = nums[i] res[counts[num - nums_min] - 1] = num counts[num - nums_min] -= 1 return res 桶排序 桶排序（Bucket Sort）基本思想：\n将待排序数组中的元素分散到若干个「桶」中，然后对每个桶中的元素再进行单独排序。\ndef insertionSort(nums:[int]) -\u0026gt; None:\tn = len(nums) if n \u0026lt; 2: return for i in range(1, n, 1): base, j = nums[i], i - 1 while j \u0026gt;= 0 and nums[j] \u0026gt; base: nums[j+1] = nums[j] j -= 1 nums[j+1] = base def bucketSort(nums: [int], bucket_size=5) -\u0026gt; [int]: # 时间复杂度: O(nxlogn/m) nums_min, nums_max = min(nums), max(nums) bucket_count = (nums_max - nums_min) // bucket_size + 1 buckets = [[] for _ in range(bucket_count)] for num in nums: buckets[(num - nums_min) // bucket_size].append(num) res = [] for bucket in buckets: insertionSort(bucket) res.extend(bucket) return res 基数排序 基数排序（Radix Sort）基本思想：\n将整数按位数切割成不同的数字，然后从低位开始，依次到高位，逐位进行排序，从而达到排序的目的。\ndef maxBits(nums: [int]) -\u0026gt; int: maxN = 1 \u0026lt;\u0026lt; 31 n = len(nums) for i in range(n): maxN = max(maxN, nums[i]) res = 0 while maxN != 0: res += 1 maxN /= 10 return res def getDigit(x: int, d: int) -\u0026gt; int: return int((x / int(pow(10, d - 1))) % 10) def process(nums: [int], left: int, right: int, digit: int) -\u0026gt; None: radix = 10 i, j = 0, 0 bucket = [0 for _ in range(right-left+1)] for d in range(1, digit+1, 1): count = [0 for _ in range(radix)] for i in range(left, right+1, 1): j = getDigit(nums[i], d) count[j] += 1 for i in range(1, radix, 1): count[i] = count[i] + count[i-1] for i in range(right, left-1, -1): j = getDigit(nums[i], d) bucket[count[j] - 1] = nums[i] count[j] -= 1 j = 0 for i in range(left, right+1, 1): nums[i] = bucket[j] j += 1 def radixSort(nums: [int]) -\u0026gt; None:\t# 时间复杂度：O(nxk) n = len(nums) if n \u0026lt; 2: return process(nums, 0, n-1, maxBits(nums)) 二分查找 二分查找（一） 二分查找算法（Binary Search Algorithm）：也叫做折半查找算法、对数查找算法，是一种用于在有序数组中查找特定元素的高效搜索算法。\n二分查找算法是经典的 「减而治之」 的思想。\n这里的 「减」 是减少问题规模的意思，「治」 是解决问题的意思。「减」 和 「治」 结合起来的意思就是 「排除法解决问题」。即：每一次查找，排除掉一定不存在目标元素的区间，在剩下可能存在目标元素的区间中继续查找。\ndef binary_search(nums: [int], target: int) -\u0026gt; int: left, right = 0, len(nums) - 1; while left \u0026lt;= right: mid = left + ((right - left) \u0026gt;\u0026gt; 1) if nums[mid] \u0026lt; target: left = mid + 1 elif nums[mid] \u0026gt; target: right = mid - 1 else: return mid return -1 二分查找（二） 二分查找的一些关键在于：\n1.区间的开闭问题； 2.中值的取值问题； 3.出界条件的判断； 4.搜索区间范围的选择。 数组双指针 双指针（Two Pointers）：指的是在遍历元素的过程中，不是使用单个指针进行访问，而是使用两个指针进行访问，从而达到相应的目的。如果两个指针方向相反，则称为「对撞指针」。如果两个指针方向相同，则称为「快慢指针」。如果两个指针分别属于不同的数组 / 链表，则称为「分离双指针」。\n对撞指针 对撞指针：指的是两个指针 left、right 分别指向序列的第一个元素和最后一个元素，然后 left 指针不断递增，right 不断递减，直到两指针值相撞，或者满足其他要求的特殊条件为止。\n快慢指针 快慢指针：指两个指针从同一侧开始遍历序列，且移动步长一个快一个慢。两个指针以不同速度、不同策略移动，直到快指针移动到数组尾端，或者两指针相交，或者满足其他特殊条件为止。\n分离双指针 分离双指针：两个指针分别属于不同的数组，两个指针分别在两个数组中移动。\n数组滑动窗口 滑动窗口算法（Sliding Window）：在给定数组 / 字符串上维护一个固定长度或不定长度的窗口。可以对窗口进行滑动操作、缩放操作，以及维护最优解操作。\n滑动操作：窗口可按照一定方向进行移动。最常见的是向右侧移动。 缩放操作：对于不定长度的窗口，可以从左侧缩小窗口长度，也可以从右侧增大窗口长度。 固定长度滑动窗口 固定长度滑动窗口算法（Fixed Length Sliding Window）：在给定数组 / 字符串上维护一个固定长度的窗口。可以对窗口进行滑动操作、缩放操作，以及维护最优解操作。\n不定长滑动窗口 不定长度滑动窗口算法（Sliding Window）：在给定数组 / 字符串上维护一个不定长度的窗口。可以对窗口进行滑动操作、缩放操作，以及维护最优解操作。\n","date":"2024-04-01T02:38:04+08:00","image":"https://yikuanzz.github.io/2024/%E6%95%B0%E7%BB%84/cover_huf4806f05142707a1515192af0abebe67_586819_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":"Python 计算 数字 # 加减乘除 print(2 + 2)\t# 4 print(4 - 3)\t# 1 print(6 * 2) # 12 print(17 / 3)\t# 5.666667 # 去掉小数点 print(17 // 3) # 5 # 取模运算 print(17 % 3)\t# 2 # 幂运算 print(3 ** 2)\t# 9 # 变量赋值 tax = 12.5 / 100 price = 100.50 print(price * price) 文本 # 打印字符串 print(\u0026#34;Hello\u0026#34;)\t# Hello # 转义 print(\u0026#34;I\\\u0026#39;m\u0026#34;)\t# I\u0026#39;m print(r\u0026#39;C:\\user\\local\u0026#39;) # C:\\user\\local # 打印多行 print(\u0026#34;\u0026#34;\u0026#34;\\ Man, what can I said. \u0026#34;\u0026#34;\u0026#34;) # 字符拼接 print(2*\u0026#34;O\u0026#34; + \u0026#34;k\u0026#34;)\t# OOK 列表 # 打印列表 squares = [1, 4, 9] print(squares)\t# [1, 4, 9] # 索引切片 squares[0]\t# 1 squares[-1] # 9 squares[-2:] # [4, 9] # 相同引用 rgb = [\u0026#34;Red\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Blue\u0026#34;] rgba = rgb print(id(rgb) == id(rgba))\t# True # 清空列表 squares[:] = [] print(squares) # [] Python 流程控制 分支结构 # if 语句 x = intput(\u0026#34;请输入一个数字：\u0026#34;) if x \u0026lt; 0: print(\u0026#34;x是负数！\u0026#34;) elif x == 0: print(\u0026#34;x是零！\u0026#34;) else: print(\u0026#34;x是正数！\u0026#34;) 循环结构 # for 循环 animals = [\u0026#39;cat\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;] for a in animals: print(a, len(a)) # 迭代集合副本 weeks = {\u0026#39;Mon\u0026#39;:1, \u0026#39;Tue\u0026#39;:2, \u0026#39;Wen\u0026#39;:3} for d, n in weeks.copy().items(): print(d, n) 其他语句 # range()函数 for i in range(4): print(i)\t# 0 1 2 3 print(list(range(3, 5)))\t# 3 4 print(list(range(0, 10, 3)))\t# 0 3 6 9 print(sum(range(4)))\t# 6 # break 和 continue for n in range(2, 10): for x in range(2, n): if n % x == 0: print(n, \u0026#39;相当于\u0026#39;, x, \u0026#39;*\u0026#39;, n//x) break else: print(n, \u0026#39;是质数\u0026#39;) for num in range(2, 10): if num % 2 == 0: print(\u0026#34;偶数 \u0026#34;, num) continue print(\u0026#34;奇数 \u0026#34;, num) # pass 什么也不执行 while True: pass # match\t\u0026#34;_\u0026#34; 为通配符 一定会执行 def http_error(status): match status: case 400: return \u0026#34;Bad request\u0026#34; case 401|403: return \u0026#34;Not allowed\u0026#34; case 404: return \u0026#34;Not found\u0026#34; case 418: return \u0026#34;I\u0026#39;m a teapot\u0026#34; case _:\treturn \u0026#34;Something\u0026#39;s wrong with the internet\u0026#34; Python 函数 函数定义 def fib(n): a, b = 0, 1 while a \u0026lt; n: print(a, end=\u0026#39; \u0026#39;) a, b = b, a + b print() def ask_ok(prompt, retries=4, reminder=\u0026#39;Please try again!\u0026#39;): while True: reply = input(prompt) if reply in {\u0026#39;y\u0026#39;, \u0026#39;ye\u0026#39;, \u0026#39;yes\u0026#39;}: return True if reply in {\u0026#39;n\u0026#39;, \u0026#39;no\u0026#39;, \u0026#39;nop\u0026#39;, \u0026#39;nope\u0026#39;}: return False retries = retries - 1 if retries \u0026lt; 0: raise ValueError(\u0026#39;invalid user response\u0026#39;) print(reminder) 函数参数 # *name 接收元组 **name 接收字典 def fun(*argument, **keywords): for arg in argument: print(arg) print(\u0026#34;-------\u0026#34;) for kw in kewords: print(kw, \u0026#34;:\u0026#34;, keywords[kw]) # / 限制前面的参数只能按位置传递 # * 限制后面的参数只能按关键字传递 def combined_example(pos_only, /, standard, *, kwd_only): print(pos_only, standard, kwd_only) print(combined_example(1, 2, kwd_only=3)) # 任意参数列表 def concat(*args, sep=\u0026#34;/\u0026#34;) return sep.join(args) print(concat(\u0026#34;earth\u0026#34;, \u0026#34;mars\u0026#34;, \u0026#34;venus\u0026#34;))\t# \u0026#39;earth/mars/venus\u0026#39; # * 将实参从列表或元组解包 args = [3, 6] print(list(range(*args))) Lambda表达式 # 匿名函数写法 def make_incrementor(n): return lambda x: x + n; f = make_incrementor(3) print(f(1))\t# 4 print(f(2))\t# 6 # 匿名函数作实参 paris = [(1, \u0026#39;one\u0026#39;), (2, \u0026#39;two\u0026#39;), (3, \u0026#39;three\u0026#39;), (4, \u0026#39;four\u0026#39;)] paris.sort(key=lambda pair:pair[1]) print(paris) 函数注解 # -\u0026gt; 用来指示函数返回类型\t# __annotations__ 是函数的注解 def f(ham: str, eggs: str = \u0026#39;eggs\u0026#39;) -\u0026gt; str: print(\u0026#34;Annotations:\u0026#34;, f.__annotations__) print(\u0026#34;Arguments:\u0026#34;, ham, eggs) return ham + \u0026#39; and \u0026#39; + eggs 高阶函数 map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。\nr = map(lambda x: x*x, [1, 2, 3, 4]) print(list(r)) reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。\nfrom functools import reduce i = reduce(lambda x, y: 10*x + y, [j for j in range(10) if j % 2 != 0]) print(i) filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\ndef is_odd(n): return n % 2 == 1 print(list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))) yield用法。\ndef g(n): while n \u0026gt; 0: yield n n = n - 1 print(g(10)) Python 数据结构 列表 # 定义列表 animals = [\u0026#39;cat\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;] # count() 计数 print(animals.count(\u0026#39;panda\u0026#39;))\t# 2 # index() 索引 print(animals.index(\u0026#39;elephant\u0026#39;))\t# 4 # reverse() 反转 print(animals.reverse())\t# [\u0026#39;panda\u0026#39;，\u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;dog\u0026#39;, \u0026#39;cat\u0026#39;] # append() 添加 print(animals.append(\u0026#39;pig\u0026#39;))\t# [\u0026#39;cat\u0026#39;，\u0026#39;dog\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;pig\u0026#39;] # sort() 排序 animals.sort() print(animals)\t# [\u0026#39;cat\u0026#39;，\u0026#39;dog\u0026#39;, \u0026#39;donkey\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;panda\u0026#39;, \u0026#39;pig\u0026#39;] # pop() 弹出 print(animals.pop)\t# pig # 列表实现栈 stack = [3, 4, 5] # 入栈 stack.append(6) # 出栈 stack.pop() # 列表实现队列 from collections import deque queue = deque([\u0026#34;Mike\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Tim\u0026#34;]) # 入队 queue.append(\u0026#34;Terry\u0026#34;) # 出队 queue.popleft() 元组和序列 # 元组由多个逗号隔开的值组成 tuples = 123, 4455, \u0026#39;python\u0026#39; print(t)\t# (123, 455, \u0026#39;python\u0026#39;) t = ([1,2,3], [3,2,1]) print(t)\t# ([1,2,3], [3,2,1]) 集合 # 创建集合用 {} 或 set() basket = {\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;} print(basket)\t# {\u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;apple\u0026#39;} a = set(\u0026#39;abracadabra\u0026#39;) b = set(\u0026#39;alacazam\u0026#39;) print(a - b)\t# \u0026#39;r\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39; print(a | b)\t# \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;l\u0026#39; print(a \u0026amp; b)\t# \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39; print(a ^ b)\t# \u0026#39;r\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;l\u0026#39; 字典 # 字典是键值对 tel = {\u0026#39;jack\u0026#39;: 4098, \u0026#39;sape\u0026#39;: 4139} t = dict([(\u0026#39;sape\u0026#39;, 4139), (\u0026#39;guido\u0026#39;, 4127), (\u0026#39;jack\u0026#39;, 4098)]) # 删除 del tel[\u0026#39;jack\u0026#39;] # 添加 tel[\u0026#39;irv\u0026#39;] = 4127 # 判断 print(\u0026#39;guido\u0026#39; in del)\t# True 循环技巧 # items() 提取键值对 knights = {\u0026#39;gallahad\u0026#39;: \u0026#39;the pure\u0026#39;, \u0026#39;robin\u0026#39;: \u0026#39;the brave\u0026#39;} for k, v in knights.items(): print(k, v) # enumerate() 提取索引和值 for i, v in enumerate([\u0026#39;tic\u0026#39;, \u0026#39;tac\u0026#39;, \u0026#39;toe\u0026#39;]): print(i, v) # zip() 循环多个序列 questions = [\u0026#39;name\u0026#39;, \u0026#39;quest\u0026#39;, \u0026#39;favorite color\u0026#39;] answers = [\u0026#39;lancelot\u0026#39;, \u0026#39;the holy grail\u0026#39;, \u0026#39;blue\u0026#39;] for q, a in zip(questions, answers): print(\u0026#39;What is your {0}? It is {1}.\u0026#39;.format(q, a)) # reversed() 逆向 for i in reversed(range(1, 10, 2)): print(i) # sorted() 排序 basket = [\u0026#39;apple\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;apple\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;orange\u0026#39;, \u0026#39;banana\u0026#39;] for i in sorted(basket): print(i) Python IO编程 由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。同步和异步的区别就在于是否等待IO执行的结果。\n文件读写 # 以读文件模式打开一个文件对象 f = open(\u0026#34;/Users/local/test.txt\u0026#34;, \u0026#39;r\u0026#39;) # 一次读取文件全部内容 f.read() # 关闭文件 f.close() # 用 with 自动关闭文件和处理异常 # f.readline()：读取单行数据保留换行符 # f.readline()：返回空字符串表示到文件末尾 # f.tell()：返回文件对象在文件中的位置 # f.seek(offset, whence)：可改变文件对象位置 with open(\u0026#39;/Users/local/test.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: for line in f.readlines(): print(line.strip())\t# 去掉换行符 with open(\u0026#39;/Users/local/test.txt\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;gbk\u0026#39;) as f: f.write(\u0026#39;Hello, World!\u0026#39;) 内存读写 # StringIO 将字符串写入内存 from io import StringIO f = StringIO() f.write(\u0026#34;Hello\u0026#34;) print(f.getvalue()) # BytesIO 将字节写入内存 from io import BytesIO f = BytesIO() f.write(\u0026#39;中文\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) print(f.getvalue()) 文件和目录操作 # 导入 OS import os # 查看当前目录的绝对路径 os.path.abspath(\u0026#39;.\u0026#39;) # 新目录完整路径表示 os.path.join(\u0026#39;/Users/local\u0026#39;, \u0026#39;testdir\u0026#39;) # 创建目录 os.mkdir(\u0026#39;/Users/local/testdir\u0026#39;) # 删除目录 os.rmdir(\u0026#39;/Users/local/testdir\u0026#39;) # 文件路径拆分 os.path.split(\u0026#39;/Users/local/testdir/file.txt\u0026#39;) # 获取文件拓展名 os.path.splitext(\u0026#39;/Users/local/testdir/file.txt\u0026#39;) # 文件重命名 os.rename(\u0026#34;file.txt\u0026#34;, \u0026#34;file.py\u0026#34;) # 文件删除 os.remove(\u0026#34;file.py\u0026#34;) # 列出当前目录下所有目录 [x for x in os.listdir(\u0026#39;.\u0026#39;) if os.path.isdir(x)] # 列出所有 .py 文件 [x for x in os.listfir(\u0026#39;.\u0026#39;) if os.path.isfile(x) and os.paht.splitext(x)[1]=\u0026#39;.py\u0026#39;] 序列化 把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。\n# 将对象序列化为 bytes import pickle d = {\u0026#39;name\u0026#39;:\u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:88} print(pickle.dumps(d)) # 将序列化的对象写入文件 with open(\u0026#39;dump.txt\u0026#39;, \u0026#39;wb\u0026#39;) as f: pickle.dump(d, f) # 直接读取序列化对象 with open(\u0026#39;dump.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: print(pickle.load(f)) # JSON 格式 import json d = {\u0026#39;name\u0026#39;:\u0026#39;Bob\u0026#39;, \u0026#39;age\u0026#39;:20, \u0026#39;score\u0026#39;:88} print(json.dumps(d)) # 将序列化的对象写入文件 with open(\u0026#39;dump.json\u0026#39;, \u0026#39;w\u0026#39;) as f: json.dump(d, f) # 直接读取序列化对象 with open(\u0026#39;dump.json\u0026#39;, \u0026#39;r\u0026#39;) as f: print(json.load(f)) # 类要转换为字典才能被序列化 print(json.dumps(s, default=lambda obj: obj.__dict__)) # 同理，反序列化也是一样的 print(json.loads(json_str, object_hook=dict2student)) 字符串格式化 # 格式化字面值 year = 2024 name = \u0026#39;Mike\u0026#39; print(f\u0026#39;{name} love {year}\u0026#39;) # str.format() 方法 yes_votes = 42_572_654 no_votes = 43_132_495 percentage = yes_votes / (yes_votes + no_votes) print(\u0026#39;{:-9} YES votes {:2.2%}\u0026#39;.format(yes_votes, percentage)) print(\u0026#39;{0}, {1}\u0026#39;.format(yes_votes, percentage)) Python 错误和异常 错误可（至少）被分为两种：语法错误 和 异常。\n异常处理 # 单个值异常 while True: try: x = int(input(\u0026#34;Please enter a number: \u0026#34;)) break except ValueError: print(\u0026#34;Oops! That was no valid number. Try again...\u0026#34;) # 多个异常处理 import sys try: f = open(\u0026#39;myfile.txt\u0026#39;) s = f.readline() i = int(s.strip()) except OSError as err: print(\u0026#34;OS error:\u0026#34;, err) except ValueError: print(\u0026#34;Could not convert data to an integer.\u0026#34;) except Exception as err: print(f\u0026#34;Unexpected {err=}, {type(err)=}\u0026#34;) raise # else 子句 for arg in sys.argv[1:]: try: f = open(arg, \u0026#39;r\u0026#39;) except OSError: print(\u0026#39;cannot open\u0026#39;, arg) else: print(arg, \u0026#39;has\u0026#39;, len(f.readlines()), \u0026#39;lines\u0026#39;) f.close() 异常触发 # raise 强制触发异常 raise NameError(\u0026#39;HiThere\u0026#39;) # 只想判断是否有异常但不处理 try: raise NameError(\u0026#39;HiThere\u0026#39;) except NameError: print(\u0026#39;An exception flew by!\u0026#39;) raise 调用栈 如果错误没有被捕获，它就会一直往上抛，最后被 Python 解释器捕获，打印一个错误信息，然后程序退出。\n# 可以记录错误信息 def foo(s): return 10 / int(s) def bar(s): return foo(s) * 2 def main(): try: bar(\u0026#39;0\u0026#39;) except Exception as e: logging.exception(e) main() 调试 # assert def foo(s): n = int(s) # 如果 n !=0 就会抛出错误 assert n != 0, \u0026#39;n is zero!\u0026#39; return 10 / n def main(): foo(\u0026#39;0\u0026#39;) # logging # 级别：debug、info、warning、error import logging logging.basicConfig(level=logging.INFO) s = \u0026#39;0\u0026#39; n = int(s) logging.info(\u0026#39;n = %d\u0026#39; % n) print(10 / n) 单元测试 单元测试是用来对一个模块、一个函数或一个类来进行正确性检验的测试工作。\n# Dict类 class Dict(dict): def __init__(self, **kw): super().__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r\u0026#34;\u0026#39;Dict\u0026#39; object has no attribute \u0026#39;%s\u0026#39;\u0026#34; % key) def __setattr__(self, key, value): self[key] = value # Dict测试 \u0026#34;\u0026#34;\u0026#34; assertEqual(abs(-1), 1)\t断言函数返回结果与1是否相等 assertRaises(KeyError)\t期待抛出指定类型异常 \u0026#34;\u0026#34;\u0026#34; import unittest from mydict import Dict class TestDict(unittest.TestCase): def test_init(self): d = Dict(a=1, b=\u0026#39;test\u0026#39;) self.assertEqual(d.a, 1) self.assertEqual(d.b, \u0026#39;test\u0026#39;) self.assertTrue(isinstance(d, dict)) def test_key(self): d = Dict() d[\u0026#39;key\u0026#39;] = \u0026#39;value\u0026#39; self.assertEqual(d.key, \u0026#39;value\u0026#39;) def test_attr(self): d = Dict() d.key = \u0026#39;value\u0026#39; self.assertTrue(\u0026#39;key\u0026#39; in d) self.assertEqual(d[\u0026#39;key\u0026#39;], \u0026#39;value\u0026#39;) def test_keyerror(self): d = Dict() with self.assertRaises(KeyError): value = d[\u0026#39;empty\u0026#39;] def test_attrerror(self): d = Dict() with self.assertRaises(AttributeError): value = d.empty # setUP 与 tearDown 分别在测试方法调用前后执行 class TestDice(unittest.TestCase): def setUp(self): print(\u0026#39;setUp..\u0026#39;) def tearDown(self): print(\u0026#39;tearDown..\u0026#39;) Python 面向对象编程 作用域和命名空间 \u0026#34;\u0026#34;\u0026#34; nonlocal 会改变 scope_test 对 spam 的绑定 global 会改变模块层级的绑定 \u0026#34;\u0026#34;\u0026#34; def scope_test(): def do_local(): spam = \u0026#34;local spam\u0026#34; def do_nonlocal(): nonlocal spam spam = \u0026#34;nonlocal spam\u0026#34; def do_global(): global spam spam = \u0026#34;global spam\u0026#34; spam = \u0026#34;test spam\u0026#34; do_local() print(\u0026#34;After local assignment:\u0026#34;, spam) do_nonlocal() print(\u0026#34;After nonlocal assignment:\u0026#34;, spam) do_global() print(\u0026#34;After global assignment:\u0026#34;, spam) scope_test() print(\u0026#34;In global scope:\u0026#34;, spam) 类基础 # 定义一个基础的类 class Dog: def __init__(self, name): # 在变量前 __ 就变成私有变量 self.__name = name self.tricks = [] def add_trick(self, trick): self.tricks.append(trick) 继承和多态 # 继承基类方法，多态覆盖基类方法 class Animal(object): def run(self): print(\u0026#39;Animal is running...\u0026#39;) class Dog(Animal): def run(self): print(\u0026#39;Dog is running...\u0026#39;) class Cat(Animal): pass # 判断某个变量是否是某个类型 a = Animal() d = Animal() print(a, Animal) # True print(d, Animal) # True 定制类 # __str__ 打印类实例 class Student: def __init__(self, name): self.name = name def __str__(self): return \u0026#39;Student object (name: %s)\u0026#39; % self.name # __repr___ 直接显示变量调用信息 __repr___ = __str___ print(Student(\u0026#34;Tom\u0026#34;)) # __iter__ 获取一个迭代对象 class Fib: def __init___(self): self.a, self.b = 0, 1 def __iter___(self): return self def __next___(self): self.a, self.b = self.b, self.a + self.b if self.a \u0026gt; 100_100: raise StopIteration() return self.a # __getitem__ 用下标取出元素 class Fib: def __getitem__(self, n): if isinstance(n, int)\t# n 是索引的时候 a, b = 1, 1 for x in range(n): a, b = b, a + b return a if isinstance(n, slice)\t# n 是切片 start = 0 if n.slice is None else n.slice stop = n.stop a, b = 1, 1 L = [] for x in range(stop): if x \u0026gt;= start: L.append(a) a, b = b, a + b return L # __getattr___ 动态返回一个属性 class Student: def __init__(self): self.name = \u0026#39;Mike\u0026#39; def __getattr__(self, attr): if attr==\u0026#39;score\u0026#39;: return 99 elif attr==\u0026#39;age\u0026#39;: return lambda: 25 # __call()__ 直接调用实例 class Student(object): def __init__(self, name): self.name = name def __call__(self): print(\u0026#39;My name is %s.\u0026#39; % self.name) # Callable 判断调用是对象还是函数 print(callable(Student())) print(callable([1, 2, 3])) ","date":"2024-03-27T00:20:54+08:00","image":"https://yikuanzz.github.io/2024/python-%E5%9F%BA%E7%A1%80/cover_hu39a96208b41191b61a5710e1893b7c44_1174048_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/python-%E5%9F%BA%E7%A1%80/","title":"Python - 基础"},{"content":"操作系统简要 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。 操作系统本质上是一个运行在计算机上的软件程序 ，它屏蔽了硬件层的复杂性，像是硬件使用的管理员，统筹管理计算机硬件和软件资源。 操作系统的 内核（Kernel） 是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。 操作系统功能 进程和线程的管理 ：进程的创建、撤销、阻塞、唤醒，进程间的通信等。 存储管理 ：内存的分配和管理、外存（磁盘等）的分配和管理等。 文件管理 ：文件的读、写、创建及删除等。 设备管理 ：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。 网络管理 ：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。 安全管理 ：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作。 用户态和内核态 用户态(User Mode) : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。 内核态(Kernel Mode) ：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。 用户态切换到内核态的方式 系统调用（Trap） ：用户态进程 主动 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。 中断（Interrupt） ：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 异常（Exception）：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 进程和线程 进程（Process） 是指计算机中正在运行的一个程序实例。PCB（Process Control Block） 为进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。 线程（Thread） 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。 一个进程内可能有多个线程，它们的区别在于进程往往是相互独立的，而线程之间可能会相互影响，需要进行通信。并且，线程的执行开销相对要小一些。\n线程的优点 多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。 同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。 线程之间的同步方式 互斥锁(Mutex) ：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 读写锁（Read-Write Lock）：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。 信号量(Semaphore) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 屏障（Barrier） ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。 事件(Event) :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 进程的状态 创建状态(new) ：进程正在被创建，尚未到就绪状态。 就绪状态(ready) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。 运行状态(running) ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。 阻塞状态(waiting) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。 结束状态(terminated) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。 进程的通信方式 管道/匿名管道(Pipes) ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。 有名管道(Named Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。 信号(Signal) ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生； 消息队列(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。 信号量(Semaphores) ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。 共享内存(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。 套接字(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。 进程调度算法 先到先服务调度算法(FCFS，First Come, First Served) : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 短作业优先的调度算法(SJF，Shortest Job First) : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。 时间片轮转调度算法（RR，Round-Robin） : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。 多级反馈队列调度算法（MFQ，Multi-level Feedback Queue） ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。 优先级调度算法（Priority） ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。 僵尸进程和孤儿进程 僵尸进程 ：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。 孤儿进程 ：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。 死锁 死锁（Deadlock） 描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。\n产生死锁的必要条件 互斥：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。 占有并等待：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。 非抢占：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。 循环等待：有一组等待进程 {P0, P1,..., Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，\u0026hellip;\u0026hellip;，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。 解决死锁的方法 预防 是采用某种策略，限制并发进程对资源的请求，从而使得死锁的必要条件在系统执行的任何时间上都不满足。 避免则是系统在分配资源时，根据资源的使用情况提前做出预测，从而避免死锁的发生。 检测是指系统设有专门的机构，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。 解除 是与检测相配套的一种措施，用于将进程从死锁状态下解脱出来。 死锁的预防 死锁的预防主要是通过破坏产生死锁的四个必要条件来实现的：\n静态分配策略：指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行，它破坏了占有并等待的要求。\n层次分配策略：将所有的资源分成多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，它破坏了循环等待的要求。\n死锁的避免 死锁的避免允许产生死锁的四个必要条件存在，它根据并发进程中与每个进程有关的资源动态申请情况做出进程的调度。\n我们将系统的状态分为 安全状态 和 不安全状态 ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。\n如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。\n银行家算法：先 试探 分配给该进程资源，然后通过 安全性算法 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 真的分配资源给该进程。\n问题：（1）该状态是否安全？（2）若进程 P2 提出请求 Request（1，2，2，2）后，系统能否分配给它？\nProcess Allocation Need Avaliable P0 0 0 3 2 0 0 1 2 1 6 2 2 P1 1 0 0 0 1 7 5 0 P2 1 3 5 4 2 3 5 6 P3 0 3 3 2 0 6 5 2 P4 0 0 1 4 0 6 5 6 死锁的检测 这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 定时地运行一个 “死锁检测” 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。\n乐观锁和悲观锁\n乐观锁和悲观锁是两种用于解决并发场景下数据竞争问题的思想.\n乐观锁：\n乐观锁对应于生活中乐观的人，总是认为事情会往好的方向发展。 在操作数据时，乐观锁非常乐观，认为别人不会同时修改数据。 乐观锁不会上锁，只是在执行更新时判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 性能较好，大部分情况下不会阻塞其他事务的读操作。 悲观锁：\n悲观锁对应于生活中悲观的人，总是认为事情会往坏的方向发展。 在操作数据时，悲观锁比较悲观，认为别人会同时修改数据。 悲观锁在操作数据时直接将数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。 性能较差，可能会阻塞其他事务的读写操作。 死锁的解除 立即结束所有进程的执行，重新启动操作系统 ：这种方法简单，但以前所在的工作全部作废，损失很大。 撤销涉及死锁的所有进程，解除死锁后继续运行 ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。 逐个撤销涉及死锁的进程，回收其资源直至死锁解除。 抢占资源 ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。 进程-资源分配图 在资源分配图中，进程由圆表示，资源由矩形表示。这个图可以帮助我们了解哪些进程在多使用系统资源，并且指出可能存在的瓶颈\n化简资源分配图的方法步骤如下：\n首先，查看系统还剩下多少资源未分配，然后确定哪些进程是不阻塞的（即系统有足够的空闲资源分配给它们）。 将不阻塞的进程的所有边都去掉，形成一个孤立的点，并将系统分配给这些进程的资源回收回来。 接着，查看剩下的进程中哪些是不阻塞的，然后逐个将它们变成孤立的点。 最后，所有的资源和进程都变成孤立的点。这样的图被称为“可完全简化”。如果一个图可完全简化，那么不会产生死锁；如果一个图不可完全简化（即图中还有“边”存在），则会产生死锁。 我们看到图 a，发现左边的进程资源有三个箭头是往外的，这表示它分配了三个资源，所以它没有空闲的资源。再看到右边的进程资源，有一个箭头往外，则表示它分配了一个资源，所以它有一个空闲资源。 进程看完了后，我们看进程，发现 $P_2$ 进程请求一个左边资源，但是左边的资源都分配了，所以 $P_2$ 被阻塞了。在看到 $P_1$ 它请求了一个右边的资源，恰好有空闲的资源分配，所以 $P_1$ 正常运行。 紧接着，在 $P_1$ 执行完毕后，资源释放。我们看到图 b，现在左边有两个空闲资源，右边有一个空闲资源。我们的 $P_2$ 也获得了它的需要的所有资源，所以 $P_2$ 也正常运行了。 如果进程-资源分配图中无环路，则此时系统没有发生死锁。 如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。 如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 既不阻塞又非独立的进程 ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 消除所有的边 ，则不会发生死锁，否则会发生死锁。 ​\n内存管理 操作系统的内存管理非常重要，主要负责下面这些事情：\n内存的分配与回收 ：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。 地址转换 ：将程序中的虚拟地址转换成内存中的物理地址。 内存扩充 ：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。 内存映射 ：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。 内存优化 ：通过调整内存分配策略和回收算法来优化内存使用效率。 内存安全 ：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。 \u0026hellip;\u0026hellip; 内存碎片 内部内存碎片(Internal Memory Fragmentation，简称为内存碎片) ：已经分配给进程使用但未被使用的内存。导致内部内存碎片的主要原因是，当采用固定比例比如 2 的幂次方进行内存分配时，进程所分配的内存可能会比其实际所需要的大。举个例子，一个进程只需要 65 字节的内存，但为其分配了 128（$2^7$） 大小的内存，那 63 字节的内存就成为了内部内存碎片。 外部内存碎片(External Memory Fragmentation，简称为外部碎片) ：由于未分配的连续内存区域太小，以至于不能满足任意进程所需要的内存分配请求，这些小片段且不连续的内存空间被称为外部碎片。也就是说，外部内存碎片指的是那些并为分配给进程但又不能使用的内存。我们后面介绍的分段机制就会导致外部内存碎片。 内存管理 连续内存管理 ：为一个用户程序分配一个连续的内存空间，内存利用率一般不高。 非连续内存管理 ：允许一个程序使用的内存分布在离散或者说不相邻的内存中，相对更加灵活一些。 连续内存管理\n块式管理 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为内部内存碎片。除了内部内存碎片之外，由于两个内存块之间可能还会有外部内存碎片，这些不连续的外部内存碎片由于太小了无法再进行分配。\n在 Linux 系统中，连续内存管理采用了 伙伴系统（Buddy System）算法 来实现，这是一种经典的连续内存分配算法，可以有效解决外部内存碎片的问题。伙伴系统的主要思想是将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 $2^6$=64 KB），并将相邻的内存块组合成一对伙伴。\n当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。\n假设两块相邻的内存块都被释放，系统会将这两个内存块合并，进而形成一个更大的内存块，以便后续的内存分配。这样就可以减少内存碎片的问题，提高内存利用率。\n虽然解决了外部内存碎片的问题，但伙伴系统仍然存在内存利用率不高的问题（内部内存碎片）。这主要是因为伙伴系统只能分配大小为 $2^n$ 的内存块，因此当需要分配的内存大小不是 $2^n$ 的整数倍时，会浪费一定的内存空间。举个例子：如果要分配 65 大小的内存快，依然需要分配 $2^7$=128 大小的内存块。\n为了解决内部碎片的任务，Linux 使用 SLAB分配器 来解决。它将内存划分为固定大小的块，每个块就是一个 SLAB，一个 SLAB 由连续的物理页组成。如果本地高速缓存中有可用的对象，直接从本地高速缓存中分配一个SLAB。否则，执行重新填充操作，从伙伴系统的空闲内存中获取一个 SLAB 并填充到本地高速缓存中。虽然如此，但是在某些情况下它无法提供最优性能。\nSLOB 分配器：\n围绕一个简单的内存块链展开，在分配内存时使用了同样简单的最先适配算法。 主要针对嵌入式系统，特别适用于内存非常有限的系统，例如只有 32MB 以下的内存。 SLOB 的目标是使用较少的内存来实现和管理内存分配。 然而，SLOB 分配器的主要限制在于容易产生外部碎片。 SLUB 分配器：\nSLUB 是 SLAB 分配器 的进化版，旨在改进 SLAB 分配器的一些问题。 为了配合大规模并行系统，通过将页帧打包为组，并用struct page中未使用的字段来管理这些组。 SLUB 分配器与 SLAB 分配器的一些不同之处在于： 每个 CPU 结构中保存的是一个 SLAB 缓冲区，而不是空闲对象链表。 对于每个 CPU，SLUB 不再使用共享的空闲对象链表，而是直接使用单个 SLAB，并且每个 CPU 都维护有自己的部分空链表。 结构对比：\nSLAB 分配器的每个节点有三个链表：空闲 SLAB 链表、部分空 SLAB 链表和已满 SLAB 链表。 SLUB 分配器将这三个链表精简为一个链表，只保留了部分空 SLAB 链表。 SLUB 分配器的 SLAB 缓冲区结构与 SLAB 分配器的不同，它没有对象描述符数组，而是使用指针来管理空闲对象。 非连续内存管理\n段式管理 ：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 页式管理 ：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页，现代操作系统广泛使用的一种内存管理方式。 段页式管理机制 ：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。 虚拟内存 虚拟内存(Virtual Memory) 是计算机系统内存管理非常重要的一个技术，本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。\n虚拟内存的好处\n隔离进程 ：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。 提升物理内存利用率 ：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。 简化内存管理 ：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。 多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。 提高内存使用安全性 ：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。 提供更大的可使用内存空间 ： 可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。 虚拟内存的缺点\n性能下降：当物理内存严重不足时，系统会频繁地进行内存和磁盘的交换（swap），这会降低系统性能。特别是在处理超大文件时，这种性能下降更为明显。 切换开销：在多个应用程序之间切换时，虚拟内存会增加一定的时间开销。因为数据需要从磁盘加载到内存，这会影响应用程序的响应速度。 磁盘空间占用：虚拟内存实际上是将一部分硬盘空间划分为内存使用，同时在硬盘上生成一个 PageFile.Sys文件。尽管这样可以弥补物理内存不足，但也会占用一定的磁盘空间，导致实际可用的磁盘空间变小。 对固态硬盘的影响：虚拟内存的读写操作会对固态硬盘的寿命产生一定影响。如果虚拟内存设置不当，可能会加速固态硬盘的磨损。 虚拟地址和物理地址 物理地址（Physical Address） 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 虚拟地址（Virtual Address） 。\n虚拟地址空间是虚拟地址的集合，是虚拟内存的范围。每一个进程都有一个一致且私有的虚拟地址空间。 物理地址空间是物理地址的集合，是物理内存的范围。 MMU（Memory Management Unit，内存管理单元）是一种硬件模块，用于在CPU和内存之间实现虚拟内存管理。其主要功能包括：\n虚实地址翻译：当用户访问内存时，将用户访问的虚拟地址翻译为实际的物理地址，以便CPU对实际的物理地址进行访问。 访问权限控制：MMU可以对一些虚拟地址进行访问权限控制，以便于对用户程序的访问权限和范围进行管理。例如，代码段一般设置为只读，如果有用户程序对代码段进行写操作，系统会触发异常。 引申的物理内存管理：MMU负责对系统的物理内存资源进行管理，为用户程序提供物理内存的申请、释放等操作接口。 分段机制 目的：分段机制旨在将虚拟地址空间划分为不同的段，每个段对应一个连续的内存区域。\n工作原理：\n分段管理通过 段表（Segment Table） 映射虚拟地址和物理地址。 每个逻辑段都有一对基址寄存器和界限寄存器。 基址寄存器存储段的起始物理地址，界限寄存器定义了段的大小。 优点：\n灵活性：不同的段可以放置在不同的物理内存地址处，避免了虚拟地址空间中未使用部分占用内存。 共享：支持共享代码段等，确保多个进程共享某些段而不会出现问题。 缺点：\n外部碎片：段的大小不一，可能导致物理内存被分割成奇怪的大小，难以分配连续的内存。 内存分配请求复杂：需要解决外部碎片问题。 分段机制下的虚拟地址组成：\n段号 ：标识着该虚拟地址属于整个虚拟地址空间中的哪一个段。\n段内偏移量 ：相对于该段起始地址的偏移量。\n​\n段表中每个段的参数：\n段基地址：段在线性地址空间中的开始地址。 段限长：段内最大可用偏移地址，定义了段的长度。 段属性：指定段的特性，如可读、可写、可执行等。 具体的地址翻译过程如下：\n程序执行时，从进程控制块（PCB）中取出段表始址和段表长度，装入段表寄存器； MMU 解析得到虚拟地址中的段号和段内偏移量； 通过段号去该应用程序的段表中取出对应的段信息（找到对应的段表项）； 检查段内位移量是否超出该段的长度，若超过，产生越界中断； 从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址。 分页机制 目的：将用户程序的地址空间划分为固定大小的页，并将内存空间分成相应大小的物理块。\n工作原理：\n分页管理通过 页表（Page Table） 映射虚拟地址和物理地址。 用户程序的地址空间被划分成若干固定大小的区域，称为“页”。（虚拟页） 内存空间也分成若干个物理块，页和块的大小相等。（物理页） 可将用户程序的任一页放在内存的任一块中，实现了离散分配。 优点：\n内存利用率高：分页将内存划分为大小相等的页框，可以更有效地利用内存空间。 减少外部碎片：由于页的大小固定，不会产生外部碎片。 用户不可见：分页对用户是透明的，用户无需关心页的分配。 缺点：\n设计复杂：实现分页需要复杂的管理机制。 信息共享受限：页的大小由页框决定，一个页中可能包含多个逻辑模块，共享同一块内存不太合理。 分页机制下的虚拟地址组成：\n页号 ：通过虚拟页号可以从页表中取出对应的物理页号； 页内偏移量 ：物理页起始地址+页内偏移量=物理内存地址。 具体的地址翻译过程如下：\n程序执行时，从进程控制块（PCB）中取出页表始址和页表长度，装入页表寄存器； MMU 解析得到虚拟地址中的虚拟页号和页内偏移量； 通过页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）； 检查页号是否超出页表长度，若超过，产生越界中断。 用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。 多级别页表 以 32 位的环境为例，虚拟地址空间范围共有 $2^{32}$（4G）。假设 一个页的大小是 $2^{12}$（4KB），那页表项共有 4G / 4K = $2^{20}$ 个。每个页表项为一个地址，占用 4 字节（32位），也就是说一个程序啥都不干，页表大小就得占用 4M。\n系统运行的应用程序多起来的话，页表的开销还是非常大的。而且，绝大部分应用程序可能只能用到页表中的几项，其他的白白浪费了。\n为了解决这个问题，操作系统引入了 多级页表（Multi-Level Page Table） ，多级页表对应多个页表，每个页表也前一个页表相关联。32 位系统一般为二级页表，64 位系统一般为四级页表。多级页表属于时间换空间的典型场景，利用增加页表查询的次数减少页表占用的空间。\n我们看一下这个四级页表的例子，它的虚拟地址有 4级索引、3级索引、2级索引、1级索引 和 偏移量。\n每个进程会有一个 4级页表。检索的时候，我们先通过4级页表索引得到一个3级页表的位置，然后再根据3级页表索引找到该表中的条目，也就是一个2级页表，然后再根据2级页表索引获得一个1级页表，最后再根据该1级页表来获得最终的物理地址。\n所以根据上图，我们明白4级索引中可能会有很多种 1级页表、2级页表，甚至是 3 级页表。\n事实上，多级页表就像一个多叉树的数据结构，所以我们常常称它为页表树。因为虚拟内存地址分布的连续性，树的第一层节点的指针，很多就是空的，也就是不需要有对应的子树了。所谓不需要子树，其实就是不需要对应的 2 级、3 级的页表。找到最终的物理页号，就好像通过一个特定的访问路径，走到树最底层的叶子节点。\n最后，我们可以知道的是：如果用单级表进行存储，则需要将虚拟空间对物理空间的映射占满，这样不论是多大的进程都会分配到一样大的映射表；而用多级表进行存储，则可以只使用进程占用空间的映射，这样映射表的空间就每那么大，从而达到省下空间的效果。\n段页机制\n结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。\n在段页式机制下，地址翻译的过程分为两个步骤：\n段式地址映射。 页式地址映射。 快表 为了提高虚拟地址到物理地址的转换速度，操作系统在 页表方案 基础之上引入了 **转址旁路缓存(Translation Lookasjde Buffer，TLB，也被称为快表) ** 。\n在主流的 AArch64 和 x86-64 体系结构下，TLB 属于 (Memory Management Unit，内存管理单元) 内部的单元，本质上就是一块高速缓存（Cache），缓存了虚拟页号到物理页号的映射关系，你可以将其简单看作是存储着键（虚拟页号）值（物理页号）对的哈希表。\n使用 TLB 之后的 地址翻译流程 是这样的：\n用虚拟地址中的虚拟页号作为 key 去 TLB 中查询； 如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。 如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。 当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。 页缺失 页缺失（Page Fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等） 指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由 MMU 所发出的中断。\n硬性页缺失（Hard Page Fault） ：物理内存中没有对应的物理页。于是，Page Fault Hander 会指示 CPU 从已经打开的磁盘文件中读取相应的内容到物理内存，而后交由 MMU 建立相应的虚拟页和物理页的映射关系。 软性页缺失（Soft Page Fault）：物理内存中有对应的物理页，但虚拟页还未和物理页建立映射。于是，Page Fault Hander 会指示 MMU 建立相应的虚拟页和物理页的映射关系。 页面置换 当发生硬性页缺失时，如果物理内存中没有空闲的物理页面可用的话。操作系统就必须将物理内存中的一个物理页淘汰出去，这样就可以腾出空间来加载新的页面了。\n用来选择淘汰哪一个物理页的规则叫做 页面置换算法 ，我们可以把页面置换算法看成是淘汰物物理页的规则。\n最佳页面置换算法（OPT，Optimal） ：优先选择淘汰的页面是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，只是理论最优的页面置换算法，可以作为衡量其他置换算法优劣的标准。 先进先出页面置换算法（FIFO，First In First Out） : 最简单的一种页面置换算法，总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。该算法易于实现和理解，一般只需要通过一个 FIFO 队列即可需求。不过，它的性能并不是很好。 最近最久未使用页面置换算法（LRU ，Least Recently Used） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。LRU 算法是根据各页之前的访问情况来实现，因此是易于实现的。OPT 算法是根据各页未来的访问情况来实现，因此是不可实现的。 最少使用页面置换算法（LFU，Least Frequently Used） : 和 LRU 算法比较像，不过该置换算法选择的是之前一段时间内使用最少的页面作为淘汰页。 时钟页面置换算法（Clock） ：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。 文件系统 文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：\n存储管理 ：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。 文件管理 ：文件的创建、删除、移动、重命名、压缩、加密、共享等等。 目录管理 ：目录的创建、删除、移动、重命名等等。 文件访问控制 ：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。 软链接和硬链接 在 Linux/类 Unix 系统上，文件链接（File Link）是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：\n1、硬链接（Hard Link）\n在 Linux/类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。 只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。 硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。 ln 命令用于创建硬链接。 2、软链接（Symbolic Link 或 Symlink）\n软链接和源文件的 inode 节点号不同，而是指向一个文件路径。 源文件删除后，硬链接依然存在，但是指向的是一个无效的文件路径。 软连接类似于 Windows 系统中的快捷方式。 不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。 ln -s 命令用于创建软链接。 磁盘调度算法 先来先服务算法（First-Come First-Served，FCFS） ：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。FCFS 算法实现起来比较简单，不存在算法开销。不过，由于没有考虑磁头移动的路径和方向，平均寻道时间较长。同时，该算法容易出现饥饿问题，即一些后到的磁盘请求可能需要等待很长时间才能得到服务。 最短寻道时间优先算法（Shortest Seek Time First，SSTF） ：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。SSTF 算法能够最小化磁头的寻道时间，但容易出现饥饿问题，即磁头附近的请求不断被服务，远离磁头的请求长时间得不到响应。实际应用中，需要优化一下该算法的实现，避免出现饥饿问题。 扫描算法（SCAN） ：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。SCAN 算法能够保证所有的请求得到服务，解决了饥饿问题。但是，如果磁头从一个方向刚扫描完，请求才到的话。这个请求就需要等到磁头从相反方向过来之后才能得到处理。 循环扫描算法（Circular Scan，C-SCAN） ：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。 边扫描边观察算法（LOOK） ：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。LOOK 算法对 SCAN 算法进行了改进，如果磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向，依此往复。也就是边扫描边观察指定方向上还有无请求，因此叫 LOOK。 均衡循环扫描算法（C-LOOK） ：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。C-LOOK 算法对 C-SCAN 算法进行了改进，如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。 ","date":"2024-03-26T20:28:49+08:00","image":"https://yikuanzz.github.io/2024/%E6%B5%85%E8%81%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/cover_hu7463b4b34524b427fe5ff8175328084d_847514_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E6%B5%85%E8%81%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","title":"浅聊操作系统"},{"content":"计算机内可以存储各种各样的数据，例如：文本数据、图片数据、音频数据、视频数据等等。\n这些数据都会以 位（bit，或比特） 的形式储存在计算机内，并且它们的组织形式通常是一组，我们一般认为 8个位为 1个字节（byte）。\n计算机能处理的位数越多，那么它的速度就会越快。接下来，这篇文章会向读者介绍计算机是如何对其中的数据进行处理的。\n整数 人类的计数方式通常是“逢十进一”，称为 十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字0~9是目前最广泛采用的。\n计算机是用数字电路搭成的，数字电路中只有1和0两种状态，或者可以说计算机只有两个手指，所以对计算机来说 二进制（Binary） 是最自然的计数方式。根据“逢二进一”的原则，十进制的1、2、3、4分别对应二进制的1、10、11、100。\n计算机采用如下的逻辑电路计算两个 bit 的加法：\nBit Full Adder Sign and Magnitude表示法 我们如果用 8个 bit 表示正数和负数，那么一个简单的想法就是把最高位规定为 符号位（Sign Bit），这样一个字节的取值范围就是 -$2^7$-1 ~ $2^7$-1​。\n-1\t-\t10000001 +1\t-\t00000001 1.两个数的低7位相加的结果超出了范围，就会产生 溢出（Overflow），这时通常把计算机中的一个标志位置1表示当前运算产生了溢出。 2.两个符号位不同的数，一个大一个小，用大的数减小的数，符号位是大数的符号位。 3.零的表示有两种，一种是符号为 0 的正零，另一种是符号为 1 的负零。 4.两个数做减法的时候就需要进行转换，把加数先变成负数然后再进行加法运算。 我们可以发现，如果采用Sign and Magnitude表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。\nComplement表示法 一种更好的方法就是用二进制补码系统来表示有符号整数，因为它可以将减法运算转换为对减数的补数运算。\n补码的类型有两种：1位补码（1\u0026rsquo;s complement）和2位补码（2\u0026rsquo;s complement）。\n一位补码： 也称为原码。 正数的一位补码与其本身相同。 负数的一位补码为其绝对值的二进制形式，所有数字位取反，再加一。 二位补码： 也称为反码。 正数的二位补码与其本身相同。 负数的二位补码为在原码的基础上，符号位不变，其余位取反，再加一。 补数运算：\n以十进制为例，如果一个数是一位的，那么它与它的补数和总是 9，这样 2 的补数是 7；如果这个数是两位的，那么补数和就是99，那么 11 的补数是 88。\n以二进制为例，通常是 $n$ 位的运算，那么数 $P$ 的补数为 $Q$ 且 $P + Q = 2^n$。例如，01100101 的补数和是 100000000，求一个数的补数是取反加 1，这样 01100101 的补数就是 10011010 + 1 = 10011011。\n如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。如果溢出了，就要连接到溢出标志位去提示计算产生了溢出。\n​\n无符号二进制乘法 我们回顾一下平时使用的乘法，就是先把乘数的一部分先与被乘数相乘，记录下每个部分的乘积然后再将它们相加得到最终的结果。\n但实际上，计算的做法稍微有些不同，它在每次做运算的时候就先将部分积的值加到乘数中。\n布斯乘法 布斯乘法适用于，两个正数、一个正数和一个负数、两个负数相乘的情况。它与无符号数乘法很相似，我们对算法进行描述：\n对于 $N$ 位乘数 $Y$ ，布斯算法检查其 2 的补码形式的最后一位和一个隐含的低位，命名为 $y[i-1]$ ，初始值为 0 。对于 $y[i], i = 0, 1, \u0026hellip;, N - 1$，考察 $y[i]$ 和 $y[i - 1 ]$。当这两位相同时，存放积的累加器 $P$ 的值保持不变。当 $y[i] = 0$ 且 $y[i - 1] = 1$ 时，被乘数乘以 $2^i$ 加到 $P$ 中。当 $y[i]= 1$ 且 $y[i - 1] = 0$ 时，从 $P$ 中减去被乘数乘以 $2^i$ 的值。算法结束后， $P$ 中的数即为乘法结果。\n同样是 10x13 的这个例子，我们用布斯乘法计算无符号的乘法：\n上述式子结果高位溢出直接丢弃，结果就是：1000 0010。\n如果是对于无符号位的计算，则需要先将负数用原码进行表示，然后再进行计算：\n上述式子结果高位溢出直接丢弃，结果就是：00 1000 0010。\n除法 除法就是通过被除数不断减去除数直到结果为零或小于除数来实现的。\n减去除数的次数为 商（quotient）,最后一次减法的差为 余数（remainder）。\n与乘法的部分积类似，除法的话主要是对部分被除数做减法。\n我们先看看无符号除法的例子，575 ÷ 25：\n我们需要用文字描述这一个过程的实现，主要用以下这两种表述：\n1.恢复余数除法\n部分被除数初始化为被除数，除数对齐是通过位移实现的，书上的例子很清晰，这里就直接贴图，不做另外的解释了。\n2.不恢复余数除法\n浮点数 浮点数运算就是实数之间的运算，它不像整数运算，浮点数的计算结果一般是不确定的。\n浮点数表示也被称作 “科学计数法”，在十进制运算中，科学计数法表示的数字被写成：尾数 x $10^{指数 }$ 的形式，例如：$1.2345 \\times 10^{20}$，指数以 10 的整数倍将其扩大或缩小。\n二进制浮点数则表示为：尾数 x $2^{指数 }$，例如：$1.01010111 \\times 2^5$。\nIEEE 754 浮点数标准提供了 3 种浮点数表示：32 位单精度浮点数，64 位双精度浮点数，以及 128位四精度浮点数。\nIEEE（电气和电子工程师协会）\n电气和电子工程师协会 (IEEE, 读做 “eye- triple-ee”) 是一个包括所有电子和计技术的专业团体。它出版刊物，举办会议，并且建立委员会来定义标准，内容涉及从电力传输到软件工程。另一个 IEEE 标准的例子是无线网络的 802. 11 标准。\nIEEE 浮点表示 IEEE 浮点标准采用 $V = (-1)^s \\times F \\times 2^{E - 偏置常数}$ 的形式来表示一个数：\n符号（sign）$s$ 决定这个数是负数还是正数。 尾数（significand）$F$ 是一个二进制小数。 阶码（exponent）$E$ 的作用是对浮点数加权，$E_{min}-1$ 表示浮点 0，$E_{max}+1$ 表示正或负无穷大或 非数（Not a Number, NaN）。 为什么对指数进行偏置？（以单精度浮点数为例）\n因为单精度浮点数的指数部分使用 8 位来存储（范围:0~255），为了能够表示正负的指数所以我们减去一个偏移量得到：-126~+127。\n十进制转换为二进制浮点数\n将十进制数 $4100.125_{10} $ 转换为符合 IEEE 754 标准的 32位单精度二进制浮点数。\n首先将 $4100.125$ 转换为二进制定点数，整数部分 $4100_{10} = 10000000000100_2$，小数部分 $0.125_{10}=0.001_2$，所以 $4100.125_{10} = 10000000000100.001_2$。\n接下来对该二进制数进行规格化，就是将小数点左移变成 1.xxx 的形式，每左移动一次指数就加一：$1.0000000000100001 \\times 2^{12}$。\nS = 0 E = 12 + 127 = 10001011 F = 00000000010000100000000 浮点运算 浮点数不能直接相加，我们要先对齐浮点数的小数点，然后使它们的指数大小相同，然后才对尾数进行运算，最后再对结果进行规格化。\n下面给出书上的流程图，但要注意几点：\n因为指数有时和尾数位于同一个字中，所以在加法过程开始之前要将它们分开。 如果两个指数的差大于 $p+1$ ，这里 $p$ 为尾数的位数，那么较小的数就无法影响大的数。 结果规格化的时候会检查指数，看它是是否比最小指数小或比最大指数大，分别检测指数下溢或上溢，下溢会导致结果为 0，上溢会造成结果错误。 ","date":"2024-03-25T10:55:32+08:00","image":"https://yikuanzz.github.io/2024/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/cover_hu2a12c6b4de696aee97ce970a68d98a3e_1194101_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%9C%AF/","title":"计组-计算机算术"},{"content":"程序的基本概念 程序和编程语言 程序（Program） 是由一系列指令（Instruction）组成，它告诉计算机应如何完成一个计算任务。\n这些指令通常会有：输入（从输入设备中获取数据）、输出（在输出设备中输出数据）、基本运算（例如数学上的四则运算）、流程控制（条件分支或者循环其他指令）。\n编写程序就是将指令进行组合，来完成复杂任务。\n编程语言（Programming Language）分为低级语言（Low-level Language）和高级语言（High-level Language）。\n机器语言（Machine Language）和汇编语言（Assembly Language）属于低级语言，直接用计算机指令编写程序。而C、C++、Java、Python等属于高级语言，它们用语句（Statement）来编写程序，语句是计算机指令的抽象表示。\n编译器（Compiler）将C语言的语句编译（Compile）成汇编或机器指令，计算机才能执行。\n虽然说编译需要花费一些时间，但是这样会使编程变得更加容易。\nC语言是 可移植的（Portable） 的，为什么这么说呢。\n因为不同的计算机体系是有不同的指令集（Instruction Set）的，那么能识别到机器指令格式也不同。如果不同机器上都有C语言的编译器，那么我们就可以将C语言编译成不同机器都能识别的机器指令。\n那么，程序执行的流程就是：源码通过编译生成可执行文件，然后在操作系统上加载运行这个可执行程序。\n当然，如果是脚本语言，比如：Shell、Python等等，则省去编译的这个过程。\n程序的调试 程序的编写通常没有那么容易，程序中错误叫做 BUG，修正 BUG 的过程叫做 调试（Debug） ，程序中的 BUG 通常有这么几类：\n编译时错误，例如一些语法错误。 运行时错误，可以编译成可执行文件，但是在执行时程序会崩溃。 逻辑错误和语义错误，编译和执行都很顺利，但是没有按期望去执行。 第一个程序 我们将 C语言程序写在 main.c 的文件里。\n# include \u0026lt;stdio.h\u0026gt; int main(){ pritf(\u0026#34;Hello, World!\\n\u0026#34;); return 0; } 我们通过 gcc 对 C语言进行编译，它会将我们的 main.c 源代码编译生成可执行文件 a.out ，当然我们也可以指定其生成的文件名。\ngcc -Wall main.c -o main ./main\t# Hello, World! 一个好的习惯是打开 gcc 的 -Wall 选项，也就是让 gcc 提示所有的警告信息，不管是严重的还是不严重的，然后把这些问题从代码中全部消灭。\n常量、变量和表达式 简单的规则 # include \u0026lt;stdio.h\u0026gt; // 单行注释 /* 多行注释 */ int main(void){ printf(\u0026#34;注释不会影响编译！\u0026#34;); return 0; } 除了注释，我们用到了由双引号（Double Quote）引起来的一串字符，它称为 字符串字面值（String Literal） 或者字符串。\n打印的时候，我们并不会打印双引号，因为它是字符串字面值的界定符号。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ printf(\u0026#34;Hello, world.\\n\u0026#34;); printf(\u0026#34;Goodbye, \u0026#34;); printf(\u0026#34;cruel world!\\n\u0026#34;); return 0; } 上面的代码中，我们用到了 转义序列（Escape Sequence） ，它们代表着一些特殊的意义。\n\\n：换行符号。 \\t：制表符号。 \\b：回退符号。 常量 常量（Constant） 是程序中最基本的元素，有字符（Character）常量、整数（Integer）常量、浮点数（Floating Point）常量和枚举常量。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ printf(\u0026#34;character: %c\\ninteger: %d\\nfloating point: %f\\n\u0026#34;, \u0026#39;}\u0026#39;, 34, 3.14); return 0; } 这里需要注意的是，计算机中整数和小数点内部表达方式不同，这是因为它们的基本存储方法不同。\n其中，%c、%f、%d 是字符类型的转换说明，这种用法通常叫做占位符（Placeholder），只是在打印输出的时候改变显示的内容，但不是对实际的内容进行修改。\n变量 变量（Variable） 是编程语言最重要的概念之一，变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value）。\nC语言规定必须以字母或下划线_（Underscore）开头，后面可以跟若干个字母、数字、下划线，但不能有其它字符。\n# include \u0026lt;stdio.h\u0026gt; int main(){ // 变量声明 char cc;\t// 字符型变量 int bb;\t// 整型变量 float ss;\t// 单精度浮点数 double tom;\t// 双精度浮点数 return 0; } C语言中的声明（Declaration）有变量声明、函数声明和类型声明三种。如果一个变量或函数的声明要求编译器为它分配存储空间，那么也可以称为定义（Definition），因此定义是声明的一种。\n赋值 声明或定义了变量之后，我们要把值存到它们所表示的存储空间里，可以用赋值（Assignment）语句。\n变量的定义和赋值也可以一步完成，这称为变量的 初始化（Initialization）。\n# include \u0026lt;stdio.h\u0026gt; int main(){ // 变量赋值 char firstletter; int hour, minute; firstletter = \u0026#39;a\u0026#39;; /* give firstletter the value \u0026#39;a\u0026#39; */ hour = 11; /* assign the value 11 to hour */ minute = 59; /* set minute to 59 */ return 0; } 注意变量一定要先声明后使用，它们代表着各自的存储空间，编译器必须先看到变量声明，才知道怎么对变量进行读写。\n表达式 常量和变量都可以参与加减乘除运算，比如 +、-、*、/ 就代表着四则运算的符号，就叫运算符（Operator），参与运算的变量叫操作数（Operand）比如 a + b ，a 和 b 就是操作数，而 a + b 这一整个式子，就是表达式（Expression）\n# include \u0026lt;stdio.h\u0026gt; int main(){ int total_minute; total_minute = hour * 60 + minute; } 字符类型和字符编码 # include \u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;%c\\n\u0026#34;, \u0026#39;a\u0026#39;+1); } 在计算机内，每个符号都有对应的整数来进行表示，我们称为 字符编码（Character Encoding） ，最常用的字符编码规则就是 ASCII码（American Standard Code for Information Interchange，美国信息交换标准码）。\n简单函数 数学函数 在数学中我们用过sin和ln这样的函数，例如sin(π/2)=1，ln1=0等等，在C语言中也可以使用这些函数。\n# include \u0026lt;math.h\u0026gt; # include \u0026lt;stdio.h\u0026gt; int main(void){ double pi = 3.1416; printf(\u0026#34;sin(pi/2)=%f\\nln1=%f\\n\u0026#34;, sin(pi/2), log(1.0)); return 0; } 我们编译运行这个程序。\ngcc main.c ./a.out\t# sin(pi/2)=1.000000 ln1=0.000000 上面的代码中，log 我们叫它 函数（Function） log(1.0) 我们叫函数调用（Function Call），这些函数就放在 math.h 的这个文件内，所以要使用这些函数就要导入这个文件。\n其实，我们已经接触过函数了，就是我们的 main 函数，它前面的 int 是指函数运行完毕后返回的值类型是一个整数，return 语句负责函数的返回。\n自定义函数 #include \u0026lt;stdio.h\u0026gt; void newline(void) { printf(\u0026#34;\\n\u0026#34;); } void threeline(void) { newline(); newline(); newline(); } int main(void) { printf(\u0026#34;Three lines:\\n\u0026#34;); threeline(); printf(\u0026#34;Another three lines.\\n\u0026#34;); threeline(); return 0; } 上述代码说明了几个事情，就是函数的调用只需要写它的函数名和圆括号就行了，除非它有要求参数，不然就不用进行参数传递。\n此外，如果函数没返回值，那么在定义的时候写上 void，这样函数就不用写 return 语句了。\n最后，同一个函数是可以被多次调用的，但是要在调用前进行定义。\n形参和实参 #include \u0026lt;stdio.h\u0026gt; void print_time(int hour, int minute) { printf(\u0026#34;%d:%d\\n\u0026#34;, hour, minute); } int main(void) { print_time(23, 59); return 0; } 形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化，如果我们对形参进行修改，结果并不会影响到实际参数。\n其实就是相当于将实际参数复制了一份给函数内部进行使用，使用完后，形式参数就会被回收。\n全局变量、局部变量 我们把函数中定义的变量称为 局部变量（Local Variable） 。它的含义是，函数中定义的变量不能被其他函数使用，每次调用函数的时候会创建新的局部变量，它们的存储空间是不同的。\n全局变量（Global Variable），全局变量定义在所有的函数体之外，它们在程序开始运行时分配存储空间，在程序结束时释放存储空间，在任何函数中都可以访问全局变量。\n分支语句 if 语句 # include \u0026lt;stdio.h\u0026gt; int main(){ int x = 12; if (x != 0) { printf(\u0026#34;x is nonzero.\\n\u0026#34;); } } 其中，!= 表示不等于的意思，x != 0这个表达式称为 控制表达式（Controlling Expression），如果条件成立，那么 {} 里面的语句就会执行，否则就不执行。\n!= 是关系运算符，此外还有 == 表示相等的关系运算符，自然还有其他的关系运算符，这里就按下不表了。\nif/else 语句 # include \u0026lt;stdio.h\u0026gt; int main(){ int x = 7; // if - else if (x % 2 == 0) printf(\u0026#34;x is even.\\n\u0026#34;); else printf(\u0026#34;x is odd.\\n\u0026#34;); // if - else if - else if (x \u0026gt; 0) printf(\u0026#34;x is positive.\\n\u0026#34;); else if (x \u0026lt; 0) printf(\u0026#34;x is negative.\\n\u0026#34;); else printf(\u0026#34;x is zero.\\n\u0026#34;); } 通常 if 语句与 else 语句搭配使用，要解释一下的是 % ，它是取模（Modulo）运算符，计算余数用的。\n布尔代数 # include \u0026lt;stdio.h\u0026gt; int main(){ int a = 1, b = 2, c =3; if (a \u0026lt; b \u0026amp;\u0026amp; b \u0026lt; c) { printf(\u0026#34;b is between a and c.\\n\u0026#34;); } return 0; } 其中 \u0026amp;\u0026amp; 是逻辑运算符号，叫做逻辑与（Logical AND），仅仅当左右两边的条件成立时才为真。此外，还有逻辑或（Logical OR）||，仅有一个条件成立就为真。逻辑非（Logical NOT）! ，直接取反条件。\nswtich 语句 # include \u0026lt;stdio.h\u0026gt; void print_day(int day){ switch (day){ case 1: case 2: case 3: case 4: case 5: printf(\u0026#34;Work Day！\u0026#34;); break; case 6: case 7: printf(\u0026#34;Weekend!\u0026#34;); break; default: printf(\u0026#34;Illegal Day Number!\u0026#34;); break; } } int main(){ printf_day(2); return 0; } 深入理解函数 return 语句 # include \u0026lt;stdio.h\u0026gt; int absolute_value(int x) { if (x \u0026lt; 0) { return -x; } else if (x \u0026gt; 0) { return x; } } int main(){ printf(absolute_value(-10)); return 0; } 函数返回一个值相当于定义一个和返回值类型相同的临时变量并用 return 后面的表达式来初始化。\n增量式开发 增量式（Incremental） 开发的思路就是将大的问题分成小的问题，然后再让小问题分成更小的问题，这个过程在代码中的体现就是函数的分层设计（Stratify）。\n编写一个程序求圆的面积，圆的半径以两个端点的座标(x1, y1)和(x2, y2)给出。\n1、根据两点坐标求出圆的半径。 2、根据半径求出圆的面积。 # include \u0026lt;stdio.h\u0026gt; double distance(double x1, double y1, double x2, double y2){ return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2)); } double area(double r){ return r*r*3.1416; } int main(){ printf(are(distance(1.0, 2.0, 4.0, 6.0))); return 0; } 递归 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ if (n == 0){ return 1; } return factorial(n-1)*n } int Fibonacci(int n){ if (n == 0 || n == 1){ return n } return Fibonacci(n-1) + Fibonacci(n-2) } int main(){ // 阶乘 printf(\u0026#34;10的阶乘是：%d\u0026#34;, factorial(10)); // 斐波那契 printf(\u0026#34;第10项的斐波那契数是：%d\u0026#34;, Fibonacci(10)); } 循环语句 while 语句 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ int result = 1; while (n \u0026gt; 0) { result = result * n; n = n - 1; } return result; } int main(){ printf(factorial(10)); return 0; } do while 语句 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ int result = 1; int i = 1; do { result = result * i; i = i + 1; } while (i \u0026lt;= n); return result; } int main(){ printf(factorial(10)); return 0; } for 语句 # include \u0026lt;stdio.h\u0026gt; int factorial(int n){ int result = 1; int i; for(i = 1; i \u0026lt;= n; ++i) result = result * i; return result; } int main(){ printf(factorial(10)); return 0; } break 和 continue #include \u0026lt;stdio.h\u0026gt; int is_prime(int n){ int i; for (i = 2; i \u0026lt; n; i++) if (n % i == 0) break; if (i == n) return 1; else return 0; } int main(void){ int i; for (i = 1; i \u0026lt;= 100; i++) { if (!is_prime(i)) continue; printf(\u0026#34;%d\\n\u0026#34;, i); } return 0; } 结构体 复合类型与结构体 根据语法规则由基本类型组合而成的类型称为 复合类型（Compound Type），例如字符串是由很多字符组成的。\n现在，我们用 C语言来表示一个复数：从直角坐标系来看，复数由实部和虚部组成；从极座标系来看，复数由模和辐角组成，两种座标系可以相互转换。\n# include \u0026lt;stdio.h\u0026gt; struct complex_struct{ double x, y; }z1, z2; int main(){ // 结构体字段赋值 z1.x = 3.0; z1.y = 4.0; // 结构体的初始化 struct complex_struct z3 = {0}; } 数据抽象 用 C 语言实现一个完整的复数运算程序。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;math.h\u0026gt; struct complex_struct{ double x, y; }; double real_part(struct complex_struct z){ return z.x; } double img_part(struct complex_struct z){ return z.y; } double magnitude(struct complex_struct z){ return sqrt(z.x*z.x + z.y*z.y); } double angle(struct complex_struct z){ return atan2(z.y, z.x) } struct complex_struct make_from_real_img(double x, double y){ struct complex_struct z; z.x = x; z.y = y; return z; } struct complex_struct make_from_mag_ang(double r, double A){ struct complex_struct z; z.x = r * cos(A); z.y = r * sin(A); return z; } struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2) { return make_from_real_img(real_part(z1) + real_part(z2), img_part(z1) + img_part(z2)); } struct complex_struct sub_complex(struct complex_struct z1, struct complex_struct z2){ return make_from_real_img(real_part(z1) - real_part(z2), img_part(z1) - img_part(z2)); } struct complex_struct mul_complex(struct complex_struct z1, struct complex_struct z2){ return make_from_mag_ang(magnitude(z1) * magnitude(z2), angle(z1) + angle(z2)); } struct complex_struct div_complex(struct complex_struct z1, struct complex_struct z2){ return make_from_mag_ang(magnitude(z1) / magnitude(z2), angle(z1) - angle(z2)); } int main(){ return 0; } 数据类型标志 通过枚举类型，定义复数的类型。\n# include \u0026lt;stdio.h\u0026gt; enum coordinate_type { RECTANGULAR, POLAR }; struct complex_struct { enum coordinate_type t; double a, b; }; int main(){ return 0; } 数组 数组的基本概念 数组（Array） 也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。它的特点就是这些元素是相邻存储的，并且其中的每个元素可以通过下标索引进行访问。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ int count[4] = { 3, 2, }, i; for (i = 0; i \u0026lt; 4; i++) printf(\u0026#34;count[%d]=%d\\n\u0026#34;, i, count[i]); return 0; } 我们做一个案例：要求成一列0~9的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;stdlib.h\u0026gt; # define N 10000 int a[N]; void gen_random (int upper_bound){ int i ; for (i = 0; i \u0026lt; N; i++) a[i] = rand() % upper_bound; } void print_random(){ int i; for (i = 0; i \u0026lt; N; i++) printf(\u0026#34;%d \u0026#34;, a[i]); printf(\u0026#34;\\n\u0026#34;); } int howmany(int value){ int count = 0, i; for (i = 0; i \u0026lt; N; i++) if (a[i] == value) ++count; return count; } int main(){ int i; gen_random(10); printf(\u0026#34;value\\thow many\\n\u0026#34;); for (i = 0; i \u0026lt; 10; i++) printf(\u0026#34;%d\\t%d\\n\u0026#34;, i, howmany(i)); return 0; } 然后我们使用 -E 可以看到预处理（Preprocess）阶段之后、编译之前的程序。\ngcc -E main.c 这里预处理器做了两件事情，一是把头文件 stdio.h 和 stdlib.h 在代码中展开，二是把 #define 定义的标识符 N 替换成它的定义20。\n字符串 字符串可以看作一个数组，它的每个元素是字符型的。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ // 通过下标获取字符串的字符 char c = \u0026#34;Hello, world.\\n\u0026#34;[0]; // 字符数组存储字符串 char str1[10] = { \u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;\\0\u0026#39; }; char str2[10] = \u0026#34;Hello, world.\\n\u0026#34;; char str3[] = \u0026#34;Hello, world.\\n\u0026#34;; print(\u0026#34;字符是：%c\u0026#34;, c); print(\u0026#34;字符串是：%s\u0026#34;, str3); return 0; } 数组后面元素没有指定，就会自动初始化为 0，就是 Null 字符。当然，以 \\0 为结尾的也叫字符串，所以只要是 Null 字符结尾，那么就是字符串。\n多维数组 多维数组（Multi-dimensional Array） 就是在数组里面嵌套数组。\n# include \u0026lt;stdio.h\u0026gt; int main(void){ // a -\u0026gt; a[0]、a[1]、a[2] int a[3][2] = { 1, 2, 3, 4, 5}; int b[][2] = { { 1, 2 }, { 3, 4 }, { 5, } }; return 0; } 简单的小游戏 - 剪刀石头布\n# include \u0026lt;stdio.h\u0026gt; # include \u0026lt;stdlib.h\u0026gt; # include \u0026lt;time.h\u0026gt; int main(void){ char gesture[3][10] = {\u0026#34;剪刀\u0026#34;, \u0026#34;石头\u0026#34;, \u0026#34;布\u0026#34;}; int man, computer, result, ret; srand(time(NULL)); printf(\u0026#34;现在开始剪刀石头布游戏！\\n\u0026#34;); while (1){ computer = rand() % 3; printf(\u0026#34;请选择(剪刀-0，石头-1，布-2)：\u0026#34;); ret = scanf(\u0026#34;%d\u0026#34;, \u0026amp;man); if (ret != 1 || man \u0026lt; 0 || man \u0026gt; 2) { printf(\u0026#34;无效输入! 请输入 0, 1 或 2.\\n\u0026#34;); sleep(3); system(\u0026#34;clear\u0026#34;); continue; } printf(\u0026#34;你出了: %s\\t电脑出了: %s\\n\u0026#34;, gesture[man], gesture[computer]); result = (man - computer + 4) % 3 - 1; if (result \u0026gt; 0) printf(\u0026#34;你赢了!\\n\u0026#34;); else if (result == 0) printf(\u0026#34;平局!\\n\u0026#34;); else printf(\u0026#34;你输了!\\n\u0026#34;); sleep(3); system(\u0026#34;clear\u0026#34;); } } GDB调试 调试工具 gdb，可以完全操控程序的运行。\n调试的基本思想就是“分析现象-\u0026gt;假设错误原因-\u0026gt;产生新的现象去验证假设”这样一个循环。\n单步执行和跟踪函数调用 #include \u0026lt;stdio.h\u0026gt; int add_range(int low, int high){ int i, sum; for (i = low; i \u0026lt;= high; i++) sum = sum + i; return sum; } int main(void){ int result[100]; result[0] = add_range(1, 10); result[1] = add_range(1, 100); printf(\u0026#34;result[0]=%d\\nresult[1]=%d\\n\u0026#34;, result[0], result[1]); return 0; } 在编译时要加上 -g 选项，生成的可执行文件才能用 gdb 进行源码级调试：\ngcc -g main.c -o main 通过 gdb 命令进入调试：\ngdb main 这里要说明的是，gdb 并不是将源码嵌入到可执行文件中的，它也是从外部获取源码来进行调试分析的。\n我们通过 start 命令开始调试，gdb 会停在变量定义后的第一条语句等待我们的命令，可以使用 next 进行下一步语句：\n(gdb) start Temporary breakpoint 1 at 0x400568: file zz2.c, line 14. Starting program: /root/testdir/zz2 Temporary breakpoint 1, main () at zz2.c:14 14 result[0] = add_range(1, 10); (gdb) next 15 result[1] = add_range(1, 100); 此外，我们还可以通过 step 命令就进入到函数的执行中：\n(gdb) start The program being debugged has been started already. Start it from the beginning? (y or n) y Temporary breakpoint 2 at 0x400568: file zz2.c, line 14. Starting program: /root/testdir/zz2 Temporary breakpoint 2, main () at zz2.c:14 14 result[0] = add_range(1, 10); (gdb) step add_range (low=1, high=10) at zz2.c:5 5 int i, sum = 0; 使用 backtrace 命令可以查看函数调用的栈帧：\n(gdb) backtrace #0 add_range (low=1, high=10) at zz2.c:5 #1 0x0000000000400577 in main () at zz2.c:14 可见当前的 add_range 函数是被 main 函数调用的，main 传进来的参数是 low=1, high=10。main 函数的栈帧编号为1，add_range 的栈帧编号为 0 。现在可以用 info 命令查看 add_range 函数局部变量的值：\n(gdb) info locals i = 32767 sum = -138851417 如果初始化有错误，我们也可以直接修改初始化变量：\n(gdb) set sum = 0 (gdb) info locals i = 32767 sum = 0 如果想查看 main 函数当前局部变量的值也可以做到，先用 frame 命令选择 1 号栈帧然后再查看局部变量：\n(gdb) frame 1 #1 0x0000000000400570 in main () at zz2.c:14 14 result[0] = add_range(1, 10); (gdb) info locals result = {0, 0, 4, 0, 0, 0, -8264, 32767, -8304, 32767, 0, 0, -8208, 32767, -134223256, 32767, -134224160, 32767, -136425313, 32767, 0, 0, -8208, 32767, 0, 0, 0, 0, 0, 832, -134224160, 32767, 960, 1472, 2496, 2496, 2496, 2496, 2496, 2496, 0, 0, -134223256, 32767, -8448, 32767, -8464, 32767, 1700966438, 0, -138851417, 32767, 11538501, 0, -140227432, 32767, -8368, 32767, -138865760, 32767, 256, 64, 118, 0, -8368, 32767, 194, 0, -8272, 32767, -8256, 32767, 9, 0, -139772531, 32767, 118, 0, 0, 0, 0, 0, 15775231, 0, 1, 0, 4195837, 0, -8272, 32767, 0, 0, 4195760, 0, 4195392, 0, -8048, 32767, 0, 0} 通过 print 命令还可以直接打印变量的值：\n(gdb) print sum $1 = 0 最后，可以使用 finish 函数让程序运行到从当前函数返回为止：\n(gdb) finish Run till exit from #0 add_range (low=1, high=10) at zz2.c:7 0x0000000000400577 in main () at zz2.c:14 14 result[0] = add_range(1, 10); Value returned is $2 = 55 断点 #include \u0026lt;stdio.h\u0026gt; int main(void){ int sum = 0, i = 0; char input[5]; while (1) { scanf(\u0026#34;%s\u0026#34;, input); for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) sum = sum*10 + input[i] - \u0026#39;0\u0026#39;; printf(\u0026#34;input=%d\\n\u0026#34;, sum); } return 0; } 程序的作用是：首先从键盘读入一串数字存到字符数组 input 中，然后转换成整型存到 sum 中，然后打印出来，一直这样循环下去。\n例如输入是 \u0026quot;2345\u0026quot; ，则循环累加的过程是 (((0*10+2)*10+3)*10+4)*10+5=2345。\n我们可以用 display 命令使得每次停下来的时候都显示当前sum的值，然后继续往下走：\n(gdb) display sum 1: sum = 0 (gdb) next 10 scanf(\u0026#34;%s\u0026#34;, input); 1: sum = 0 undisplay 命令可以取消跟踪显示，变量 sum 的编号是1，可以用 undisplay 1 命令取消它的跟踪显示：\n(gdb) n 10 scanf(\u0026#34;%s\u0026#34;, input); 1: sum = 123345 (gdb) undisplay 1 通过 break 命令在第 10 行打个断点，然后用 continue 连续运行到达断点：\n(gdb) list 10 5 int sum = 0, i = 0; 6 char input[5]; 7 8 while (1) 9 { 10 scanf(\u0026#34;%s\u0026#34;, input); 11 for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) 12 sum = sum * 10 + input[i] - \u0026#39;0\u0026#39;; 13 printf(\u0026#34;input=%d\\n\u0026#34;, sum); 14 } (gdb) break 10 Breakpoint 2 at 0x4005b3: file zz3.c, line 10. (gdb) continue Continuing. 123 input=123345123 Breakpoint 2, main () at zz3.c:10 10 scanf(\u0026#34;%s\u0026#34;, input); 我们可以用 info 命令查看断点情况：\n(gdb) info breakpoint Num Type Disp Enb Address What 2 breakpoint keep y 0x00000000004005b3 in main at zz3.c:10 breakpoint already hit 2 times 我们可以用 disable 命令禁用断点，用 enable 重新启用断点，用 delete 删除断点：\n(gdb) disable breakpoints 2 (gdb) info breakpoints Num Type Disp Enb Address What 2 breakpoint keep n 0x00000000004005b3 in main at zz3.c:10 breakpoint already hit 2 times (gdb) enable 2 (gdb) info breakpoints Num Type Disp Enb Address What 2 breakpoint keep y 0x00000000004005b3 in main at zz3.c:10 breakpoint already hit 2 times (gdb) delete breakpoints Delete all breakpoints? (y or n) t Please answer y or n. Delete all breakpoints? (y or n) y (gdb) info breakpoints No breakpoints or watchpoints. gdb 的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当sum不等于0时才中断，然后用 run 命令重新从程序开头连续运行：\n(gdb) break 10 if sum != 0 Breakpoint 3 at 0x4005b3: file zz3.c, line 10. (gdb) i breakpoints Num Type Disp Enb Address What 3 breakpoint keep y 0x00000000004005b3 in main at zz3.c:10 stop only if sum != 0 (gdb) run The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /root/testdir/zz3 123 input=123 Breakpoint 3, main () at zz3.c:10 10 scanf(\u0026#34;%s\u0026#34;, input); 2: sum = 123 想要退出 gbd 调试的话，只需要输入 quit 就可以了：\n(gdb) quit A debugging session is active. Inferior 1 [process 14749] will be killed. Quit anyway? (y or n) y 观察点 #include \u0026lt;stdio.h\u0026gt; int main(void) { int sum = 0, i = 0; char input[5]; while (1) { sum = 0; scanf(\u0026#34;%s\u0026#34;, input); for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) sum = sum*10 + input[i] - \u0026#39;0\u0026#39;; printf(\u0026#34;input=%d\\n\u0026#34;, sum); } return 0; } 如果我们想查看某个数的输出可以用 x 来输出：\n(gdb) n 11 scanf(\u0026#34;%s\u0026#34;, input); (gdb) n 12345 12 for (i = 0; input[i] != \u0026#39;\\0\u0026#39;; i++) (gdb) x/8b input 0x7fffffffdfa0: 0x31 0x32 0x33 0x34 0x35 0x00 0x00 0x00 如果我们想观察某个值的变化，可以用 watch 来设置观察点：\n(gdb) watch input[0] Hardware watchpoint 4: input[0] (gdb) c Continuing. input=12345 234 Hardware watchpoint 4: input[0] Old value = 49 \u0026#39;1\u0026#39; New value = 50 \u0026#39;2\u0026#39; 0x00007ffff7a68382 in __GI__IO_vfscanf () from /lib64/libc.so.6 段错误 如果程序运行时出现段错误，用 gdb 可以很容易定位到究竟是哪一行引发的段错误：\n#include \u0026lt;stdio.h\u0026gt; int main(void) { int man = 0; scanf(\u0026#34;%d\u0026#34;, man); return 0; } 然后我们用 gdb 调试这段程序：\n(gdb) run Starting program: /root/testdir/zz5 123 Program received signal SIGSEGV, Segmentation fault. 0x00007ffff7a69341 in __GI__IO_vfscanf () from /lib64/libc.so.6 (gdb) backtrace #0 0x00007ffff7a69341 in __GI__IO_vfscanf () from /lib64/libc.so.6 #1 0x00007ffff7a790b9 in __isoc99_scanf () from /lib64/libc.so.6 #2 0x0000000000400580 in main () at zz5.c:6 gdb 显示段错误出现在 _IO_vfscanf 函数中，用 bt 命令可以看到这个函数是被我们的 scanf 函数调用的，所以是 scanf 这一行代码引发的段错误。仔细观察程序发现是 man 前面少了个 \u0026amp;。\n","date":"2024-03-24T14:37:07+08:00","image":"https://yikuanzz.github.io/2024/linux-c%E4%B8%80%E5%85%A5%E9%97%A8/cover_huc77e13b628f6c253544f486e9b91b9b1_1927448_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/linux-c%E4%B8%80%E5%85%A5%E9%97%A8/","title":"Linux C（一）入门"},{"content":"开发技术革新 CGI 通用网关接口 通用网关接口（Common Gateway Interface, CGI） 是一种Web服务器与外部应用程序之间进行数据交互的标准协议。\n背景： 早期的Web服务器只能响应浏览器发来的HTTP静态资源请求，并将存储在服务器中的静态资源返回给浏览器。 随着Web技术的发展，动态技术逐渐出现，但Web服务器不能直接运行动态脚本。 为了解决Web服务器与外部应用程序（即CGI程序）之间的数据互通问题，CGI（通用网关接口）应运而生。 工作原理： CGI允许Web服务器获取客户端提交的信息，并将其传递给服务端的CGI程序进行处理，然后将结果返回给客户端。 CGI通信系统由两部分组成: HTML页面：显示在用户浏览器上的页面。 运行在服务器上的CGI程序：处理客户端提交的数据。 一次网页请求与响应的过程如下： 浏览器通过URL请求一个网页，服务器返回该网页文件。 通常我们看到的网页是动态生成的，比如PHP/JSP网页，根据请求参数不同返回不同内容。 类似地，请求一个CGI程序时，CGI程序解析前端传递的参数，理解意图并返回数据，如HTML、XML或JSON等。 前端知识： 前端页面发送数据的方式包括： 表单提交（HTML原生）。 JavaScript操作表单提交。 JavaScript通过Ajax请求数据。 \u0026lt;!-- 用户访问时就会访问，cgi-bin 下对应对的脚本 --\u0026gt; \u0026lt;form action=\u0026#34;/cgi-bin/hello.cgi\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;用户名：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input name=\u0026#34;username\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;密码：\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input name=\u0026#34;password\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;OK\u0026#34;/\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/form\u0026gt; MVC （Model-View-Controller） MVC（Model-View-Controller） 是一种常见的软件架构模式，广泛应用于Web应用程序和桌面应用程序的开发。在这种模式下，应用程序被分为三个不同的部分：\n模型（Model）： 负责处理应用程序的业务逻辑和数据。 模型不包含与数据显示相关的代码，只关注数据的处理和业务规则的执行。 视图（View）： 负责显示数据给用户，以及与用户的交互功能，例如表单、网页等。 视图是应用程序的外观，通常由HTML、JSP等实现。 控制器（Controller）： 类似于一个分发器，用来决定对于视图发来的请求，需要用哪一个模型来处理，以及处理完后需要跳回到哪一个视图。 控制器连接视图和模型，协调它们之间的交互。 MVC模式的流程如下：\n浏览器通过视图向控制器发出请求。 控制器接收请求，选择合适的模型进行处理。 处理完请求后，控制器再转发到视图，进行视图界面的渲染并做出最终响应。 在MVC模式中，视图可以用JSP、HTML、CSS实现，模型可以用JavaBean实现，而控制器通常使用Servlet来实现。这种分层架构使得应用程序更易于维护、扩展和重用。\n另外，还有一个与MVC类似的架构模式叫做三层架构，它将应用程序分为表示层、业务逻辑层和数据访问层。这三层各自负责不同的功能，也有助于代码的分层和复用。\n后台服务化与前端一致化 后台服务化和前端一致化架构是现代软件开发中的两个关键概念。\n后台服务化： 在传统的软件架构中，前端和后端是分离的。前端专注于页面渲染，而后台则处理业务逻辑。前后端之间最常见的交互方式是通过接口实现的。 后台服务化的架构将后端业务逻辑进一步拆分成独立的服务。每个服务负责特定的功能，例如用户管理、订单处理、支付等。 这种架构有助于提高系统的可维护性、扩展性和性能。它允许不同的团队并行开发不同的服务，而无需相互干扰。 前端一致化架构： 前端一致化架构旨在解决前端开发中的一些痛点。 传统的前端开发模式中，前端工程师负责将设计图切成 HTML 页面，而后端工程师负责将 HTML 转换为 JSP 页面并处理逻辑和数据展示。 这种模式导致了人员分工不明、效率低下以及不利于项目迭代等问题。 前端一致化架构通过前后端分离，让前端专注于页面展示，后端只提供接口数据。这样可以降低耦合度，提高开发效率，同时满足多端应用开发的需求。 开发模式革新 瀑布开发 瀑布模型（也称为Waterfall Model）是一种软件生命周期模型，其开发过程按照一系列阶段的顺序展开，从系统需求分析开始，直到产品发布和维护。这个模型的名称来源于项目开发进程从一个阶段“流动”到下一个阶段，就像瀑布流水逐级下落。\n瀑布模型的核心思想是将问题分解为工序，将功能的实现与设计分开，以便于分工协作。它将软件生命周期划分为以下六个基本活动，并规定了它们自上而下、相互衔接的固定次序：\n制定计划：确定项目的范围、时间和资源。 需求分析：收集、分析和定义系统需求。 软件设计：设计系统的架构、模块和接口。 程序编写：根据设计规范编写代码。 软件测试：验证系统是否满足需求并修复错误。 运行维护：发布产品并进行后续维护。 瀑布模型的优点和缺点如下：\n优点： 强制开发人员采用规范的方法（如结构化技术）。 严格规定每个阶段必须提交的文档。 要求所有产品都必须经过质量保证小组的仔细验证。 缺点： 瀑布模型依赖于书面的规格说明，用户只能通过文档来了解产品。 可能导致最终开发出的软件产品不能真正满足用户的需求。 不适合需求模糊的系统。 此外，还有一种加入迭代过程的瀑布模型，用于解决传统瀑布模型过于理想化的问题。在这种模型中，当后续阶段发现前面阶段的错误时，需要返回前面的阶段进行修改，以确保产品质量。\n总之，瀑布模型在软件开发中曾经广泛采用，但现在更多的团队倾向于使用敏捷方法，以更灵活和迭代的方式开发软件。\n敏捷开发 敏捷开发是一种高效的软件开发方法，起源于美国。许多大型公司为了提高产品的开发效率，已经开始运用敏捷开发。让我用通俗易懂的语言解释一下：\n迭代开发： 敏捷开发的核心是迭代开发。 迭代开发通过短期增量（通常称为冲刺）的方式来完成工作，从而缩短开发周期。 每个冲刺通常为一到四周。 在敏捷开发中，软件项目被切分成多个子项目，每个子项目都经过测试，具备可视、可集成和可运行的特征。 换言之，就是把一个大项目分成多个相互联系、但也可独立运行的小项目，并分别完成。在此过程中，软件一直处于可使用状态。 优势和不足： 优势： 敏捷开发将一艘大船变成许多条小船，每条小船各司其职，分配小目标，所有的小目标合起来就能完成大目标。 效率高，每个人职责分明。 不足： 小团队难以拥有开阔的视野，看不到全局。 对于不可分割的大需求，敏捷开发不再合适。 敏捷开发适用于成熟的应用做高效的版本迭代，对于初创型或快速增长的公司不适合。 混合式开发： 对于大需求，可以采用传统的瀑布式开发。 对于小优化和小迭代，可以采用敏捷开发。 现在很多大型公司结合了两者的优势。 产品经理在敏捷开发团队中的不同： 敏捷开发中，产品经理有更多时间思考产品细节，不用花太多时间在沟通和传递需求上。 敏捷开发让产品经理更专注于大方向的事务。 总之，敏捷开发是一种高效、迭代式的开发方法，适用于成熟的应用做版本迭代。\n​\n精益开发 精益开发是一种用于开发产品和服务的方法论，旨在缩短产品开发周期，并快速发现产品创意构思是否可行。它通过采用商业假设驱动的实验、迭代产品发布和验证学习的组合来实现。\n让我们深入了解一下精益开发的核心思想和原则：\n杜绝浪费： 将所有的时间花在能够增加客户价值的事情上。 除去不必要的环节，专注于创造价值的活动。 推迟决策： 保持可选方案的开放性，但时间不能过长。 尽可能多地提出可行方案，但不要拖延决策。 加强学习： 使用科学的学习方法。 培养有战斗力的团队，持续学习和改进。 快速交付： 当客户索取价值时应立即交付价值。 缩短迭代周期，提供稳定可运行且有价值的软件。 打造精品： 使用恰当的方法确保质量。 追求完美，不断改进产品。 授权团队： 让创造增值的员工充分发挥自己的潜力。 培养健康的团队，不被琐碎的细节束缚。 优化整体： 防止以损害整体为代价而优化部分的倾向。 考虑局部优化对整体利益的影响。 总之，精益开发是一种追求尽善尽美、注重价值创造和持续改进的方法，适用于不同行业和产品开发领域。\n","date":"2024-03-23T20:46:07+08:00","image":"https://yikuanzz.github.io/2024/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%92%8C%E6%A8%A1%E5%BC%8F/cover_hu7d4fceec4d5a30dfc826354c0be764cc_547485_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E5%92%8C%E6%A8%A1%E5%BC%8F/","title":"开发技术和模式"},{"content":"我们做随机实验(ramdom trial)，记为 $E$ ，把实验的所有结果的集合叫作样本空间(sample sapce)，记为 $\\Omega$ 。\n随机事件(random event) 是样本空间的子集，简单称为事件。\n频率 $P$ 那么，我们假设在同一条件下进行了 $n$ 次实验，再假设随机事件 $A$ 在实验中发生了 $k$ 次，那么就事件的频率为 :\n$$ f_n(A)=\\frac{k}{n} $$\n当 $n$ 很大的时候，频率 $\\frac{k}{n}$ 趋于某一数值 $p$ ，则称 $p$ 为事件 $A$ 发生的概率，记为：\n$$ P(A) = p $$\n公理化的定义是说，$P(A)$ 满足以下公理：\n非负性：$P(A)\\geq0$ 规范性：$P(\\Omega) = 1$ 可数可加性： $P(\\cup ^ {\\infty} _ {n=1} A_n ) = \\sum ^ {\\infty} _ {n=1} P(A_n) $ 条件概率 $P(A|B) = \\frac{P(AB)}{P(B)}$ 我们说，在事件 $B$ 发生的前提下，事件 $A$ 发生的条件概率为: $$ P(A|B) = \\frac{P(AB)}{P(B)} $$ 条件概率 $P(A|B)$ 满足以下公理：\n对任一事件 $A$ ，有 $P(A|B) \\geq 0$ $P(\\Omega|B) = 1$ $P( \\cup ^ {\\infty} _ {i=1} A_i|B) = \\sum^{ \\infty } _ {i=1} P(A_i|B)$ 另外，乘法公式是说，当 $P(B) \u0026gt; 0$ 时，则有： $$ P(AB) = P(B)P(A|B) $$\n全概率公式 $P(B)=\\sum^{n}_{i=1}P(A_i)P(B|A_i)$ 我们定义 $A_1, A_2, \u0026hellip;, A_n$ 为样本空间 $\\Omega$ 的一个划分，它满足：\n划分中的任两个事件之间不相容 划分中的所有事件的总和构成样本空间 那么，这里我们认定事件 $B$ 为样本空间 $\\Omega$ 中的任意事件，因为 $P(B\\Omega) = P(B) * P(\\Omega) = P(B) * 1 = P(B) $，所以这里给出公式推理：\n$$ \\begin{aligned} P(B) \u0026amp;= P(B\\Omega)= P(B(A_1 \\cup A_2 \\cup \\cdots \\cup A_n))\\\\ \u0026amp;= P(BA_1 \\cup BA_2 \\cup \\cdots \\cup BA_n) \\\\ \u0026amp;= P(BA_1) + P(BA_2) + \\cdots + P(BA_n) \\\\ \u0026amp;= P(A_1)P(B|A_1) + P(A_2)P(B|A_2) + \\cdots + P(A_n)P(B|A_n) \\end{aligned} $$\n贝叶斯公式 $P(A_i|B) = \\frac{P(B|A_i)P(A_i)}{\\sum^{n}_{j=1}P(B|A_i)P(A_j)}$ 贝叶斯公式由条件概率和全概率公式组合而来，推理如下： $$ \\begin{aligned} P(A_i|B) \u0026amp;= \\frac{P(A_iB)}{P(B)} = \\frac{P(BA_i)}{P(B)}\\ \u0026amp;= \\frac{P(B|A_i)P(A_i)}{P(B)} \\ \u0026amp;= \\frac{P(B|A_i)P(A_i)}{\\sum^{n}_{j=1}P(B|A_j)P(A_j)} \\end{aligned} $$ 一般来说，我们将划分 $A_1,A_2,\u0026hellip;,A_n$ 作为已知的结果，是说我们通过实验或者以往的信息经验之类的得到了 $P(A_j)$ 的值，所以我们称 $P(A_j)$ 为先验概率。此外，我们称 $P(A_i|B)$ 为后验概率，因为 $P(A_i|B)$ 是说在事件 $B$ 发生后，$A_i$ 再发生的概率。\n通俗来说，就是我们通过了那么多的事件 $A_1,A_2,\u0026hellip;,A_n$ 得到了结果，也就是事件 $B$ 的概率，但是我们还想要知道这个结果，也就是事件 $B$ 发生的情况下，某个 $A_j$ 发生的概率是多少这样。\n分布函数 $F(x)=P\\{X \\leq x \\}$ 我们这里给出一个函数为： $$ X = X(A) $$ 这里，我们把样本空间 $\\Omega$ 中的每一个结果，或者说每一个事件都放入函数里，得到一个实数，比如 $X_1 = X(A_1),X_2=X(A_2),\\dots,X_n=X(A_n)$ 。\n这样做的好处是，我们将一些实验的结果用数字进行替代，比如，我们要在一个装有红、绿、蓝小球的箱子里摸球，我们可以用数字来替代红、绿、蓝的结果，$X(红)=1,X(绿)=2，X(蓝)=3$。\n因为我们的函数 $X$ 的值会随着实验的不同结果而变化，所以我们称 $X$ 函数为随机变量(random variable)。\n当然，我们一般用区间对 $X$ 的值进行描述，因为有时候不能将每一个值都列出来，所以我们会说随机变量 $X$ 的取值落在区间 $(x_1,x_2]$ 的概率，就是要求 $P \\{ x_1\\leq X \\leq x_2 \\}$ 的值。\n求 $P\\{x_1\\leq X \\leq x_2\\}$ 的值就相当于要计算 $P\\{X \\leq x_2\\} - P\\{ X \\leq x_1\\}$ 的值，那么就很容易知道我们其实是要研究 $P\\{X \\leq x \\}$ 的概率问题了。因为它的值也是随着不同的 $x$ 而变化的，所以我们叫 $P\\{X \\leq x \\}$ 为$P\\{X \\leq x \\}$ ，这里给出它的公式： $$ F(x) = P \\{X \\leq x \\} $$ 分布函数有以下特点：\n$F(x_2) - F(x_1) = P \\{x_1 \u0026lt; X \\leq x_2 \\} \u0026gt; 0$ $0 \\leq F(x) \\leq1 $ 我们在这里对随机变量有个区分：\n离散型随机变量：随机变量的取值为有限个或者可数无穷多个 连续型随机变量：随机变量的取值连续地充满某个区间 离散型随机变量-两点分布 $X \\sim (0-1)$ 当随机变量 $X$ 的取值只有 $x_1$ 和 $x_2$ 这两个结果时，它的分布为：\n$$ \\begin{aligned} P\\{ X=x_1 \\} \u0026= p \\quad , \\\\ P\\{ X=x_2 \\} \u0026= 1 - p \\quad, \\quad0 \u003c p \u003c 1 \\\\ \\end{aligned} $$ 我们称 $X$ 服从参数为 $p$ 的两点分布，也叫 (0-1) 分布，记作 $X \\sim (0-1)$。\n离散型随机变量-二项分布 $X\\sim b(n, p)$ 当随机变量 $X$ 的分布满足： $$ P\\{X=k\\} = C_n^k p ^k(1-p)^{n-k} $$ 则称 $X$ 为服从参数为 $n $ , $p$ 的二项分布(binomial distribution)，记作 $X\\sim b(n, p)$。\n一般我们会使用 泊松(Posisson)定理 来进行近似计算，这里做个简单介绍。\n设 $np_n = \\lambda$ ，对任意非负整数有： $$ \\lim\\limits_{x\\rightarrow\\infty}C^k_np^k_n(1-p)^{n-k}=\\frac{\\lambda^ke^{-\\lambda}}{k!} $$\n离散型随机变量-泊松分布 $X \\sim P(\\lambda)$\n当随机变量 $X$ 的分布满足： $$ P\\{X=k\\} = \\frac{\\lambda^ke^{-\\lambda}}{k!} \\quad,\\quad k=0,1,2,\\dots, $$ 则称 $X$ 为服从参数为 $\\lambda$ 的泊松分布(poisson distribution)，记作 $X \\sim P(\\lambda)$，其中 $\\lambda$ 为常数。\n概率密度函数 $f(x)$ 这里介绍一个概念，概率密度函数(density sunction)。它可以用来描述随机变量 $X$ 的分布函数 $F(x)$： $$ F(x) = \\int^x_{\\infty}f(t)dx $$ 它有以下特点：\n$f(x) \\geq 0$ $\\int^{{+\\infty}}_{-\\infty}f(x)dx = 1$ $P \\{ x_1 \u0026lt; X \u0026lt;x_2 \\} = F(x_2) - F(x_1) = \\int^{x_2}_{x_1}f(t)dx$ 连续型随机变量-均匀分布 $X\\sim U(a,b)$ 当随机变量 $X$ 具有概率密度：\n$$ f(x)=\\left\\{ \\begin{aligned} \u0026 \\frac{1}{b-a},\u0026 a \u003c x\u003c b, \\\\\\ \u00260,\u0026 其他. \\end{aligned} \\right. $$ 则称 $X$ 在区间 $(a, b)$ 上服从均匀分布(unniform distribution)，记作 $X\\sim U(a,b)$\n积分求得 $X$ 的分布函数：\n$$ F(x)=\\left\\{ \\begin{aligned} \u0026 0,\u0026 x \u003c a, \\\\\\ \u0026 \\frac{x-a}{b-a},\u0026a \\leq x \u003c b, \\\\\\ \u0026 1,\u0026 x \\geq b. \\end{aligned} \\right. $$ 连续型随机变量-指数分布 $X\\sim E(\\lambda)$ 当随机变量 $X$ 具有概率密度：\n$$ f(x)=\\left\\{ \\begin{aligned} \u0026 \\lambda e^{-\\lambda x}, \u0026x \u003e 0, \\\\\\ \u00260,\u0026 x \\leq 0. \\end{aligned} \\right. $$ 则称 $X$ 服从 $\\lambda$ 的指数分布(exponential distribution)，记作 $X\\sim E(\\lambda)$，其中 $\\lambda$ 为常数。\n积分求得 $X$ 的分布函数：\n$$ F(x)=\\left\\{ \\begin{aligned} \u0026 1-e^{-\\lambda x},\u0026 x \u003e 0, \\\\ \u0026 0,\u0026x \\leq 0. \\end{aligned} \\right. $$ 连续型随机变量-正态分布 $X \\sim N(\\mu, \\sigma^2)$ 当随机变量 $X$ 具有概率密度： $$ f(x)= \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{- \\frac{(x-\\mu)^2}{2 \\sigma^2}},-\\infty\u0026lt;x\u0026lt;+\\infty $$ 则称 $X$ 服从参数为 $\\mu$ , $\\sigma$ 的正态分布(normal distribution)，记作 $X \\sim N(\\mu, \\sigma^2)$， 其中 $\\mu$ 和 $\\sigma (\\sigma\u0026gt;0)$ 为常数。\n积分求得 $X$ 的分布函数： $$ F(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\int^x_{-\\infty}e^{-\\frac{(t-\\mu)^2}{2 \\sigma^2}}dt $$ 特别的，当 $\\mu=0,\\sigma=1$时，我们称 $X$ 服从标准正态分布 $N(0,1)$，这时它的概率密度表示为：\n$$ \\varphi(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{x^2}{2}} $$\n分布函数表示为：\n$$ \\phi(x)=\\frac{1}{\\sqrt{2\\pi}} \\int ^x _{-\\infty} e^{\\frac{t^2}{2}}dt $$\n一般地，若 $X \\sim N(\\mu, \\sigma^2)$ ，那么 $\\frac{X-\\mu}{\\sigma}\\sim N(0, 1)$，我们可以通过正态函数表来计算正态分布：\n$$ \\begin{aligned} P \\{\\mu- \\sigma \u003c X \u003c \\mu + \\sigma \\} = \\phi(1) - \\phi(-1) = 2\\phi(1) -1 = 0.6826 \\\\ P \\{\\mu-2 \\sigma \u003c X \u003c \\mu + 2 \\sigma \\} = \\phi(2) - \\phi(-2) = 2\\phi(2) -1 = 0.9544 \\\\ P \\{\\mu-3 \\sigma \u003c X \u003c \\mu + 3 \\sigma \\} = \\phi(3) - \\phi(-3) = 2\\phi(3) -1 = 0.9974 \\end{aligned} $$ 联合分布函数 $F(x,y) = P{ X \\leq x, Y \\leq y}$ 在这里，我们考虑两个随机变量 $X(e)$ 和 $Y(e)$ 的组合。我们把 $(X(e), Y(e))$ 称为二维随机向量(2-dimensional random vector)，简单记作 $(X, Y)$。\n显然，我们可以得到二维随机向量 $(X, Y)$ 的分布函数，或者说，随机变量 $X$ 和随机变量 $Y$ 的联合分布函数： $$ F(x,y) = P\\{ X \\leq x, Y \\leq y\\} $$\n边缘分布函数 $F_X(x), F_Y(y)$ 我们说到联合分布函数是二维随机变量 $(X, Y)$ 的分布函数，自然随机变量 $X$ 和 $Y$ 是有分布函数的，那么我们通过联合分布函数来求得变量 $X$ 和 $Y$ 的分布函数，就可以得二维随机变量 $(X, Y)$ 关于 $X$ 和 $Y$ 的边缘分布函数(marginal distribution function)：\n$$ \\begin{aligned} F_X(x) \u0026amp;= P\\{X \\leq x \\} = P\\{X \\leq x, Y \u0026lt; +\\infty \\} = F(x, +\\infty) \\\\ F_Y(y) \u0026amp;= P\\{Y \\leq y \\} = P\\{X \u0026lt; +\\infty, Y \\leq y \\} = F(+\\infty, y) \\end{aligned} $$\n数学期望 $E(X)$ 我们现在知道一个离散型变量 $X$ 的分布律为：\n$$ P\\{X = x_k\\} = p_k, k=1,2.\\dots $$\n如果满足条件 $\\sum ^ {\\infty} _ {k=1} x_kp_k$ 绝对收敛，那么有数学期望(mathematical expectation)，记作 $E(X)$，即： $$ E(X) =\\sum^{\\infty}_{k=1}x_kp_k $$\n当然，如果是一个连续型的随机变量 $X$ 的话，我们就假设它有概率密度函数 $f(x)$ 。\n如果满足积分 $\\int^{+\\infty}_{-\\infty}xf(x)dx$ 绝对收敛，那么同样有数学期望为：\n$$ E(X) = \\int^{+\\infty}_{-\\infty}xf(x)dx $$\n数学期望有一些性质：\n$E(c) = c$ ，其中 $c$ 为常数； $E(cX) = cE(X)$； $E(X+Y) = E(X) + E(Y)$； $E(XY) = E(X)E(Y)$，其中 $X,Y$ 相互独立。 $(0-1)$分布 二项分布 泊松分布 均匀分布 指数分布 正态分布 $ E(X) $ $ p $ $ np $ $ \\lambda $ $ \\frac{a+b}{2} $ $ \\frac{1}{\\lambda} $ $ \\mu $ 方差 $D(X)$ 数学期望描述了随机变量取值的“平均数”，而 方差(variance) 是用来度量随机变量取值的分散程度的，记作 $D(X)$，即： $$ D(X) = E[X-E(X)]^2 = E(X^2) - [E(X)]^2 $$\n其中，我们称 $\\sqrt{D(X)}$ 为随机变量 $X$ 的标准差(standard deviation)，或均方差(mean square deviation)，记作 $ \\sigma(X)$。\n方差有一些性质：\n$D(c) = 0$，其中 $c$ 为常数； $D(cX) = c^2D(X)$； $D(X±Y) = D(X) + D(Y) ±2E[(X-E(X))(Y-E(Y))]$； $D(X±Y) = D(X) + D(Y)$，其中 $X,Y$ 相互独立。 $(0-1)$分布 二项分布 泊松分布 均匀分布 指数分布 正态分布 $ D(X) $ $ p(1-p) $ $ np(1-p) $ $ \\lambda $ $ \\frac{(a+b)^2}{12} $ $ \\frac{1}{\\lambda^2} $ $ \\sigma^2 $ 协方差 $cov(X, Y)$ 数学期望和方差反映的都是随机变量自身的内容，这里我们考虑随机变量相互之间的影响，一般会使用协方差(convariance) 来描述，即：\n$$ cov(X, Y) = E{[X-E(X)][Y-E(Y)]} $$ 其中，我们称 $\\frac{cov(X, Y)}{\\sqrt{D(X)}{\\sqrt{D(Y)}}}$ 为随机变量 $X,Y$ 的相关系数(correlation corfficient)，或标准协方差(standard convariance)，记作 $\\rho_{XY} $，即：\n$$ \\rho_{XY} =\\frac{cov(X, Y)}{\\sqrt{D(X)}{\\sqrt{D(Y)}}} $$\n一些实用的计算公式：\n$$ D(X±Y) = D(X) + D(Y) ± 2cov(X, Y) \\\\ cov(X, Y) = E(XY) - E(X)E(Y) $$\n","date":"2024-03-22T20:39:03+08:00","image":"https://yikuanzz.github.io/2024/%E6%A6%82%E7%8E%87%E8%AE%BA/cover_hu8470374154b02d0cb208d1f67de517c1_1238996_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/%E6%A6%82%E7%8E%87%E8%AE%BA/","title":"概率论"},{"content":"基础篇 MySQL概述 数据库相关概念 数据库（Data Base）：存储数据的仓库，并且是有组织的存储。\n数据库管理系统（Data Base Management System）：操纵和管理数据库的大型软件。\nSQL（Structured Query Language）：操作关系型数据库的编程语言。\nMySQL 数据库 # 连接 MySQL mysql -u username -p 数据模型：客户端 \u0026raquo; 数据库管理系统 \u0026raquo; 数据库。\n关系型数据库（RDBMS）：由多张互相连接的二维表组成的数据库。\nSQL SQL 通用语法 -- 注释写法1 : 不区分大小写，关键字建议大写 # 注释写法2 : 可以使用缩进或空格 /*\t注释写法3 */ SQL 分类 DDL（Data Definition Language）：定义数据库、表、字段。\nDML（Data Manipulation Language）：表中数据增、删、改。\nDQL（Data Query Language）：查询数据库表记录。\nDCL（Data Control Language）：创建数据库用户、控制数据库访问权限。\n数据类型 数值类型：\nTINYINT（1 byte）、SMALLINT（2 bytes）、MEDIUMINT（3 bytes）、INT（4 bytes）、BIGINT（8 bytes）、FLOAT（4 bytes）、DOUBLE（8 bytes）。\n字符串类型：\nCHAR、VARCHAR、TINYBLOB、TINYTEXT、BLOB、TEXT、MEDIUMBLOB、MEDIUMTEXT、LONGBLOB、LONGTEXT。\n日期类型：\nDATE（YYYY-MM-DD）、TIME（HH:MM:SS）、YEAR（YYYY）、DATETIME（YYYY-MM-DD HH:MM:SS）、TIMESTAMP（YYYY-MM-DD HH:MM:SS）\nDDL /* 数据库的操作 */ # 查询所有数据库 SHOW DATABASES; # 查询当前数据库 SELECT DATABASE(); # 创建数据库 CREATE DATABSE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; # 使用数据库 USE 数据库名; # 删除 DROP DATABASE [IF NOT EXISTS] 数据库名; /* 表操作 */ # 查询所有数据表 SHOW TABLES; # 查询表结构 DESC 表名; # 查询表的建表语句 SHOW CREATE TABLE 表名; # 创建表 CREATE TABLE 表名( 字段1 字段1类型[COMMENT 字段1注释], 字段2 字段2类型[COMMENT 字段2注释], 字段3 字段3类型[COMMENT 字段3注释], )[COMMENT 表注释]; # 添加字段 ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束]; # 修改数据类型 ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度); # 修改字段名和字段类型 ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; # 删除字段 ALTER TABLE 表名 DROP 字段名; # 修改表名 ALTER TABLE 表名 RENAME TO 新表名; # 删除表 DROP TABLE [IF EXISTS] 表名; # 删除指定表并重新创建该表 TRUNCATE TABLE 表名; DML # 给指定字段添加数据 INSERT INTO 表名(字段名1, 字段名2, ...) VALUES(值1, 值2, ...); # 给全部字段添加数据 INSERT INTO 表名字 VALUES(值1, 值2, ...); # 修改数据 UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [WHERE 条件]; # 删除数据 DELETE FROM 表名 [WHERE 条件]; DQL SELECT 字段列表 FROM 表名列表 WHERE 条件列表 GROUP BY 分组字段列表 HAVING 分组后条件列表 ORDER BY 排序字段列表 LIMIT 分页参数 # 查询多个字段 SELECT 字段1, 字段2, 字段3 ... FROM 表名; SELECT * FROM 表名; # 设置别名 SELECT 字段1[AS 别名1], 字段2[AS 别名2] .. FROM 表名; # 去除重复记录 SELECT DISTINCT 字段列表 FROM 表名; # 查询没有身份证号的员工信息 SELECT * FROM emp WHERE idcard IS NULL; # 查询 15岁 到 20岁 之间的员工信息 SELECT * FROM emp WHERE age \u0026gt;= 15 and age \u0026lt;= 20; SELECT * FROM emp WHERE age BETWEEN 20 and 15; # 查询年龄为 18岁 或 20岁 或 40岁 的员工信息 SELECT * FROM emp WHERE age = 18 OR age = 20 OR age = 40; SELECT * FROM emp WHERE age IN(18, 20, 40); # 查询姓名为两个字的员工信息 SELECT * FROM emp WHERE name LIKE \u0026#39;__\u0026#39;; # 查询身份证最后一位是X的员工信息 SELECT * FROM emp WHERE idcard LIKE \u0026#39;%X\u0026#39;; # 统计企业员工数据量 SELECT COUNT(*) FROM emp; # 根据性别分组，统计男性员工和女性员工的数量 SELECT gender, count(*) FROM emp GROUP BY gender; # 查询年龄小于 45岁 的员工，并根据工作地址分组，获取员工数量大于3的工作地址 SELECT workaddress, count(*) FROM emp WHERE age\u0026lt;45 GROUP BY workaddress HAVING count(*)\u0026gt;3; # 根据年龄对公司的员工进行升序排序 SELECT * FROM emp ORDER BY age ASC; # 根据入职时间对员工进行降序排序 SELECT * FROM emp ORDER BY entrydate DESC; # 先按年龄升序排，年龄同的按入职时间降序排 SELECT * FROM emp ORDER BY age ASC, entrydate DESC; # 查询第 1 页员工数据，每页展示 10 条记录 SELECT * FROM emp LIMIT 0, 10; # 查询第 2 页员工数据，每页展示 10 条记录 SELECT * FROM emp LIMIT 10,10; DCL # 查询用户 USE mysql; SELECT * FROM USER; # 创建用户 CREATE USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; IDENTIFIED BY \u0026#39;密码\u0026#39;; # 修改用户密码 ALTER USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;新密码\u0026#39;; # 删除用户 DROP USER \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 查询权限 SHOW GRANTS FOR \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 授予权限 GRANT 权限列表 ON 数据库名.表名 TO \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; # 撤销权限 REVOKE 权限列表 ON 数据库名.表名 FROM \u0026#39;用户名\u0026#39;@\u0026#39;主机名\u0026#39;; 函数 字符串函数 -- concat SELECT CONCAT(\u0026#39;Hello \u0026#39;, \u0026#39;MySQL\u0026#39;); -- LOWER SELECT LOWER(\u0026#39;Hello\u0026#39;); -- UPPER SELECT UPPER(\u0026#39;Hello\u0026#39;); -- LPAD SELECT LPAD(\u0026#39;01\u0026#39;, 5, \u0026#39;-\u0026#39;); -- RPAD SELECT RPAD(\u0026#39;01\u0026#39;, 5, \u0026#39;-\u0026#39;); -- TRIM SELECT TRIM(\u0026#39; Hello MySQL \u0026#39;); -- SUBSTRIMG SELECT SUBSTRING(\u0026#39;Hello MySQL\u0026#39;, 1, 5); 数值函数 -- CEIL(x) SELECT CEIL(1.1); -- FLOOR(x) SELECT FLOOR(1.9); -- MOD(x,y) SELECT MOD(3, 4); -- RAND() SELECT RAND(); -- ROUND(x,y) SELECT ROUND(3.1415926, 2); 日期函数 -- CURDATE() SELECT CURDATE(); -- CURTIME() SELECT CURTIME(); -- NOW() SELECT NOW(); -- YEAR, MONTH, DAY SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); -- DATE_ADD(date, INTERVAL expr type) SELECT DATE_ADD(NOW(), INTERVAL 70 DAY); -- DATEDIFF(date1, date2) SELECT DATEDIFF(\u0026#39;2024-02-29\u0026#39;, \u0026#39;2023-11-11\u0026#39;); 流程函数 -- IF SELECT IF(FALSE, \u0026#39;OK\u0026#39;, \u0026#39;ERROR\u0026#39;); -- IFNULL SELECT IFNULL(\u0026#39;Get\u0026#39;, \u0026#39;DEFAULT\u0026#39;); SELECT IFNULL(\u0026#39;\u0026#39;, \u0026#39;DEFATLT\u0026#39;); SELECT IFNULL(null, \u0026#39;DEFATLT\u0026#39;); -- CASE WHEN[val1] THEN[res1] ... ELSE[default] END SELECT name, CASE WHEN score \u0026gt;= 85 THEN \u0026#39;优秀\u0026#39; WHEN score \u0026gt;= 60 THEN \u0026#39;及格\u0026#39; ELSE \u0026#39;不及格\u0026#39; END FROM student_score; -- CASE [expr] WHEN[val1] THEN[res1] ... ELSE[default] END SELECT name, CASE workaddress WHEN \u0026#39;北京\u0026#39; THEN \u0026#39;一线城市\u0026#39; WHEN \u0026#39;上海\u0026#39; THEN \u0026#39;一线城市\u0026#39;ELSE \u0026#39;二线城市\u0026#39; END FROM emp; 约束 约束包括：\n1、主键约束：每个表会有一个唯一标识表的字段。 2、外键约束：表中的某字段由另外一个表的主键决定。 3、唯一约束：确保该字段的每个字段值是唯一的，允许空值。 4、检查约束：用于检查数据表中，字段值是否有效。 5、非空约束：用来约束数据表中，字段值不能为空。 6、默认值约束：当表中某字段不输入值时，自动为其添加设定好的值。 常见约束 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) NOT NULL UNIQUE COMMENT \u0026#39;姓名\u0026#39;, age INT CHECK(age \u0026gt; 0 AND age \u0026lt;= 120) COMMENT \u0026#39;年龄\u0026#39;, status CHAR(1) DEFAULT \u0026#39;1\u0026#39; COMMENT \u0026#39;状态\u0026#39;, gender CHAR(1) COMMENT \u0026#39;性别\u0026#39; ) COMMENT \u0026#39;用户表\u0026#39;; 外键约束 CREATE TABLE emp( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) NOT NULL UNIQUE COMMENT \u0026#39;姓名\u0026#39;, age INT CHECK(age \u0026gt; 0 AND age \u0026lt;= 120) COMMENT \u0026#39;年龄\u0026#39;, salary INT CHECK(salary \u0026gt; 0) NOT NULL COMMENT \u0026#39;薪资\u0026#39;, entrydate NOT NULL COMMENT \u0026#39;入职时间\u0026#39;, managerid INT COMMENT \u0026#39;直属领导ID\u0026#39;, dept_id INT \u0026#39;部门ID\u0026#39; ) COMMENT \u0026#39;员工表\u0026#39;; CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;ID\u0026#39;, name VARCHAR(50) NOT NULL COMMENT \u0026#39;部门名称\u0026#39; ) COMMENT \u0026#39;部门表\u0026#39;; # 添加外键 ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE CASCADE; ALTER TABLE emp ADD CONSTRAINT fk_emp_dept_id FOREIGN KEY (dept_id) REFERENCES dept(id) ON UPDATE CASCADE ON DELETE SET NULL; # 删除外键 ALTER TABLE emp DROP FOREIGN KEY fk_emp_dept_id; 多表查询 多表关系 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) COMMENT \u0026#39;姓名\u0026#39;, sid VARCHAR(10) COMMENT \u0026#39;学号\u0026#39; ) COMMENT \u0026#39;学生表\u0026#39;; CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, name VARCHAR(10) COMMENT \u0026#39;课程名称\u0026#39; )COMMENT \u0026#39;课程表\u0026#39;; CREATE TABLE student_course( id INT PRIMARY KEY AUTO_INCREMENT COMMENT \u0026#39;主键\u0026#39;, studentid INT COMMENT \u0026#39;学生ID\u0026#39;, courseid INT COMMENT \u0026#39;课程ID\u0026#39;, CONSTRAINT fk_courseid FOREIGN KEY (courseid) REFERENCES course(id), CONSTRAINT fk_studentid FOREIGN KEY (studentid) REFERENCES student(id) )COMMENT \u0026#39;学生选课表\u0026#39;; 多表查询概述 # 多表查询 - 笛卡尔积 SELECT * FROM emp, dept WHERE emp.detp_id = dept.id; 内连接 # 内连接查询的是两张交集的部分 SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件; 外连接 # 左外连接 SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件 ...; # 右外连接 SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件 ...; 自连接 # 自连接可以是内连接也可以是外连接 SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; SELECT 字段列表 FROM 表A 别名A LEFT[OR RIGHT] [OUTER] JOIN 表B 别名B ON 条件 ...; 联合查询 # UNION ALL 是不合并相同信息 SELECT * FROM emp WHERE salary \u0026lt; 5000 UNION ALL SELECT * FROM emp WHERE age \u0026gt; 50; 子查询 # 嵌套查询就是子查询 SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2); # 查询销售部所有员工信息 SELECT * FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = \u0026#39;销售部\u0026#39;); # 查询销售部和市场部所有员工信息 SELECT * FROM emp WHERE dept_id IN((SELECT id FROM dept WHERE name IN(\u0026#39;销售部\u0026#39;, \u0026#39;市场部\u0026#39;))); # SOME、ANY、ALL 使用 # 比财务部所有人工资都高 SELECT * FROM emp WHERE salary \u0026gt; ALL(SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = \u0026#39;财务部\u0026#39;)); 事务 事务：就是一组操作，不可分割单工作单位，将作为一个整体提交到系统。\n默认 MySQL 的事务是自动提交的，也就是，当执行一条 DML 语句， MySQL 会隐式地提交事务。\n事务操作 # 查看、设置事务提交方式 SELECT @@autocommint; SET @@autocommint = 0; # 开启事务 START TRANSACTION; BEGIN; # 提交事务 COMMIT; # 回滚事务 ROLLBACK; CREATE TABLE account( ID INT AUTO_INCREMENT PRIMARY KEY COMMENT \u0026#39;主键\u0026#39;, NAME VARCHAR(10) COMMENT \u0026#39;姓名\u0026#39;, MONEY INT COMMENT \u0026#39;余额\u0026#39; ) COMMENT \u0026#39;账户表\u0026#39;; INSERT INTO account(ID, NAME, MONEY) VALUES (null, \u0026#39;张三\u0026#39;, 2000), (null, \u0026#39;李四\u0026#39;, 2000); # 恢复数据 UPDATE account SET MONEY = 2000 WHERE NAME IN(\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;); # 张三给李四转账 1000 # 1.查询张三账户余额 SELECT MONEY FROM account WHERE name = \u0026#39;张三\u0026#39;; # 2.将张三用户余额 -1000 UPDATE account SET MONEY = MONEY - 1000 WHERE name = \u0026#39;张三\u0026#39;; # 3.将李四用户余额 +1000 UPDATE account SET MONEY = MONEY + 1000 WHERE name = \u0026#39;李四\u0026#39;; 事务特性 原子性（Atomicity）：事务不可分割。\n一致性（Consistency）：事务完成时，所有数据状态一致。\n隔离性（Isolation）：保证事务在不受并发操作下独立运行。\n持久性（Durabiliry）：事务一旦提交或回滚，数据改变是永久的。\n并发事务 脏读：一个事务读到另一个事务还没有提交的数据。\n不可重复读：一个事务先后读取同一条记录，但是两次读取的数据不同。\n幻读：查询时没有对应数据行，但插入数据时数据又存在。\n事务隔离级别 隔离级别 脏读 不可重复读 幻读 Read uncommitted ✓ ✓ ✓ Read committed × ✓ ✓ Repeatable Read (Default) × × ✓ Serializable × × × # 查看事务隔离级别 SELECT @@TRANSACTION_ISOLATION; # 设置事务隔离级别 SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}; 进阶篇 Linux MySQL 使用 MySQL 服务 # 启动 systemctl start mysqld # 重启 systemctl restart msyqld # 停止 systemctl stop mysqld 查询自动生成的 root 密码 grep \u0026#39;temporary password\u0026#39; /var/log/mysqld.log 修改 root 密码 # 设置密码复杂度和密码长度 SET GLOBAL VALIDATE_PASSWORD.policy = 0; SET GLOBAL VALIDATE_PASSWORD.length = 4; # 修改密码 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;1234\u0026#39;; 创建用户 CREATE USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;1234\u0026#39;; 分配所有权限 grant all on *.* to \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39;; 存储引擎 MySQL 体系结构 MySQL 客户端 \u0026laquo; === \u0026raquo; MySQL Server （连接层 + 服务层 + 引擎层 + 存储层）\nMySQL Server = 连接池 + 系统管理工具 + SQL 接口 + 解析器 + 查询优化器 + 缓存 + 可插拔存储引擎 + 系统文件 + 文件和日志\n存储引擎简介 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储殷勤是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。\n# 创建表时指定存储引擎 CREATE TABLE 表名( )ENGINE = INNODB； # 查询数据库支持的存储引擎 SHOW ENGINES； 存储引擎特点 InnoDB：高可靠性和高性能的通用存储引擎。\nxxx.ibd：xxx 代表表名，innoDB 引擎每张表都会对应一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。\nTablespace -\u0026gt; Segment -\u0026gt; EXtent -\u0026gt; Page -\u0026gt; Row (Trx id + Roll Pointer + col1 + col2 + col3 + \u0026hellip;)\nDML 操作遵循 ACID 模型，支持事务； 行级锁，提高并发访问性能； 支持外键 FOREIGN KEY 约束，保证数据的完整性和正确性。 MyISAM：MySQL 早期默认存储引擎。\nxxx.sdi：存储表结构信息。\nxxx.MYD：存储数据。\nxxx.MYI：存储索引。\n不支持事务，不支持外键； 支持表锁，不支持行锁； 访问速度快。 Memoery：表数据存储在内存中，只做临时表或缓存。\nxxx.sdi：存储表结构信息。\n内存存放； hash 索引（默认）。 存储引擎选择 InnoDB：对事务完整性要求高，并发条件下数据的一致性，除了插入和查询外，还包含很多更新、删除，则选该引擎。\nMyISAM：以读取和插入为主，很少更新和删除操作，对事务完整性、并发性要求不是很高，就用该引擎。\nMEMORY：访问速度快，但大小有限制，因为是临时存储也无法保证数据的安全性。\n索引 索引概述 索引（Index） ： 是帮助 MySQL 高效获取数据的数据结构。数据之外，数据库管理系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。\n优点：提高检索的效率，降低数据库的 IO 成本；通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗； 缺点：索引列也是要占用空间的；索引提高了查询效率，同时也降低了更新表的速度。 索引结构 MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的结构：\nB+Tree：最常见的索引类型，大部分引擎支持。\nHash：底层数据用哈希表实现，只有精确匹配索引列查询才有效。\nR-tree：空间索引为MyISAM引擎的特殊索引类型，主要用于地理空间数据类型。\nFull-text：一种通过建立倒排索引，快速匹配文档的方式。\n二叉树：顺序插入到时候，会形成一个链表，查询性能会大大降低，大数据量情况下，层级较深，检索速度慢。\n红黑树：大量数据情况下，层级深，检索速度慢。\nB-Tree：（最大度数为 5 的 b-tree 每个节点存 4 个 key）。\nB+-Tree：所有的数据都有在叶子节点形成单向链表，非叶子节点起到索引的作用。\nMySQL 索引在经典 B+Tree 进行了优化，增加了一个指向相邻叶子节点的链表指针。\nHash 索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，再映射到对应的槽位上，然后存储在 hash 表中。如果两个或多个键值，映射到相同的位置上，就产生了哈希冲突，可以通过链表来解决。\nHash的特点：不支持范围搜索，无法通过索引完成排序，查询效率高。\nMemory 引擎支持 hash 索引，而 InnoDB 自适应 hash 功能。\n为什么 InnoDB 用 B+tree 索引结构？\n相对于二叉树，层级更少，搜索的效率高；\n对于 B-tree ，因为他叶子和非叶子都保存数据，这样一个页内存储的键值对少，如果要保存大量数据，只能增加树都高度；\n相对于 Hash 索引，B+tree 支持范围匹配和排序操作。\n索引分类 主键索引：针对表中主键创建的索引，默认自动创建。PRIMARY。\n唯一索引：避免同一个表中某数据列中的值重复，可以有多个。UNIQUE。\n常规索引：快速定位特定数据，可以有多个。\n全文索引：全文索引查找的是文本中的关键词，可以有多个。FULLTEXT。\n在 InnoDB 存储引擎中，根据索引的存储形式，还可以划分：\n聚群索引（Clustered Index）将数据与索引放到一块，索引结构的叶子节点保存了数据。必须有，且只一个。\n如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用第一个 UNIQUE 索引作为聚集索引。 如果都没有，则 InnoDB 自动生成 rowid 为隐藏的聚集索引。 二级索引（Secondary Index）将数据与索引分开存储，索引结构的叶子节点关联对应主键。可以存在多个。\n例如：SELECT * FROM USER WHERE NAME='Arm';\n1、进行 NAME 字段的二级索引，找到对应的 ID；\n2、根据 ID 进行回表查询，即聚集索引找到 ID 下那一行的数据。\n索引语法 # 创建索引 CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name, ...); # 查看索引 SHOW INDEX FROM table_name; # 删除索引 DROP INDEX index_name ON table_name; SQL 性能分析 SQL 执行频率：SHOW [SESSION|GLOBAL] STATUS; 可以查看数据库指令的访问频次。\nSHOW GLOBAL STATUS LIKE \u0026#39;com______\u0026#39;; 慢查询日志：它记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志。MySQL 的慢查询日志默认没有开启，需要在 MySQL 的配置文件（/etc/my.cnf）中配置信息：\n# 开启 MySQL 慢日志查询 slow_query_log = 1 # 设置超 2 秒就视为慢查询 long_query_time = 2 # 重启后，慢查询日志 SHOW VARIABLES LIKE \u0026#39;slow_query_log\u0026#39;; # 生成文件 /var/lib/mysql/localhost-slow.log show profiles 能够在 SQL 优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看见 MySQL 是否支持 profile 操作：\n# 默认关闭，通过 SET 在 session / global 开启 SET profiling = 1; # 查看 profiles 是否开启 SELECT @@have_profiling; # 查看每一条 SQL 的耗时基本情况 SHOW profiles; # 查看指定 query_id 的 SQL 语句各个阶段的耗时情况 SHOW profile FOR query query_id; # 查看指定 query_id 的 SQL 语句 CPU 使用情况 SHOW profile cpu FOR query query_id; EXPLAIN 或 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接或连接的顺序。\n# 直接在 SELECT 语句前加上关键字 explain / desc EXPLAIN SELECT 字段 FROM 表名 WHERE 条件; /* id 相同，从上到下顺序执行；不同则值大的先执行。 select_type 表示 SELECT 类型。 tyep 表连接类型，性能好到差为 NULL、system、const、eq_ref、ref、range、index、all。 possible_key 显示可能应用这个表上的索引，一个或多个。 key 为实际使用的索引。 key_len 索引中使用的字节数，即索引字段最大可能值。 rows MySQL 认为必须要执行查询的行数，这是估计值。 filtered 表示返回结果的行数占所需读取行数的百分比，值越大越好。 */ 索引使用 验证索引效率\n# 未建立索引前执行 SQL SELECT * FROM tb_sku WHERE sn = \u0026#39;100000003145001\u0026#39;; # 针对字段建立索引 CREATE INDEX idx_sku_sn ON tb_sku(sn); # 再次执行 SELECT * FROM tb_sku WHERE sn = \u0026#39;100000003145001\u0026#39;; 最左前缀法：如果进行了联合索引，要遵循最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n范围查询：联合索引中，出现范围查询（\u0026gt;, \u0026lt;），范围查询右侧的列索引失效。在业务允许的情况，尽量使用 \u0026gt;= 或 \u0026lt;=。\n索引列运算：不要在索引列上进行运算操作，索引将失效。此外，如果字符串不加引号，也不会走索引的。\n模糊查询：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失败。\nor 连接条件：如果 or 前字段有索引，而后面的没有索引，则不会用到索引。\n数据分布影响：如果 MySQL 评估使用索引比全表更慢，则不使用索引。\nSQL 提示：就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。\n# USE INDEX explain select * from tb_user use index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; # IGNORE INDEX explain select * from tb_user ignore index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; # FORCE explain select * from tb_user force index(idx_user_pro) where profession=\u0026#39;软件工程\u0026#39;; 覆盖索引：尽量使用覆盖索引（查询使用了索引，且需要返回的列，在该索引中已经全部能够找到），减少 select *。\nusing index condition ： 查找使用了索引，但是需要回表查询数据。\nusing where; using index ：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据。\n前缀索引：当字段类型为字符串时，要索引很长的字符串，这样会浪费磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以节约索引空间。\nCREATE INDEX idx_xxx ON table_name(column(n)); # 前缀长度：不重复数据 和 总数据的比值 SELECT count(distinct email)/count(*) FROM tb_user; SELECT count(distinct substring(email, 1,5)) / count(*) FROM tb_user; 单列索引：即一个索引只包含单个列。\n联合索引：即一个索引包含了多个列。\n业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。\n# 单列索引情况 MysQL 优化器会自动评估哪个字段的索引效率更高 EXPLAIN select id,phone,name from tb_user where phone=\u0026#39;12314123\u0026#39; and name = \u0026#39;李白\u0026#39;; 索引设计原则 1、数据量大，且查询比较频繁就建立索引；\n2、针对尝作为查询、排序、分组的字段建立索引；\n3、选择区分度高的建立索引，尽量建立唯一索引；\n4、字符串类型字段可建立前缀索引；\n5、尽量使用联合索引，很多时候可以覆盖索引；\n6、控制索引数量，维护索引结构代价要考虑；\n7、索引列不能存储NULL值，就用NOT NULL进行约束。\nSQL 优化 插入数据 -- 批量插入 INSERT INTO tb_test VALUES (1, \u0026#39;Tom\u0026#39;), (2, \u0026#39;Cat\u0026#39;); -- 手动提交事务 START TRANSACTION; INSERT INTO tb_test VALUES (1, \u0026#39;Tom\u0026#39;), (2, \u0026#39;Cat\u0026#39;); INSERT INTO tb_test VALUES (3, \u0026#39;Jerry\u0026#39;), (4, \u0026#39;Mike\u0026#39;); COMMIT; -- 主键顺序插入 -- 大批量插入 # 连接服务器 mysql --local-infile -u root -p # 设置变量，从本地加载文件导入数据 SET GLOBAL local_infile = 1; # 执行 load 指令，加载数据到表 load data local infile \u0026#39;/root/sql1.log\u0026#39; into table \u0026#39;tb_user\u0026#39; fields terminated by \u0026#39;,\u0026#39; lines terminated by \u0026#39;\\n\u0026#39;; 主键优化 在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为 索引组织表（index organized table IOT）。\n逻辑结构为：TableSpace \u0026gt; Segement \u0026gt; Extend \u0026gt; Page \u0026gt; Row。\n页可以为空，也可以填充一半。每个页包含了 2-N 行数据，如果一行数据太大会行溢出，是根据主键排序的。\n页分裂：主键乱序插入的时候会新建一个页空间，将原有的页一分为二，然后插入新数据。\n页合并：当页删除记录达到 MERGE_THRESHOLD，会查找前后页是否可以进行合并。\n设计原则：\n满足业务需求的情况下，尽量降低主键的长度； 插入数据尽量顺序插入，选择 AUTO_INCREMENT； 尽量不用 UUID 做主键或是其他自然主键，如身份证号； 业务操作时，尽量不对主键修改。 order by 优化 Using filesort：通过表索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。 Using index：通过有序索引顺序扫描直接返回有序数据，不需要额外排序。 可以通过指定索引时排序字段的升降序，来进行优化； 注意要遵循左前缀法进行索引。 如果要 filesort 可以适当增加排序缓冲区大小 sort_buffer_size。 group by 优化 分组操作时，可以通过索引来提高效率。 分组操作时，索引的使用也是满足最左前缀法。 limit 优化 # 不直接使用 limit 获取全部数据，而是只获取 id 然后再作为表查询 SELECT s.* FROM tb_sku s, (SELECT id FROM tb_sku ORDER BY id LIMIT 9000000, 10) a WHERE s.id = a.id; count 优化 MyISAM 引擎会把一个表的总行数存在磁盘上；InnoDB 引擎则需要一行一行地计算。\n# 效率排行 ：count(*) \u0026gt; count(1) \u0026gt; count(主键) \u0026gt; count(字段) update优化 InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。\n视图/存储过程/触发器 视图 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。其实，视图就是保留了 SQL 逻辑，不保存查询结果。\nWITH CHECK OPTION 子句创建时，MySQL 会检查正在更改的行是否符合视图的定义。MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查范围，MySQL 提供了两个选项： CASCADED（默认） 和 LOCAL。\n# 创建 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [with cascaded check option]; # 查询 SHOW CREATE VIEW 视图名称; SELECT * FROM 视图名称 ...; # 修改 CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句。 ALTER VIEW 视图名称[(列名列表)] AS SELECT语句。 # 删除 DROP VIEW [IF EXISTS] 视图名; 视图若包含一下项则不可更新：\n1、聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等）； 2、DISTINCT、GROUP BY、HAVING、UNION 或 UNION ALL。 作用：\n经常使用的查询可以被定义为视图，从而用户不必每次操作都指定操作来进行查询了； 数据库授权，通过视图用户只能查询和修改所能见到的数据； 视图可以帮助用户屏蔽真实表结构变化带来的影响。 存储过程 存储过程就是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。\n存储过程思想上，就是数据库 SQL 语句层面的代码封装与重用。可以接收参数，也可以返回数据，减少网络交互，提高效率。\n# 创建 # 通过关键字 delimiter 指定 SQL 语句结束符 /* delimiter $$ CREATE PROCEDURE 存储过程名称([参数列表]) BEGIN -- SQL 语句 END$$ */ CREATE PROCEDURE 存储过程名称([参数列表]) BEGIN -- SQL 语句 END; # 调用 CALL 名称([参数]); # 查看 SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = \u0026#39;xxx\u0026#39;; SHOW CREATE PROCEDURE 存储过程名称; # 删除 DROP PROCEDURE [IF EXISTS] 存储过程名称; 系统变量 是 MySQL 服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSIOM）。\n默认是改变 SESSION 变量。 MySQL 服务器重启后，设置的全局参数会失效，想要不失效，可以在 /etc/my.cnf 中配置。 # 查看系统变量 SHOW [SESSION|GLOBAL] VARIABLES; SHOW [SESSION|GLOBAL] VARIABLES LIKE ...; SELECT @@[SESSION|GLOBAL] 系统变量名; # 设置系统变量 SET [SESSION|GLOBAL] 系统变量名 = 值; SET @@[SESSION|GLOBAL] 系统变量名 = 值; 用户定义变量 是用户根据自己定义的变量，用户变量不用提前声明，在用的时候直接用 \u0026ldquo;@变量名\u0026rdquo; 使用。其作用域为当前连接。\n# 赋值 SET @var_name = expr; SET @var_name := expr; SELECT @var_name := expr; SELECT 字段名 INTO @var_name FROM 表名; # 使用 SELECT @var_name; 局部变量 根据需要定义的在局部生效的变量，访问之前，需要 DECLARE 声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的 BEGIN \u0026hellip; END 块。\n# 声明 DECLARE 变量名 变量类型 [DEFAULT ...]; # 赋值 SET 变量名 = 值; SET 变量名 := 值; SELECT 字段名 INTO 变量名 FROM 表名 ...; # if 语句 IF 条件1 THEN ... ELSEIF 条件2 THEN\t... ELSE ... END IF; # 参数 IN、OUT、INOUT CREATE PROCEDURE 存储过程名称([IN/OUT/INOUT 参数名 参数类型]) BEGIN -- SQL 语句 END; # case 语句 CASE case_value WHEN when_value1 THEN statement_list1 ... END CASE; CASE WHEN search_condition1 THEN statement_list1 ... END CASE; # while 语句 WHILE 条件 DO SQL 逻辑 END WHILE; # repeat 语句 REPEAT SQL 逻辑 UNTIL 条件 END REPEAT; # loop 函数 # LEAVE：退出循环；ITERATE：跳过当前循环，进入下次循环。 [begin_label:]LOOP SQL 逻辑 END LOOP [end_label]; CREATE PROCEDURE pp(IN n INT) BEGIN DECLARE total INT DEFAULT 0; sum:LOOP IF n \u0026lt;= 0 THEN LEAVE sum; END IF; SET total := total + n; SET n := n - 1; END LOOP sum; SELECT total; END; /* 游标（CURSOR）用来存储查询结果集的数据类型， 在存储过程和函数中可使用游标对结果集进行循环处理。 */ # 游标声明 DECLARE 游标名称 CURSOR FOR 查询语句; # 打开游标 OPEN 游标名称; # 获取游标记录(循环获取) FETCH 游标名称 INTO 变量; # 关闭游标 CLOSE 游标名称; # 条件处理程序 Handler # handler_action：CONTINUE 继续执行当前程序、EXIT 终止执行当前程序。 # SQLSTATE sqlstate_value 状态码、SQLWARNING 以01开头的SQLSTATE代码简写、NOT FOUND 以02开头的SQLSTATE代码简写、SQLEXCEPTION 其他。 DECLARE handler_action HANDLER FOR condition_value statement; DECLARE exit HANDLER FOR SQLSTATE \u0026#39;02000\u0026#39; CLOSE u_cursor; 存储函数 存储函数是有返回值的存储过程，存储函数的参数只能是 IN 类型的。\n/* DETREMINISTIC：相同的输入参数总是产生相同的结果; NO SQL：不包含 SQL 语句; READS SQL DATA：包含连续读取数据的语句，但不包含写入数据语句。 */ CREATE FUNCTION 存储函数名称([参数列表]) RETURNS type [characteristic ...] BEGIN -- SQL 语句 RETURN ...; END; 触发器 触发器是与表有关的数据库对象。在 insert/update/delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。\n触发器可以协助应用在数据库端保证数据的完整性，日记记录，数据校验等操作。\nOLD 和 NEW 引用触发器中变化的记录内容。支持行级触发。\nINTER 型触发器：NEW 表示将要或者已经新增的数据；\nUPDATE 型触发器：OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据。\nDELETE 型触发器：OLD 表示将要或已经删除的数据。\n# 创建 CREATE TRIGGER trigger_name BEFORE / AFTER INSERT / UPDATE / DELETE ON table_name FOR EACH ROW BEGIN triggle_statement; END; # 查看 SHOW TRIGGERS; # 删除 DROP TRIGGER [schema_name.]trigger_name; -- 通过触发器记录 tb_user 表的变更数据，将变更日志插入到日志表 user_logs 中，包含增加、修改、删除 # 日志表 user_log create table user_logs( id int(11) not null auto_increment; operation varchar(20) not null comment \u0026#39;操作类型\u0026#39;, operation_tim datetime not null comment \u0026#39;操作时间\u0026#39;, operate_id int(11) not null comment \u0026#39;操作ID\u0026#39;, operate_params varchar(500) comment \u0026#39;操作参数\u0026#39;, primary key(id) )engine=innodb default charset=utf8; # 插入数据触发器 create trigger tb_user_insert_trigger after insert on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params) values (null, \u0026#39;insert\u0026#39;, now(), new.id, concat(\u0026#39;插入的数据内容为：id=\u0026#39;, new.id, \u0026#39;, name=\u0026#39;, new.name, \u0026#39;, phone=\u0026#39;, new.phone, \u0026#39;, email=\u0026#39;, new.email)) end; # 更新数据触发器 create trigger tb_user_update_trigger after insert on tb_user for each row begin insert into user_logs(id, operation, operate_time, operate_id, operate_params) values (null, \u0026#39;update\u0026#39;, now(), new.id, concat(\u0026#39;更新前内容为：id=\u0026#39;, old.id, \u0026#39;, name=\u0026#39;, old.name, \u0026#39;, phone=\u0026#39;, old.phone, \u0026#39;, email=\u0026#39;, old.email,\u0026#39;更新后内容为：id=\u0026#39;, new.id, \u0026#39;, name=\u0026#39;, new.name, \u0026#39;, phone=\u0026#39;, new.phone, \u0026#39;, email=\u0026#39;, new.email)) end; 锁 锁是计算机协调多个进程或线程并发访问某一资源的机制。\n全局锁：锁定数据库中的所有表。 表级锁：每次操作都锁住整张表。 行级锁：每次操作锁住对应的行数据。 全局锁 加锁后，整个实例就处于只读状态。\n典型场景为全库数据的逻辑备份，对所有表进行锁定。\n1、如果在主库备份，那么备份期间数据不能更新，业务基本停摆；\n2、如果在从库备份，那么备份期间无法执行主库同步过来的二进制日志，主从不一致。\n# 不加锁一致性数据备份 mysqldump --single-transaction -h [address] -uroot -p1234 TestDB \u0026gt; TestDB.sql; # 加锁 flush tables with read lock; # 备份 mysqldump -h [address] -uroot -p1234 TestDB \u0026gt; TestDB.sql; # 解锁 unlock tables; 表级锁 锁定粒度大，发生锁冲突的概率最高，并发度最低。\n主要有这几类:\n表锁 表共享读锁（read lock）：不会阻塞其他客户端的读，但会阻塞写。 表独享写锁（write lock）：写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。 元数据锁（meta data lock）：系统自动控制，维护表元数据的一致性，在表上有活动事务时，不可以对元数据进行写入操作。 意向锁：避免行锁和表锁冲突，用意向锁使表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。 意向共享锁（IS）：与表共享锁（read）兼容，与表共享锁（read）互斥。 意向排他锁（IX）：与表共享锁（read）和表共享锁（read）都互斥。意向锁之间不互斥。 /* 当开启事务时，就不能对元数据进行操作，只有事务结束了才能操作。 一般来说，读数据是可以加表锁；而改数据是不能加表锁的。 */ # 表锁 LOCK TABLES 表名 READ / WRITE; UNLOCK TABLES / 客户端断开连接; # 加锁 SELECT 语句 LOCK IN SHARE MODE; # 查看元数据锁 SELECT * FROM performance_schema.metadata_locks; # 查看意向锁和行锁 SELECT * FROM performance_schema.data_locks; 行级锁 行级锁，每次操作锁对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。\nInooDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对应记录加的锁。\n行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行 update 和 delete。在 RC、RR 隔离级别下都支持。 间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录间隙不变，防止其他事务在间隙进行 insert ，产生幻读。在 RR 隔离级别下都支持。 临键锁（Next-Key-LOCK）：行锁和同隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。 共享锁（S）：允许一个事务去读一行，组织其他事务获取相同数据集的排他锁。\n排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务活得相同的数据集的共享锁和排他锁。\nSQL 行锁类型 说明 INSERT 排他锁 自动加锁 UPDATE 排他锁 自动加锁 DELETE 排他锁 自动加锁 SELECT 不加锁 / SELECT \u0026hellip; LOCK IN SHARE MODE 共享锁 手动加锁 SELECT \u0026hellip; FOR UPDATE 排他锁 手动加锁 1、对唯一索引进行检索，就是行锁。\n2、对没有索引的条件进行检索，会升级为表锁。\n3、索引上进行等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。\n4、索引上进行等值查询（普通索引），向右遍历到最后一个值都不满足查询需求时，next-key lock 退化为间隙。\n5、索引上进行范围查询（唯一索引），会访问直到不满足条件的第一个值为止。\nInnoDB 引擎 逻辑存储结构 TableSpace \u0026raquo;\u0026gt; Segment \u0026raquo;\u0026gt; Extent \u0026raquo;\u0026gt; Page \u0026raquo;\u0026gt; ROW\n表空间（ibd文件）：一个 MySQL 实例可以对应多个表空间，用于存储记录、索引等数据。\n段：数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）、InnoDB 是索引组织表，数据段就是 B+ 树的叶子节点，索引段为 B+ 树的非叶子几点。段用来管理区。\n区：表空间的单元结构，每个区大小为 1M。默认情况，InnoDB 存储引擎页大小为 16k，即一个区中一共有 64个 连续的页。\n页：InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。\n行：InnoDB 存储引擎数据是按行进行存放的。\nTrx_id：每次对某条记录进行改动时，都会把对应的事务 id 赋值给 trx_id 隐藏列。\nRoll_pointer：每次对某条引记录改动时，都会把旧版本写入到 undo 日志中，然后这个隐藏列就相当于一个指针，可以通过它找到该记录修改前的信息。\n架构 内存架构\nBuffer Pool：缓冲池是主内存中的一个区域，缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若没有数据，则从磁盘加载并缓冲），然后以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n缓冲池以 Page 页为单位，底层采用链表数据结构管理 Page。根据状态，将Page分为三种类型：free page 空闲页，没使用过；clean page 被使用过，但数据未修改；dirty page 脏页，就是被使用过也被修改过，与磁盘中的数据产生了不一致。\nChange Buffer：更改缓冲区（针对于二级索引页），在执行 DML 语句，如果数据没有在 Buffer Pool中，不会直接操作磁盘，而是将数据变更后的内容存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到 Buffer Pool中，再将合并后的数据刷新到磁盘中。\n因为二级索引是非唯一的，并且插入顺序是相对随机的，如果要对其更改每次操作都要依赖磁盘，这样会造成大量的磁盘 IO，有了 ChangeBuffer 后，我们可以在缓冲池汇总进行合并处理，减少磁盘 IO。\nAdaptive Hash Index：自适应 hash 索引，用于优化对 Buffer Pool 数据的查询。InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到 Hash 索引可以提升速度，则建立 Hash 索引，称之为自适应 Hash 索引。参数：adaptive_hash_index。\nLog Buffer：日志缓冲区，用来保护要写入到磁盘中的 log 日志数据（redo log、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除多行的事务，增加日志缓冲区的大小可以节省磁盘 IO。参数：innodb_log_buffer_size、innodb_flush_log_at_trx_commit。1：日志在每次事务提交时写入并刷新到磁盘；0：每秒将日志写入并刷新到磁盘一次；2：日志在每次事务提交后写入，并每秒刷新到磁盘一次。\n磁盘结构\nSystem TableSapce：系统表空间是更改缓冲区的存储区域。如果表是在系统空间而不是每个表文件或通用表空间创建的，它也可能包含表和索引数据。参数：innodb_data_file_path。\nFile-Per-Table Tablespace：每个表的文件表空间包含单个 InnoDB 表的数据和索引，并存储在文件系统上的单个数据文件。参数：innodb_file_per_table。\nGeneral Tablespaces：通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。\n# 创建表空间 CREATE TABLESPACE xxx ADD DATAFILE \u0026#39;file_name\u0026#39; ENGINE = engine_name; # 创建表 CREATE TABLE xxx TABLESPACE ts_name; Undo TableSpaces：撤销表空间，MySQL 实例在初始化时会自动创建两个默认的 undo 表空间（初始大小16M），用于存储undo log日志。\nTemporay Tablespaces：InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表数据。\nDoublewrite Buffer Files：双写缓冲区，InnoDB 引擎将数据页从 Buffer Pool 刷新到磁盘前，线将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。\nRedo Log：重写日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事务提交后会把所有修改信息都会存到日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。循环写入重做日志文件，涉及两个文件：ib_logfile0、ib_logfile1。\n后台线程\nMaster Thread：核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓冲、undo页的回收。\nIO Thread：AIO负责IO请求的回调。Read thread （4）、Write thread（4）、Log thread（1）、Insert buffer thread（1）。\nSHOW ENGINE innodb status; Purge Thread：主要用于回收事务已经提交了的undo log，在事务提交后，undo log可能不用了，就用它来回收。\nPage Cleaner Thread：协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。\n事务原理 事务就是一组操作的集合，将所有操作视作是一个整体向系统提交，若是其中某个操作失败了，就会执行回滚操作。\n事务具有 ACID 的特性：\n原子性，就是事务不可分割，要么全部执行成功，要么全部执行失败。\n一致性，事务完成时，必须让所有数据保持一致性。\n隔离性，事务不受外部并发操作影响。\n持久性，事务一旦提交或回滚，数据的改变就是永久的。\n原子性 - undo log\n持久性 - redo log\n一致性 - undo log + redo log\n隔离性 - 锁 + MVCC\nredo：重做日志，记录的是事务提交时数据页的物理修改，用来实现事务的持久性。\n该日志文件由两部分组成，重做日志缓冲（redo log buffer）、重做日志文件（redo log file）。前者是在内存中，后者在磁盘中，当事务提交后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。\nundo：回滚日志，用于记录数据被修改前的信息，包括提交回滚和MVCC（多版本并发控制）。undo log 和 redo log 记录物理日志不一样，他是逻辑日志。也就是当用户执行一次 delete 记录时，undo log 会记录一条 insert 记录，以方便回滚。\nundo log 销毁：undo log 在事务执行时产生，事务提交时，不会立刻删除 undo log，因为这些日志还用于 MVCC。\nundo log 存储：undo log 采用段方式进行管理和记录，存放在前面介绍 rollback segment 回滚段中，内部包含 1024 个 undo log segment。\nMVCC 当前读：读取记录的最新版本，读取时保证其他并发事务不能修改当前记录，会对读取记录进行加锁。\n快照读：简单的 select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。\nRead Committed：每次 select 都生成一个快照读。 Repetabel Read：开启事务后第一个 select 语句是快照读。 Serializable：快照读退化为当前读。 MVCC：Multi-Version Concurrency Control，多版本并发控制。也就是维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，依赖数据库记录中的三个隐式字段、undo log日志、readView。\n隐藏字段：\nDB_TRX_ID 最近修改事务ID，记录插入这条记录或最后一次修改为该记录的事务ID。 DB_ROLL_PTR 回滚指针，指向这条记录的上个版本，用于配合 undo log，指向上个版本。 DB_ROW_ID 隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。 undo log：回滚日志，在 insert、update、delete 时产生便于数据回滚的日志。当 insert 的时候，产生的 undo log 日志只在回滚时需要，在事务提交后，可被立即删除。而 update、delete 的时候，产生的 undo log 日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。\n不同事务或相同事务对同一条记录修改，会导致该记录的 undo log 生成一条记录版本链表，链表头部是最新的旧记录，链表尾部是最早的旧记录。\nreadview：读视图，是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。\nm_ids 当前活跃的事务ID集合。 min_trx_id 最小活跃事务ID。 max_trx_id 预分配事务ID，当前最大事务ID+1。 creator_trx_id ReadView 创建者事务ID。 版本链数据访问规则：\nREAD COMMITED：在事务中每一次执行快照读时生成ReadView。\nREPEATABLE READ：仅在事务第一次执行汇快照读时生成ReadView，后续复用该 ReadView。\nTRX_ID == CREATOR_TRX_ID（✓）- 数据是当前事务更改的。 TRX_ID \u0026lt; MIN_TRX_ID（✓）- 说明数据已经提交了。 TRX_ID \u0026gt; MAX_TRX_ID（×）- 说明事务是在 ReadView 生产后才开启。 MIN_TRX_ID \u0026lt;= TRX_ID \u0026lt;= MAX_TRX_ID（不在集合中可访问）- 说明数据已经提交。 MySQL 管理 系统数据库 MySQL 自带四个数据库：\nmysql 存储 MySQL 服务器正常运行所需要的各种信息 （时区、主从、用户、权限等）。 information_schema 提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等。 performance_schema 为 MySQL 服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数。 sys 包含了一系列方便 DBA 和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图。 常用工具 MySQL 客户端\n语法：mysql [options] [database]\n选项：-u, \u0026ndash;user=name\n​\t-p,\u0026ndash;password[=name]\n​\t-h,\u0026ndash;host=name\n​\t-p,\u0026ndash;port=port\n​\t-e,\u0026ndash;excute=name\nmysql -uroot -p123456 db01 -e \u0026#34;select * from stu*\u0026#34; mysqladmin：执行管理操作的客户端程序，用它来检查服务器的配置和当前状态、创建并删除数据库等。\nmysqladmin -uroot -p123456 drop \u0026#39;test01\u0026#39; mysqladmin -uroot -p123456 version mysqlbinlog：由服务器生成对二进制日志文件以二进制格式保存，如果想要检查这些文本格式，就会用到该日志管理工具\n语法：mysqlbinlog [options] log-files1 log-file2\n选项：-d,\u0026ndash;database=name\t指定数据库名称，只列出指定的数据库相关操作\n​\t-o,\u0026ndash;offset=#\t忽略日志中的前n行命令\n​\t-r,\u0026ndash;result-file=name\t将输出的文本格式日志输出到指定文件\n​\t-s,\u0026ndash;short-form\t显示简单格式，省略掉一些信息\n​\t-v\t将行事件（数据变更）重构为 SQL 语句\n​\t-vv\t将行事件（数据变更）重构为 SQL 语句，并输出注释信息\n​\t\u0026ndash;start-datetime=date1 \u0026ndash;stop-datetime=date2\t指定日期间隔内的所有日志\n​\t\u0026ndash;start-position=pos1 \u0026ndash;stop-position=pos2\t指定位置间隔内的所有日志\nmysqlshow：mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。\n语法：mysqlshow [options] [db_name [table_name [col_name]]]\n选项：\u0026ndash;count\t显示数据库及表的统计信息（数据库，表均可以不指定）\n​\t-i\t显示指定数据库或者执行表的状态信息\n# 查询每个数据库的表的数量以及表中记录的数量 mysqlshow -uroot -p1234 --count # 查询 test 库中每个表的字段数，以及行数 mysqlshow -uroot -p1234 test --count # 查询 test 库中 book 表的详细情况 mysqlshow -uroot -p1234 test book --count mysqldump：用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，以及插入表的 SQL 语句。\n语法：mysqldump [options] db_name [tables]\n​\tmysqldump [options] \u0026ndash;database/-B db1 [db2 db3 \u0026hellip;]\n​\tmysqldump [options] \u0026ndash;all-database/-A\n连接选项：-u,\u0026ndash;user=name\n​\t-p,\u0026ndash;password[=name]\n​\t-h,\u0026ndash;host=name\n​\t-p,\u0026ndash;port=#\n输出选项：\u0026ndash;add-drop-database\t在每个数据库创建语句前加上 drop database\n​\t\u0026ndash;add-drop-table\t在表创建语句前加上 drop table\n​\t-n,\u0026ndash;no-create-db\t不包含数据库的创建\n​\t-t,\u0026ndash;no-create-info\t不包含数据表的创建\n​\t-d,\u0026ndash;no-data\t不包含数据\n​\t-T,\u0026ndash;tab-name\t自动生成两个文件，一个.sql文件，创建表结构;一个.txt文件，数据文件。（show variables liek '%secure_file_priv;'）\nmysqlimport/soucre：数据导入工具，用来导入 mysqldump -T 导出的文本文件。\n语法：mysqlimport [options] db_name textfile1 [textfile2 \u0026hellip;]\n​\tsource /root/xxxx.sql\nsource /root/test.sql mysqlimport -uroot -p1234 test /tmp/city.txt 运维篇 日志 错误日志 错误日志记录了 mysqld 启动和停止时，以及在运行过程中发生任何错误时的相关信息。该日志默认开启，存放目录为 /var/log/，默认日志文件名mysqld.log。\n# 查看日志文件地址 SHOW VARIABLES LIKE \u0026#39;%log_error%\u0026#39;; 二进制日志 二进制日志（BINLOG）记录了所有 DDL 和 DML 语句，但不包含 DQL 语句。\n作用：灾难时的数据恢复；MySQL 主从复制\n# 查看日志文件地址 SHOW VARIABLES LIKE \u0026#39;%log_bin\u0026#39;; MySQL 提供了多种格式来记录二进制日志：\nSTATEMENT - 基于 SQL 语句的日志记录，记录的是 SQL 语句，对数据进行修改的 SQL 都会记录在日志文件中。 ROW - 基于行的日志记录，记录的是每一行的数据。 MIXED - 混合了 STATEMENT 和 ROW 两种格式，默认采用 STATEMENT，在某些特殊情况下会自动切换为 ROW 进行记录。 # 查看格式 SHOW VARIABLES LIKE \u0026#39;%binlog_format%\u0026#39;; 日志删除方式：\nreset master\t删除全部 binlog 日志，删除后，日志编号，将从 binlog.000001 重新开始 purge master logs to \u0026lsquo;binlog.xxxxxx\u0026rsquo; 删除 xxxxxx 编号之前的所有日志 purge master logs before \u0026lsquo;yyyy-mm-dd hh24:mi:ss\u0026rsquo; 删除日志为 \u0026lsquo;yyyy-mm-dd hh24:mi:ss\u0026rsquo; 之前产生的所有日志 可以在 MySQL 配置文件 /etc/my.cnf 中配置二进制日志：\nSHOW VARIABLES LIKE \u0026#39;%binlog_expire_logs_seconds%\u0026#39;; 查询日志 查询日志记录了客户端所有操作语句，而二进制日志不包含数据的 SQL 语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以设置配置：\n# 查询 general_log 是否开启 SHOW VARIABLES LIKE \u0026#39;%general%\u0026#39;; # 在配置中开启查询日志 general_log = 1 # 设置文件名默认为 host_name.log general_log_file = mysql_query.log 慢查询日志 慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录不小于 min_examined_row_limit 的所有 SQL 语句日志，默认未开启。long_query_time 默认为 10 秒，最小为 0，精度可到微秒。\n# 慢查询日志 slow_query_log = 1 # 执行时间参数 long_query_time = 2 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用 log_slow_admin_statements 和更改此行为 log_queries_not_using_indexes。\n# 记录执行较慢的管理语句 log_slow_admin_statements = 1 # 记录执行较慢的未使用索引的语句 log_queries_not_using_indexs = 1 主从复制 概述 主从复制就是将数据库的 DDL 和 DML 操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。\nMySQL 支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。\n1.主库出现问题，可以快速切换到从库提供服务。 2.实现读写分离，降低主库的访问压力。 3.可以在从库中执行备份，以避免备份期间影响主库服务。 原理 1、Master 主库提交事务时，会将数据变更记录在二进制日志文件 Binlog 中。\n2、从库读取主库的二进制文件 Binlog ，写入到从库的中继日志 Replay Log。\n3、slave 重做中继日志中的事件，将改变反映它自己的数据。\n搭建 服务器准备：\n192.168.200.200（master）\n192.168.200.201（slave）\n# 开放指定 3306 端口号 firewall-cmd --zone=public --add-port=3306/tcp -permanent firewall-cmd -reload # 关闭服务器防火墙 systemctl stop firewalld systemctl diable firewalld 主库配置：\n1、修改配置文件 /etc/my.cnf\n# mysql 服务器 ID，确保集群中唯一 server-id = 1 # 是否只读，1 代表只读，0代表读写 read-only = 0 # 忽略的数据，指不需要同步的数据库 # binlog-ignore-db = mysql # 指定同步的数据库 # binlog-do-db = db01 2、重启 MySQL 服务器\nsystemctl restart mysqld 3、登录 MySQL，创建远程连接账号，并授予主从复制权限\n# 创建用户 CREATE USER \u0026#39;master\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;root@123456\u0026#39;; # 分配主从复制权限 GRANT REPLICATION SLAVE ON *.* TO \u0026#39;master\u0026#39;@\u0026#39;%\u0026#39; 4、查看二进制日志坐标\n/* file 从哪个日志文件开始推送 postions 从哪个位置开始推送 binlog_ignore_db 指定不需要同步的数据库 */ SHOW MASTER STATUS; 从库配置：\n1、修改配置文件 /etc/my.cnf\n# 设置服务器 ID server-id = 2 # 是否只读 read-only = 1 2、重启 MySQL\nsystemctl mysql restart 3、登录 MySQL，设置主库配置\nCHANGE REPLICATION SOURCE TO SOURCE_HOST=\u0026#39;xxx.xxx\u0026#39;,SOURCE_USER=\u0026#39;xxx\u0026#39;,SOURCE_PASSWORD=\u0026#39;xxx\u0026#39;,SOURCE_LOG_FILE=\u0026#39;xxx\u0026#39;,SOURCE_LOG_POS=xxx; 4、开启同步操作\nSTART REPLICA; 5、查看主从同步状态\nSHOW REPLICA STATUS; ​\n","date":"2024-03-22T15:51:46+08:00","image":"https://yikuanzz.github.io/2024/mysql/cover_huf4d320014c591f4e374d934afecc756b_255935_120x120_fill_box_smart1_3.png","permalink":"https://yikuanzz.github.io/2024/mysql/","title":"MySQL"}]